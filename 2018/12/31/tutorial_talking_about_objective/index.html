<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yimig.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="不知不觉18年就过完了，转眼间又到了考试季，各位小伙伴们都复习的怎么样啊？ 好吧今天我们不谈考试，就坐下来好好说说这个“面向对象”的概念，有些同学可能一学期下来也搞不清这个到底有什么用、怎么用。这次就结合Java，当然也不只有Java，来说说面向对象的语言特性，彻底缕清这个概念。">
<meta property="og:type" content="article">
<meta property="og:title" content="【教程】泛谈“面向对象”">
<meta property="og:url" content="http://yimig.github.io/2018/12/31/tutorial_talking_about_objective/index.html">
<meta property="og:site_name" content="Tim&#39;s Blog">
<meta property="og:description" content="不知不觉18年就过完了，转眼间又到了考试季，各位小伙伴们都复习的怎么样啊？ 好吧今天我们不谈考试，就坐下来好好说说这个“面向对象”的概念，有些同学可能一学期下来也搞不清这个到底有什么用、怎么用。这次就结合Java，当然也不只有Java，来说说面向对象的语言特性，彻底缕清这个概念。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://upane.cn/wp-content/uploads/2018/04/35.png">
<meta property="og:image" content="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-30-57.png">
<meta property="og:image" content="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-34-19.png">
<meta property="og:image" content="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-35-08.png">
<meta property="og:image" content="http://upane.cn/wp-content/uploads/2018/12/notepad_2018-12-31_13-11-15-1024x493.png">
<meta property="og:image" content="http://upane.cn/wp-content/uploads/2018/12/notepad_2018-12-31_13-16-33-1024x493.png">
<meta property="og:image" content="http://upane.cn/wp-content/uploads/2018/03/51.png">
<meta property="article:published_time" content="2018-12-31T13:12:59.000Z">
<meta property="article:modified_time" content="2020-10-28T14:57:56.535Z">
<meta property="article:author" content="Tim">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://upane.cn/wp-content/uploads/2018/04/35.png">

<link rel="canonical" href="http://yimig.github.io/2018/12/31/tutorial_talking_about_objective/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【教程】泛谈“面向对象” | Tim's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?64126ab668fa908027cba9464a0afec7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tim's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learn Everything!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yimig" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yimig.github.io/2018/12/31/tutorial_talking_about_objective/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Tim">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tim's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【教程】泛谈“面向对象”
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-31 21:12:59" itemprop="dateCreated datePublished" datetime="2018-12-31T21:12:59+08:00">2018-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-28 22:57:56" itemprop="dateModified" datetime="2020-10-28T22:57:56+08:00">2020-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tutorial/" itemprop="url" rel="index"><span itemprop="name">Tutorial</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              <span>9.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>不知不觉18年就过完了，转眼间又到了考试季，各位小伙伴们都复习的怎么样啊？ <a target="_blank" rel="noopener" href="http://upane.cn/wp-content/uploads/2018/04/35.png"><img src="http://upane.cn/wp-content/uploads/2018/04/35.png" alt=""></a><br>好吧今天我们不谈考试，就坐下来好好说说这个“面向对象”的概念，有些同学可能一学期下来也搞不清这个到底有什么用、怎么用。这次就结合Java，当然也不只有Java，来说说面向对象的语言特性，彻底缕清这个概念。<br><a id="more"></a></p>
<h2 id="①基础"><a href="#①基础" class="headerlink" title="①基础"></a>①基础</h2><p>有些东西需要你在本次学习之前彻底搞清，以便下面的学习得更轻松，这里讲一下几个概念，如果会的话可以跳过。</p>
<h3 id="㈠声明和实例化"><a href="#㈠声明和实例化" class="headerlink" title="㈠声明和实例化"></a>㈠声明和实例化</h3><p>有些同学读课本代码时可能经常发现这样一句话： <strong>XXX xxx=new XXX();</strong> 大家都知道，这是<strong>创建对象的过程</strong>，其中XXX是类名，xxx是新创建的对象名，但是这具体是什么意思呢？ 其实，这句话干了两件事，分别是： <strong>①XXX xxx； ②xxx=new XXX();</strong> 其中第一步是<strong>声明对象</strong>，第二步是<strong>实例化对象</strong> 通俗点讲，比如这是一个做泥塑的过程，声明对象就是向电脑要了一堆泥，而实例化就是把这堆泥捏成了泥塑。 那么，具体要怎么把泥捏成泥塑呢？这就需要调用类的<strong>构造函数</strong>了，所以说，第二步后面的XXX()与前面声明的类XXX并没有必然的联系，它只是个构造函数，在特定情况下也可以写其他类的构造函数，这个我们后面再讲。 有点晕？没关系我们看一个例子： 建立一个名为“Student”的类，类包含字段“班级”（theClass）和“学号”（schoolNum）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String theClass;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> schoolNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们分别对其声明并实例化，然后调试： <a target="_blank" rel="noopener" href="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-30-57.png"><img src="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-30-57.png" alt=""></a> 可以看到，最开始没有student这个对象，我们对其声明后就有了这个对象，但是值为null，空，但是我们知道Student类是有结构的（两个字段），只是null的话连结构都没有。 然后我们继续运行，让它实例化。 <a target="_blank" rel="noopener" href="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-34-19.png"><img src="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-34-19.png" alt=""></a> 实例化之后student的值就变成了{Student}，我们打开变量监视器可以看到其中的结构已经就绪。 <a target="_blank" rel="noopener" href="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-35-08.png"><img src="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-35-08.png" alt=""></a> 所以，如果你的编译器报了空指针错误（nullpointer），那多半就是没实例化导致的。这样是不是就多少明白些这两步的关系了？ <strong>总结：声明就是按照类中的结构大小分配存储空间，并没有真正地构造对象，只有使用了构造函数将其实例化，一个完整的对象框架才会被真正建立起来。</strong></p>
<h3 id="㈡构造函数"><a href="#㈡构造函数" class="headerlink" title="㈡构造函数"></a>㈡构造函数</h3><p>刚刚讲实例化的时候我们就接触过构造函数了，并且知道它的作用是构建对象框架。那么它和普通函数还有什么区别吗？是不是随便一个函数都可以作为构造函数呢？ 首先我们要明确的就是，<strong>不管是什么类都默认有构造函数</strong>，只是有的类不能被实例化（比如抽象类），并且它是<strong>默认存在的</strong>，即你不定义它，它也会自动生成，只是除了实例化对象之外没有其他操作了而已。 然后，我们再讲一下它和普通函数的区别： 1. 它只能在对象被实例化的时候调用，且调用时必须加关键字<strong>new</strong> 2. 构造函数的名字<strong>必须与类名相同</strong> 3. 构造函数<strong>默认且必须返回值为空</strong>，因为这个规则，构造函数就可以省略返回类型而直接写函数名 稍微解释一下，以构造函数的用途思考这些规则其实都能想通，构造函数只为实例化对象而生，肯定只能在实例化的时候调用，并且肯定与类名相同，要不谁知道是哪个类啊？“实例化”本身就是个动作，这个动作注定它不能返回什么值，而是指使计算机去做出什么，所以肯定返回值是空。最后需要注意的是构造函数的访问修饰符一般是public，否则就无法在其他类里调用其实例化了。</p>
<h2 id="②正篇"><a href="#②正篇" class="headerlink" title="②正篇"></a>②正篇</h2><p>说了这么多终于进入正题了，下面我们就好好谈谈这个面向对象到底是什么，有什么好处，为什么这么多语言都用这个概念，具体该怎么用。</p>
<h3 id="㈠对象是什么？"><a href="#㈠对象是什么？" class="headerlink" title="㈠对象是什么？"></a>㈠对象是什么？</h3><p>说白了，它就是个东西（<strong>object</strong>），你管它什么东西（<strong>object</strong>），它就是个东西（<strong>object</strong>）。 东西是什么？什么都有可能，<strong>只要数据能描述这个东西，那它就能成为对象。</strong> 注意我把这个单词<strong>object</strong>加粗了，这是英文原版的“对象”，如果不了解这个单词希望去查一下词典，看看其名词形式下都有什么释义，这样你就会对“对象”这个概念有所体会。 我觉得其实叫“面向东西”更能表达其精髓，但是这么翻译太难听了，还是面向对象吧。</p>
<h3 id="㈡那么面向东西，呃不面向对象有什么用？"><a href="#㈡那么面向东西，呃不面向对象有什么用？" class="headerlink" title="㈡那么面向东西，呃不面向对象有什么用？"></a>㈡那么面向东西，呃不面向对象有什么用？</h3><h4 id="⑴条理化的数据操作"><a href="#⑴条理化的数据操作" class="headerlink" title="⑴条理化的数据操作"></a>⑴条理化的数据操作</h4><p>我们编程为了什么？简化用户操作？优化用户体验？这不能，都太表面了，这往白了说，就是<strong>处理数据</strong>！ 处理什么数据？肯定不是一点数据，如果数据少那人算就可以了，根本用不着专门写个程序，所以我们处理的是大量的数据！至少量大到需要专门写个程序分析才行。 为了给大家一个客观的感受，放出来前几天扒的QQ音乐网页版搜索返回值： <a target="_blank" rel="noopener" href="http://upane.cn/wp-content/uploads/2018/12/notepad_2018-12-31_13-11-15.png"><img src="http://upane.cn/wp-content/uploads/2018/12/notepad_2018-12-31_13-11-15-1024x493.png" alt=""></a> 以上是搜索了“测试”这两个字的返回结果，为了保证可读性我进行了一点优化，这里每一行都是一条数据对象，也就是一个音乐。。的东西，只不过不是Java的对象，是JavaScript的对象，每行长度在880字到1024字之间，其中每条数据对象中都有非常多的字段，要想顺利承接这些字段，我需要整理它的结构。通过分析，得到每条数据的结构如下： <a target="_blank" rel="noopener" href="http://upane.cn/wp-content/uploads/2018/12/notepad_2018-12-31_13-16-33.png"><img src="http://upane.cn/wp-content/uploads/2018/12/notepad_2018-12-31_13-16-33-1024x493.png" alt=""></a> 其中每个大括号里面又是这个类的子类。可以看出，其中数据真的非常多，但是却十分条理，分门别类地存储在相应的字段中，找起来也十分方便。 返回我们之前的话题中，程序员需要写图一中的每一条数据吗？并不是，程序员写的只是图二中的结构（类），结构写完，数据就自动根据位置“穿”进去了，强迫症福利，是不是？</p>
<h4 id="⑵模块化，易于维护"><a href="#⑵模块化，易于维护" class="headerlink" title="⑵模块化，易于维护"></a>⑵模块化，易于维护</h4><p>刚刚讲的数据操作其实用C语言的结构体也可以做到，但是C语言不是面向对象的，所以要说起面向对象真正的优势，还在于模块化上。 那么类比结构体多的不就是能在里面写函数吗？对，<strong>所以我们不需要把函数“随用随写”，而是把属于这个类的函数专门写在这个类里，用的时候直接调用，这就是模块化了</strong>。哪里好呢？比如我A类的函数写好，调用之发现运转正常，这个类就可以不管了，B类调用的时候出现问题那肯定是B类的故障而不是A类，一个模块就干一个事。为了让程序员方便知道一个对象中有哪些数据可以动，哪些不能动，还引入了封装的概念，这个我们在下面也会提到。 另外也为程序的拓展带来了方便，copy别人的代码更爽了（逃</p>
<h4 id="⑶灵活多变，省时省力"><a href="#⑶灵活多变，省时省力" class="headerlink" title="⑶灵活多变，省时省力"></a>⑶灵活多变，省时省力</h4><p>通过继承一个类，我们可以快速得到很多有共同特性的派生类，还可以进行重写（override）区分派生类中的特性。</p>
<h3 id="㈢那该怎么用？"><a href="#㈢那该怎么用？" class="headerlink" title="㈢那该怎么用？"></a>㈢那该怎么用？</h3><p>好了，到这里就是我们这个文章的核心了，我的真正目标是教会大家明确对象这个概念，并且能用这个概念写出<strong>条理清楚、整洁的代码</strong></p>
<h4 id="⑴重中之重，先别急着写代码，想想咱要干嘛！"><a href="#⑴重中之重，先别急着写代码，想想咱要干嘛！" class="headerlink" title="⑴重中之重，先别急着写代码，想想咱要干嘛！"></a>⑴重中之重，先别急着写代码，想想咱要干嘛！</h4><p>要求学生的平均分还是算正方形的面积？一共需要几个类？哪个类是负责统筹主逻辑的？哪个类是负责记载数据的？算平均分的话需要哪些数据？数据类型应该是什么？…… 这些都是必须要考虑的问题，特别是今后要写较大项目的时候，不管是和别人一起写还是自己独干，千万别图一时手快，否则写着写着突然发现结构不对进行不下去了，要全部重构的时候就等着哭咯！</p>
<h4 id="⑵明确结构"><a href="#⑵明确结构" class="headerlink" title="⑵明确结构"></a>⑵明确结构</h4><p>这个结构不是指的上面说的具体结构，而是类的结构，总体来讲类的结构分为以下四个： 1. 字段 字段就是直接在类里面定义的<strong>变量</strong>，该变量可以在类里共享，是否与外界共享要看访问修饰符。 2. 访问器 访问器就是get/set，用来设置字段的，<strong>可以在一定程度上对读/取进行限制，以达到封装的目的</strong>，值得一提的是，访问器本质上就是个普通函数，只是我们为这类普通函数起了一个共有的名字而已，但是我们完全可以把它当作一个普通函数来记忆。 3. 方法 方法就是类中的<strong>函数</strong>。 4. 内部类 内部类不太常见，但也是类中的结构之一，<strong>注意内部类可以读取外部类的字段，也可以调用外部类的函数。</strong></p>
<h4 id="⑶封装"><a href="#⑶封装" class="headerlink" title="⑶封装"></a>⑶封装</h4><p>了解了结构，我们就开始封装类了。我们都知道创立了类、构建了结构肯定是要对数据进行存取，定义好哪些可以存，哪些可以取，这样不管是对别人还是对自己都能起到良好的导航效果，我们的目标就是只暴露需要的，不需要的统统隐藏。 那我们就需要了解访问修饰符了： 访问修饰符分为<strong>访问符</strong>和<strong>修饰符</strong>，我们先从比较好说的访问符开始：</p>
<h6 id="访问符，顾名思义，就是用来修饰访问性的-下面我们就来比较一下Java的四个访问符（没有也算一个）标识的可访问性："><a href="#访问符，顾名思义，就是用来修饰访问性的-下面我们就来比较一下Java的四个访问符（没有也算一个）标识的可访问性：" class="headerlink" title="访问符，顾名思义，就是用来修饰访问性的,下面我们就来比较一下Java的四个访问符（没有也算一个）标识的可访问性："></a>访问符，顾名思义，就是用来修饰访问性的,下面我们就来比较一下Java的四个访问符（没有也算一个）标识的可访问性：</h6><p>同一个类</p>
<p>同一个包</p>
<p>不同包的子类</p>
<p>不同包的非子类</p>
<p>private</p>
<p>√</p>
<p>没有访问符</p>
<p>√</p>
<p>√</p>
<p>protected</p>
<p>√</p>
<p>√</p>
<p>√</p>
<p>public</p>
<p>√</p>
<p>√</p>
<p>√</p>
<p>√</p>
<h6 id="然后我们再来讲讲修饰符，修饰符的目的就是再对被修饰的语句进行进一步的解释，赋予其更多功能："><a href="#然后我们再来讲讲修饰符，修饰符的目的就是再对被修饰的语句进行进一步的解释，赋予其更多功能：" class="headerlink" title="然后我们再来讲讲修饰符，修饰符的目的就是再对被修饰的语句进行进一步的解释，赋予其更多功能："></a>然后我们再来讲讲修饰符，修饰符的目的就是再对被修饰的语句进行进一步的解释，赋予其更多功能：</h6><p>修饰符</p>
<p>功能</p>
<p>abstract</p>
<p>抽象语句，用于类和方法的修饰，具体下节讲</p>
<p>final</p>
<p>表示“固定”、不可变，用在字段的定义中就代表常量，用在类的定义中就代表该类不可被继承</p>
<p>static</p>
<p>静态语句,可修饰类、字段、方法，具体下节讲</p>
<p>了解了访问修饰符我们才能真正开始封装，那么，具体应该怎样封装呢？下面有几种常用封装手段： <strong>封装字段的手段：（默认以全部使用private封装）</strong></p>
<p>封装手段</p>
<p>写入</p>
<p>读出</p>
<p>优势</p>
<p>劣势</p>
<p>访问符public或者不写访问符)</p>
<p>√</p>
<p>√</p>
<p>方便，只改修饰符就成</p>
<p>不受控制的修改，暴露程度太高</p>
<p>利用构造函数</p>
<p>√</p>
<p>×</p>
<p>实例化对象时即进行赋值，大大减少代码量</p>
<p>如不通过其他手段则写入的值无法读出</p>
<p>设置访问器</p>
<p>√</p>
<p>√</p>
<p>在变量被修改前可以进行筛选等高级控制</p>
<p>麻烦，需要专门另写方法</p>
<p><strong>封装方法则一律使用修饰符。</strong> 可根据需要灵活选择解决方案，也可同时使用多种手段。</p>
<h4 id="⑷掌握类之间的关系：继承与多态"><a href="#⑷掌握类之间的关系：继承与多态" class="headerlink" title="⑷掌握类之间的关系：继承与多态"></a>⑷掌握类之间的关系：继承与多态</h4><p>这是最后一节了，学会了就胜利了，加油！</p>
<h5 id="1-特殊情况：静态"><a href="#1-特殊情况：静态" class="headerlink" title="1.特殊情况：静态"></a>1.特殊情况：静态</h5><p>在学习类之间的关系之前我们要先解决上一节遗留下来的一个问题：<strong>静态关系</strong>。 之所以不在上节讲是因为其与封装关系不大，但是与这一节的关系也不大，单独拿出来内容又太少，所以只好放在这里了，望见谅。 那么静态到底是什么？ 我们知道类中的结构和方法是无法直接使用的，必须通过实例化为对象再使用，<strong>可是有些方法/字段我们只使用一次，或者说没有必要单独成为对象，我们就可以把它写为静态方法/字段</strong>，这样一来，在调用时不需要实例化，直接类名.方法/字段就可以使用它们了。 <strong>注意静态方法有个坑，就是静态方法只能引用静态方法，不能引用非静态方法，但是反过来——非静态方法可以引用所有方法</strong> 值得一提的是，类也可以被静态修饰符修饰，那样就是静态类，静态类必须是内部类。正常情况下我们必须实例化外部类才能进一步实例化内部类，但是静态类可以允许我们直接实例化某个内部类，当然与普通类相比还有其他微小的差别，若感兴趣可以去百度一下，这里就不展开讲了。</p>
<h5 id="2-继承（相同）"><a href="#2-继承（相同）" class="headerlink" title="2.继承（相同）"></a>2.继承（相同）</h5><p>我这里加了个括号，写了个相同，意思是继承的主要目标是操作类与类之间相同的地方，<strong>A类继承B类，将得到B类所有已定义的结构，包括字段、访问器、方法、内部类</strong> 而这一切，只需要你在定义的类名后加个<strong>extend</strong>即可。 我们定义了山羊类，可以很轻松地继承出绵羊类。当然你也可以从羊类继承出山羊类和绵羊类，但是两者差异不大，绵羊不就是多点毛么，直接从山羊类继承出来也未尝不可。</p>
<h5 id="3-多态（差异）"><a href="#3-多态（差异）" class="headerlink" title="3.多态（差异）"></a>3.多态（差异）</h5><p>多态我们主讲差异，刚刚我们讲了继承，讲了A类能从B类继承所有内容，但是如果我想突出A类与B类的不同呢？ 比如，同是大学生，但是少林寺章丘分寺的大学生武术不及格就不能毕业，那么关于毕业这个算法，从大学生类继承出来的少林寺章丘分寺的大学生类肯定不能相同，为了实现这个功能，我们引入重写（override）的概念，注意这不是重构（overload）哈，别搞混了，忘了重构的自己去查，这里不讲了。 重写就是直接把要重写的函数在子类再写一遍，内容和父类不同就是了。这个很好理解，记得不仅<strong>方法可以重写，字段也可以重写</strong>。 好了重写讲完了，下面我们来讲讲所谓真正的多态： 还是刚刚的大学生类，但是我们给他多一个函数，让他说自己会不会打武术：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> string theClass;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> schoolNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isMartial</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不会打武术&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再继承出一个少林寺章丘分寺的大学生类，重写会不会打武术的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QSStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isMartial</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;作为少林寺章丘分寺的学生，像你这种问题，我就三个字！打!....扰了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点来了，我们这样调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student=<span class="keyword">new</span> QSStudent();</span><br><span class="line">student.isMartial();</span><br></pre></td></tr></table></figure>
<p>对，你没看错，构造函数和前面声明的类不一样！请问会写出什么？ 答案是：</p>
<blockquote>
<p>作为少林寺章丘分寺的学生，像你这种问题，我就三个字！打!….扰了</p>
</blockquote>
<p>然后我们再做一个实验：实例化一个Student数组，然后分别用Student的构造方法和QSStudent的构造方法为其中的元素实例化，看看有什么效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student[] students=<span class="keyword">new</span> Student[<span class="number">2</span>];</span><br><span class="line">students[<span class="number">0</span>]=<span class="keyword">new</span> Student();</span><br><span class="line">studnets[<span class="number">1</span>]=<span class="keyword">new</span> QSStudent();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;students.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    students[i].isMartial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以编译通过吗？这可是Student类型的数组哦！ 答案是<strong>可以的</strong>！ 输出为</p>
<blockquote>
<p>不会打武术 作为少林寺章丘分寺的学生，像你这种问题，我就三个字！打!….扰了</p>
</blockquote>
<p>好的让我们停一下，捋一下思路：这两次实验正好得到了相反的结果：第一个实验说声明为父类型，却用子类型构造函数实例化，且实例化出的对象使用的是子类的函数，说明实例化出的对象可能是个子类型。第二个实验却表明只能容纳同一种数据类型的数组却好像容纳了两个数据类型。好的我们再看第三个实验： 直接输出student的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student=<span class="keyword">new</span> QSStudent();</span><br><span class="line">System.out.println(student.getClass())</span><br></pre></td></tr></table></figure>
<p>它输出的是</p>
<blockquote>
<p>class QSStudent</p>
</blockquote>
<p>这直接说明了<strong>用什么构造方法，就会出来什么类型的对象，声明的类型可以是其父类型</strong> 那么如果我们使用多态调用了子类型有但父类型没有的函数/字段会怎样呢？这是不可以的，会报错。 那么，这还能算是一个完整的子类型吗？当然不算，<strong>因为它本质上还是父类型！只不过这种父类型中所有的函数/字段都被引向了被构造函数实例化的子类型！ 其实这才是真正意义上的“多态”，即父类型的不定性。</strong> 所以我们可以总结为： <strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</strong> 例二的数组用法是多态最多的表现形式，当然这只是多态的一点皮毛，如果想深入了解可以自行百度，这里仅介绍。</p>
<h5 id="4-抽象类（集成）"><a href="#4-抽象类（集成）" class="headerlink" title="4.抽象类（集成）"></a>4.抽象类（集成）</h5><p>我们刚刚了解了了继承（相同）、多态（差异），经由那两个的基础再升级我们就得到了抽象（集成）。这是个什么意思？ 还记得继承那一节里的绵羊和山羊吗？当时我们说绵羊和山羊的差异不大，所以完全可以图方便从山羊类那里派生出一个绵羊类来，但是实际上山羊和绵羊并不是继承关系，而是并列关系，它们的父类应该都是羊类，如果我们偷懒从山羊类派生出绵羊类，简单使用起来好像没什么问题，但是如果我们想使用多态的知识，即把它们做成一个数组，绵羊就成了山羊，这样显然是不合逻辑的。但是如果我们写了一个羊类，又会有傻瓜队友把它不小心实例化了，这也会造成很大的麻烦，因为它是一个不具体的对象。为了更加明确其中的结构，我们造出一个专门用来集成的类、全职父类，就是抽象类了。 抽象类使用<strong>abstract</strong>修饰，<strong>正常类里面有的东西它也都可以有，只是不能被直接实例化了</strong>，另外抽象类中也可以存在未实现、即没有方法体的方法，这种方法叫抽象方法，也用<strong>abstract</strong>修饰，若一个类派生自抽象类，那么其中的抽象函数必须被实现，否则不能实例化。当然也可以把抽象函数就这么一级一级继承下去，但是除非在哪一级被实现，否则继承类都不能实例化。 这样从某种意义上讲抽象类就是为多态而服务的。</p>
<h2 id="③总结：一个例子"><a href="#③总结：一个例子" class="headerlink" title="③总结：一个例子"></a>③总结：一个例子</h2><p>下面我们用一个例子来简单回顾一下刚才所学的内容： 现在，我们写一个普通大学生类，类中有字段学院（academy）、班级（theClass）、学号（studentNum）和一个报告自己会不会武术的方法isMartial()，<strong>还有一个内部类“Grading”，用来保存学生的成绩</strong>，包含专业课、英语和政治三科：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通高校学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String academy;</span><br><span class="line">    <span class="keyword">public</span> String theClass;</span><br><span class="line">    <span class="keyword">public</span> Grading grading;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> studentNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isMartial</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不会打武术&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通高校成绩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grading</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> specializedCourse;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> english;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> politics;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是少林寺章丘分寺的学生不一样啊！他不会武术毕不了业，所以在其内部类中应添加一个武术成绩，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//少林寺章丘分寺的学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QSStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> QSGrading grading;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isMartial</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;作为少林寺章丘分寺的学生，像你这种问题，我就三个字！打!....扰了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//少林寺章丘分寺的成绩</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QSGrading</span> <span class="keyword">extends</span> <span class="title">Student</span>.<span class="title">Grading</span>//注意这里的内部类继承写法</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> martial_Art;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在main函数中分别实例化，然后为其英语成绩赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student student1=<span class="keyword">new</span> Student();</span><br><span class="line">    Student student2=<span class="keyword">new</span> QSStudent();</span><br><span class="line">    QSStudent student3=<span class="keyword">new</span> QSStudent();</span><br><span class="line"></span><br><span class="line">    student1.grading.english=<span class="number">90</span>;</span><br><span class="line">    student2.grading.english=<span class="number">90</span>;</span><br><span class="line">    student3.grading.english=<span class="number">90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想一想，这样写能编译通过吗？如果不能，应该怎样改呢？（答案在结尾）</p>
<h2 id="④（后记）目前以来遇到的坑"><a href="#④（后记）目前以来遇到的坑" class="headerlink" title="④（后记）目前以来遇到的坑"></a>④（后记）目前以来遇到的坑</h2><p>想了想从信心满满地写了第一个小程序（小时钟）以来已经过去半年了，中间也陆陆续续开了很多坑，更踩了不少雷，从这里总结一下，为大家做一次侦察兵，希望大家在未来的编程工作中少走弯路。</p>
<h4 id="⑴尽量不要在构造函数、main函数以及各种控件的事件处理方法中写很多逻辑！"><a href="#⑴尽量不要在构造函数、main函数以及各种控件的事件处理方法中写很多逻辑！" class="headerlink" title="⑴尽量不要在构造函数、main函数以及各种控件的事件处理方法中写很多逻辑！"></a>⑴尽量不要在构造函数、main函数以及各种控件的事件处理方法中写很多逻辑！</h4><p>注意我这里说的是逻辑而不是函数，函数可以有，但是选择、循环等逻辑能少则少，那逻辑挪到哪去？当然是另建一个专门处理逻辑的函数，然后在这些函数中引用逻辑函数。 比如要制作GUI，很多人一上来就在main函数里duang duang duang把按钮、布局等等控件全初始化，甚至在main函数里给控件加匿名处理方法，搞得全篇就main函数最长，好家伙近一百行。这是万万使不得的！ 正确的处理方式是，写一个初始化控件的函数，再写一个专门给布局加控件的函数，然后在main函数里引用这两个函数。这个在行业里专门有个称呼，叫<strong>“降低耦合度”</strong>，不单是这里，其实所有函数都要尽量减少其功能，让<strong>一个函数只干一件事，各个功能彼此分离</strong>，然后利用其互相调用完成想要的功能。不要一次制作一整个机械巨人，反而要像钟表匠一样把小齿轮彼此精密地连接在一起。以后应用接口的时候更需要这样。 为什么呢？ 第一是<strong>便于debug</strong>，就像上面讲的面向对象原理一样，功能分离就可以把确定无误的功能和模棱两可的功能分离开，出现问题主要去检查容易出错的函数就可以。 另一个，也就是最重要的一个原因就是<strong>降低代码复现率，提高编程效率</strong>。因为我们定义好函数之后便可无限使用，把某些经常需要用的功能分离出来就可以少写很多代码，这个真的非常重要。 最后就是<strong>便于以后添加新功能</strong>，只要耦合度低了，要添加新功能时只要把前后衔接剪断，再接入新函数的两端即可。但是如果写成了一整个函数。。。后果不堪设想。</p>
<h4 id="⑵语义化！一定要语义化！"><a href="#⑵语义化！一定要语义化！" class="headerlink" title="⑵语义化！一定要语义化！"></a>⑵语义化！一定要语义化！</h4><p>设想有一天你接手别人的项目，突然出现那么一个函数：“<code>aaa()</code>”你说你气不气？这是干嘛的？什么意思？是不是想冲上去拧着那个人的耳朵到屏幕跟前让他解释一下？ 别说别人写的，某天自己的代码中出现一个当初随便起名的函数，你自己也恨不得扇自己两巴掌，但没办法，一小时写代码，两小时读代码，这样效率真的是太低了！ 看看课本上计算器那个例题，命名12个button就是b1一直到b12，可千万别跟他学，0到9尚且好说，如果让你说说乘号是b几，也得一个一个找吗？ 除了这些，某些语言自己就有命名标准，什么camel\\pascal命名标准，至少自己应该了解一下，以后看见名字得知道应该是个什么东西才行。 还有如果可以的话尽量为每个函数加注释，一般是两个内容，即<strong>函数的作用</strong>与<strong>函数的传入值是什么，返回值是什么</strong>。有了注释在将来维护的时候就可以大大减少工作量。</p>
<h4 id="⑶类的功能要唯一，该是什么类就干什么事"><a href="#⑶类的功能要唯一，该是什么类就干什么事" class="headerlink" title="⑶类的功能要唯一，该是什么类就干什么事"></a>⑶类的功能要唯一，该是什么类就干什么事</h4><p>再揪出课本来批：把main函数写在Student类里这种事以后可千万别干，Student是学生类，学生和main函数有什么关系？如果要写main函数<strong>专门建一个类</strong>，Student就是Student，Student不需要、也不能够包含main函数。 暂时想起这些，如果还有想起来的还会更新。</p>
<hr>
<p><strong>③的答案：</strong> 不能编译通过，因为其内部类Grading与QSGrading未实例化，应该分别将其实例化。改正方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student student1=<span class="keyword">new</span> Student();</span><br><span class="line">    Student student2=<span class="keyword">new</span> QSStudent();</span><br><span class="line">    QSStudent student3=<span class="keyword">new</span> QSStudent();</span><br><span class="line"></span><br><span class="line">    student1.grading=student1.<span class="function">new <span class="title">Grading</span><span class="params">()</span></span>;</span><br><span class="line">    student1.grading.english=<span class="number">90</span>;</span><br><span class="line">    student2.grading=student2.<span class="function">new <span class="title">Grading</span><span class="params">()</span></span>;</span><br><span class="line">    student2.grading.english=<span class="number">90</span>;</span><br><span class="line">    student3.grading=student3.<span class="function">new <span class="title">QSGrading</span><span class="params">()</span></span>;</span><br><span class="line">    student3.grading.english=<span class="number">90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再唠叨一下：之所以实例化student2的内部类使用Grading的构造方法而不是QSGrading的构造方法，是因为student2是使用多态产生的QSStudent对象，其中父类的内部类Grading与子类的内部类QSGrading类名不同，所以父类的内部类无法连接到子类的内部类，进而导致其中内部类只有Grading类没有QSGrading类。没有QSGrading类就当然没办法使用其构造方法了。</p>
<hr>
<p>最后祝各位空指针2019年都能找到对象 <a target="_blank" rel="noopener" href="http://upane.cn/wp-content/uploads/2018/03/51.png"><img src="http://upane.cn/wp-content/uploads/2018/03/51.png" alt=""></a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%99%E7%A8%8B/" rel="tag"># 教程</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/12/22/csharp_lambda_and_linq/" rel="prev" title="【C#】初探Lambda表达式与LinQ">
      <i class="fa fa-chevron-left"></i> 【C#】初探Lambda表达式与LinQ
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/02/10/tutorial_wpt2/" rel="next" title="【教程】Walkman Playlist Tools使用教程（第二版）">
      【教程】Walkman Playlist Tools使用教程（第二版） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%91%A0%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">①基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%88%A0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">㈠声明和实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%88%A1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">㈡构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%91%A1%E6%AD%A3%E7%AF%87"><span class="nav-number">2.</span> <span class="nav-text">②正篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%88%A0%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">㈠对象是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%88%A1%E9%82%A3%E4%B9%88%E9%9D%A2%E5%90%91%E4%B8%9C%E8%A5%BF%EF%BC%8C%E5%91%83%E4%B8%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">㈡那么面向东西，呃不面向对象有什么用？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%B4%E6%9D%A1%E7%90%86%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.1.</span> <span class="nav-text">⑴条理化的数据操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%B5%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%8C%E6%98%93%E4%BA%8E%E7%BB%B4%E6%8A%A4"><span class="nav-number">2.2.2.</span> <span class="nav-text">⑵模块化，易于维护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%B6%E7%81%B5%E6%B4%BB%E5%A4%9A%E5%8F%98%EF%BC%8C%E7%9C%81%E6%97%B6%E7%9C%81%E5%8A%9B"><span class="nav-number">2.2.3.</span> <span class="nav-text">⑶灵活多变，省时省力</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%88%A2%E9%82%A3%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">㈢那该怎么用？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%B4%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%EF%BC%8C%E5%85%88%E5%88%AB%E6%80%A5%E7%9D%80%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%83%B3%E6%83%B3%E5%92%B1%E8%A6%81%E5%B9%B2%E5%98%9B%EF%BC%81"><span class="nav-number">2.3.1.</span> <span class="nav-text">⑴重中之重，先别急着写代码，想想咱要干嘛！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%B5%E6%98%8E%E7%A1%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.2.</span> <span class="nav-text">⑵明确结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%B6%E5%B0%81%E8%A3%85"><span class="nav-number">2.3.3.</span> <span class="nav-text">⑶封装</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%AC%A6%EF%BC%8C%E9%A1%BE%E5%90%8D%E6%80%9D%E4%B9%89%EF%BC%8C%E5%B0%B1%E6%98%AF%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E8%AE%BF%E9%97%AE%E6%80%A7%E7%9A%84-%E4%B8%8B%E9%9D%A2%E6%88%91%E4%BB%AC%E5%B0%B1%E6%9D%A5%E6%AF%94%E8%BE%83%E4%B8%80%E4%B8%8BJava%E7%9A%84%E5%9B%9B%E4%B8%AA%E8%AE%BF%E9%97%AE%E7%AC%A6%EF%BC%88%E6%B2%A1%E6%9C%89%E4%B9%9F%E7%AE%97%E4%B8%80%E4%B8%AA%EF%BC%89%E6%A0%87%E8%AF%86%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%EF%BC%9A"><span class="nav-number">2.3.3.0.1.</span> <span class="nav-text">访问符，顾名思义，就是用来修饰访问性的,下面我们就来比较一下Java的四个访问符（没有也算一个）标识的可访问性：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E5%86%8D%E6%9D%A5%E8%AE%B2%E8%AE%B2%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E7%9B%AE%E7%9A%84%E5%B0%B1%E6%98%AF%E5%86%8D%E5%AF%B9%E8%A2%AB%E4%BF%AE%E9%A5%B0%E7%9A%84%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E8%A7%A3%E9%87%8A%EF%BC%8C%E8%B5%8B%E4%BA%88%E5%85%B6%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="nav-number">2.3.3.0.2.</span> <span class="nav-text">然后我们再来讲讲修饰符，修饰符的目的就是再对被修饰的语句进行进一步的解释，赋予其更多功能：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%B7%E6%8E%8C%E6%8F%A1%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="nav-number">2.3.4.</span> <span class="nav-text">⑷掌握类之间的关系：继承与多态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9A%E9%9D%99%E6%80%81"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">1.特殊情况：静态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BB%A7%E6%89%BF%EF%BC%88%E7%9B%B8%E5%90%8C%EF%BC%89"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">2.继承（相同）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%A4%9A%E6%80%81%EF%BC%88%E5%B7%AE%E5%BC%82%EF%BC%89"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">3.多态（差异）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E9%9B%86%E6%88%90%EF%BC%89"><span class="nav-number">2.3.4.4.</span> <span class="nav-text">4.抽象类（集成）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%91%A2%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="nav-number">3.</span> <span class="nav-text">③总结：一个例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%91%A3%EF%BC%88%E5%90%8E%E8%AE%B0%EF%BC%89%E7%9B%AE%E5%89%8D%E4%BB%A5%E6%9D%A5%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91"><span class="nav-number">4.</span> <span class="nav-text">④（后记）目前以来遇到的坑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%B4%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81main%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E4%B8%AD%E5%86%99%E5%BE%88%E5%A4%9A%E9%80%BB%E8%BE%91%EF%BC%81"><span class="nav-number">4.0.1.</span> <span class="nav-text">⑴尽量不要在构造函数、main函数以及各种控件的事件处理方法中写很多逻辑！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%B5%E8%AF%AD%E4%B9%89%E5%8C%96%EF%BC%81%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AF%AD%E4%B9%89%E5%8C%96%EF%BC%81"><span class="nav-number">4.0.2.</span> <span class="nav-text">⑵语义化！一定要语义化！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%B6%E7%B1%BB%E7%9A%84%E5%8A%9F%E8%83%BD%E8%A6%81%E5%94%AF%E4%B8%80%EF%BC%8C%E8%AF%A5%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%B0%B1%E5%B9%B2%E4%BB%80%E4%B9%88%E4%BA%8B"><span class="nav-number">4.0.3.</span> <span class="nav-text">⑶类的功能要唯一，该是什么类就干什么事</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tim"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Tim</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yimig" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yimig" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhangyiming@programmer.net" title="E-Mail → mailto:zhangyiming@programmer.net" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode.com/yimig/" title="LeeCode → https:&#x2F;&#x2F;leetcode.com&#x2F;yimig&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-code"></i>LeeCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/tim-2-96" title="zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tim-2-96" rel="noopener" target="_blank"><i class="fa fa-fw fa-question-circle"></i>zhihu</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://upane.cn/" title="https:&#x2F;&#x2F;upane.cn" rel="noopener" target="_blank">博客旧址</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tim</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">184k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:47</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js"></script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'a876807f33858291f9d9',
      clientSecret: '7a5c6a83611c309965d7339d7ca5f16e34a21e9f',
      repo        : 'yimig.github.io',
      owner       : 'yimig',
      admin       : ['yimig'],
      id          : '511c2afea2bd88617f06ee1489eec7f8',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
