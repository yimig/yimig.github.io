<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AnyPin开发计划</title>
    <url>/2018/08/19/anypin%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>目标中的第一个完整的应用程序。 将分别开发各个组件，全部组件开发完成后合并在一个应用中发布。<br><a id="more"></a><br>预计实现功能/分类组件： （单击开发进度即可进入相关页面） 时钟前置（<a href="http://upane.cn/archives/414">已实现，测试中</a>）2018.8.18 任意图片前置（<a href="http://upane.cn/archives/462">已实现，测试中</a>）2018.8.21 便利贴/可编辑字符前置（<a href="http://upane.cn/archives/491">已实现，测试中</a>）2018.8.27 传感器信息前置 任意窗口前置</p>
]]></content>
      <categories>
        <category>Project.IDEA</category>
      </categories>
      <tags>
        <tag>AnyPin</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】emacsIDEAs安装教程</title>
    <url>/2018/10/01/emacsideas%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<a id="more"></a>
<p>首先调出搜索器（Ctrl+Shift+A），输入plugin <a href="http://upane.cn/emacsideas%e5%ae%89%e8%a3%85%e6%95%99%e7%a8%8b/2018-09-28_22-02-35"><img src="http://47.94.231.166/wp-content/uploads/2018/09/2018-09-28_22-02-35-280x300.png" alt=""></a> 输入按下Enter进入插件管理器，点击下方按钮”Browse repositories…”进入插件下载页面。 <a href="http://upane.cn/emacsideas%e5%ae%89%e8%a3%85%e6%95%99%e7%a8%8b/idea64_2018-09-28_22-03-11"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_22-03-11-300x254.png" alt=""></a> 然后在上方搜索框输入插件名：emacsIDEAs，如下图，选择下载即可。下载完成后重启启用插件。 <a href="http://upane.cn/emacsideas%e5%ae%89%e8%a3%85%e6%95%99%e7%a8%8b/idea64_2018-09-28_22-03-45"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_22-03-45-300x249.png" alt=""></a> 然后再次进入搜索器（Ctrl+Shift+A），输入”Manage Keymap”,按下Enter，进入快捷键管理界面 <a href="http://upane.cn/emacsideas%e5%ae%89%e8%a3%85%e6%95%99%e7%a8%8b/idea64_2018-09-28_22-04-45"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_22-04-45-300x73.png" alt=""></a> 在界面右侧输入框内输入插件名：emacsIDEAs <a href="http://upane.cn/emacsideas%e5%ae%89%e8%a3%85%e6%95%99%e7%a8%8b/idea64_2018-09-28_22-05-43"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_22-05-43-300x209.png" alt=""></a> 在根目录中找到“AceJumpWord”，对其右键，选择“Add Keyboard Shortcut”对其新建一个快捷键即可使用该插件。 <a href="http://upane.cn/emacsideas%e5%ae%89%e8%a3%85%e6%95%99%e7%a8%8b/idea64_2018-09-28_22-06-05"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_22-06-05-300x149.png" alt=""></a></p>
]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】js学习小笔记 3#</title>
    <url>/2019/04/27/js%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<p>你捡起了道具：<strong>遗失的纸片3#</strong> 一张普通的纸片，隐隐约约能够看到目录：“<strong>this、构造方法、原型、toString()、垃圾回收、数组、函数对象的方法、Date对象、Math对象、包装类、String()的方法（字符串操作）、正则表达式</strong>”。边角还有被撕扯的痕迹，它们应该属于一个笔记本，但不知为什么被主人撕下来丢掉了。 提示：集齐所有纸片应该可以得到一本技能书。 👇点击下方按钮调查<br><a id="more"></a></p>
<h2 id="13-this"><a href="#13-this" class="headerlink" title="13.this"></a>13.this</h2><blockquote>
<p>解析器在调用函数时每次都会向函数内部传递一个隐含的参数，就是_this_。<code>this</code>指向的是一个对象，是函数执行的<strong>上下文对象</strong>，根据<strong>调用方式不同</strong>，<code>this</code>的值不同。 1. 以函数形式调用时，<code>this</code>指代<strong>window</strong> 1. 以方法形式调用时，<code>this</code>指代<strong>包含该方法的对象</strong></p>
</blockquote>
<p>作用： 做到“函数的多态”</p>
<h2 id="14-构造方法"><a href="#14-构造方法" class="headerlink" title="14.构造方法"></a>14.构造方法</h2><h3 id="①使用工厂方法创建对象"><a href="#①使用工厂方法创建对象" class="headerlink" title="①使用工厂方法创建对象"></a>①使用工厂方法创建对象</h3><p>这样创建的都是<strong>object</strong>类型对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数体</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,gender</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name=name;</span><br><span class="line">    obj.age=age;</span><br><span class="line">    obj.gender=gender;</span><br><span class="line">    obj.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">var</span> obj=createPerson(<span class="string">&quot;张三&quot;</span>,<span class="number">28</span>,<span class="string">&quot;男&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="②构造函数"><a href="#②构造函数" class="headerlink" title="②构造函数"></a>②构造函数</h3><ol>
<li>创建时，构造函数就是一个普通的函数，不同的是构造函数<strong>习惯上首字母大写</strong></li>
<li>调用时，普通函数直接调用，构造函数<strong>使用<code>new</code>调用</strong></li>
</ol>
<h4 id="构造函数的执行流程："><a href="#构造函数的执行流程：" class="headerlink" title="构造函数的执行流程："></a>构造函数的执行流程：</h4><ol>
<li>立刻创建一个新的对象</li>
<li>将新建的对象设置为函数中<code>this</code>，在构造函数中可使用<code>this</code>来引用新建的对象</li>
<li>逐行执行函数中的代码</li>
<li>将新建的对象作为返回值返回</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数体</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,gender</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">    <span class="built_in">this</span>.gender=gender;</span><br><span class="line">    <span class="comment">/*this.sayName=function()&#123;</span></span><br><span class="line"><span class="comment">        alert(this.name);</span></span><br><span class="line"><span class="comment">    &#125;;*/</span></span><br><span class="line">    <span class="built_in">this</span>.sayName=sayNameFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayNameFunc</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">28</span>,<span class="string">&quot;男&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>由于构造方法会多次创建对象，所以如果在构造方法中写入方法体势必占用大量内存空间，建议将function()提取到全局，创建对象时引用之（如上例）。</strong> <strong>但这样又会污染全局作用域的类命名空间，也很不安全，最佳解决方法是将方法存储在原型中，见下一章</strong></p>
<h3 id="④instanceof"><a href="#④instanceof" class="headerlink" title="④instanceof()"></a>④instanceof()</h3><blockquote>
<p>检查一个对象是否是一个类实例</p>
</blockquote>
<p>语法：<strong>对象 instanceof 构造函数</strong> 是，返回true，否，返回false <strong>所有对象都继承自object，所以任何对象与object做instanceof运算时都会返回true</strong></p>
<h2 id="15-原型"><a href="#15-原型" class="headerlink" title="15.原型"></a>15.原型</h2><h3 id="①prototype和proto属性"><a href="#①prototype和proto属性" class="headerlink" title="①prototype和proto属性"></a>①prototype和<strong>proto</strong>属性</h3><ol>
<li>我们所创建的每一个函数，解析器都会想函数中添加一个属性<code>prototype</code>。</li>
<li>这个属性对应着一个对象，该对象及<strong>原型</strong>。</li>
<li>普通函数也有<code>prototype</code>，但无任何作用。</li>
<li>当函数以构造函数形式调用时，它创建的对象中都会有一个隐含的属性<strong>指向该构造函数的原型对象</strong>，我们可以通过<code>__proto__</code>来访问这个属性。</li>
<li>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可将对象中<strong>共有</strong>的内容同一设置到原型对象中。</li>
<li>当我们访问对象的一个属性或方法时，它会先在对象自身中查找，如果有则直接使用，如果没有则回去原型对象中查找，找到则直接使用。</li>
<li>以后我们创建构造函数时，可将这些对象共有的属性和方法<strong>统一添加到构造函数的原型对象</strong>中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都使用这些属性和方法了。</li>
<li>原型对象中也有原型，<strong>直到object的原型才没有原型</strong></li>
</ol>
<h3 id="②原型对其他方法的影响"><a href="#②原型对其他方法的影响" class="headerlink" title="②原型对其他方法的影响"></a>②原型对其他方法的影响</h3><ol>
<li>使用<code>in</code>检查对象中是否含有某属性时，<strong>若对象中没有但原型中有，则同样返回true</strong></li>
<li>可以用对象的<code>hasOwnProperty()</code>来检查对象自身是否含有某属性</li>
</ol>
<h2 id="16-toString"><a href="#16-toString" class="headerlink" title="16. toString()"></a>16. toString()</h2><blockquote>
<p><strong>在object的原型中</strong>，打印对象默认调用toString()方法，可通过在对象中添加toString()方法来修改toString()函数。</p>
</blockquote>
<h2 id="17-垃圾回收"><a href="#17-垃圾回收" class="headerlink" title="17.垃圾回收"></a>17.垃圾回收</h2><ol>
<li>当一个对象没有任何变量或属性时对它进行引用，此时我们将永远无法操作该对象，此时该对象即为垃圾，占用内存并导致程序变慢。</li>
<li>JS拥有自动垃圾回收机制</li>
<li>将不再使用的对象<strong>置null</strong>即可触发垃圾回收</li>
</ol>
<h2 id="18-数组"><a href="#18-数组" class="headerlink" title="18.数组"></a>18.数组</h2><h3 id="①创建"><a href="#①创建" class="headerlink" title="①创建"></a>①创建</h3><h4 id="⑴方法一-常规创建"><a href="#⑴方法一-常规创建" class="headerlink" title="⑴方法一:常规创建"></a>⑴方法一:常规创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="number">33</span>;</span><br></pre></td></tr></table></figure>
<h4 id="⑷方法四：使用数组的构造函数创建"><a href="#⑷方法四：使用数组的构造函数创建" class="headerlink" title="⑷方法四：使用数组的构造函数创建"></a>⑷方法四：使用数组的构造函数创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="⑶方法三：使用数组的字面量创建"><a href="#⑶方法三：使用数组的字面量创建" class="headerlink" title="⑶方法三：使用数组的字面量创建"></a>⑶方法三：使用数组的字面量创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>];<span class="comment">//数字数组</span></span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>,<span class="literal">true</span>,<span class="literal">undefined</span>];<span class="comment">//混合数组</span></span><br><span class="line"><span class="keyword">var</span> arr3=[&#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;李四&quot;</span>,<span class="attr">age</span>:<span class="number">25</span>&#125;];<span class="comment">//对象数组</span></span><br><span class="line"><span class="keyword">var</span> arr4=[<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>);&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">2</span>);&#125;];<span class="comment">//函数数组</span></span><br><span class="line"><span class="keyword">var</span> arr5=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]];<span class="comment">//多维数组</span></span><br></pre></td></tr></table></figure>
<h3 id="②性质"><a href="#②性质" class="headerlink" title="②性质"></a>②性质</h3><ol>
<li>若读取不存在的元素，<strong>不会报错，返回undefined</strong></li>
<li>获取数组长度：<code>arr.Length</code>，该属性也可设置数组长度</li>
<li>对于非连续的元素，使用length可获取到数组的最大索引+1</li>
<li>设置<code>arr[arr.length]</code>永远向数组最后添加元素</li>
</ol>
<h3 id="③常用方法"><a href="#③常用方法" class="headerlink" title="③常用方法"></a>③常用方法</h3><ol>
<li><code>push()</code><strong>在末尾添加元素</strong>，也可添加多个元素，将返回添加后的新长度</li>
<li><code>pop()</code><strong>删除数组最后一个元素</strong>，并返回被删除的元素</li>
<li><code>unshift()</code><strong>在开头添加一个或多个元素</strong>。将返回添加后的新长度</li>
<li><code>shift()</code><strong>删除并返回数组的第一个元素</strong></li>
</ol>
<h3 id="④数组的遍历"><a href="#④数组的遍历" class="headerlink" title="④数组的遍历"></a>④数组的遍历</h3><p>——<strong>forEach方法（仅支持IE8以上的浏览器，还是建议使用for）</strong> foreach方法需以函数作为参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;)<span class="comment">//arr有几个元素就输出几个hello</span></span><br></pre></td></tr></table></figure>
<ol>
<li>像这种函数，由我们创建但不有我们调用的，我们称为<strong>回调函数</strong>（浏览器负责调用）</li>
<li>数组有几个元素就会调用几次，每次执行时，浏览器会将遍历到的元素以实参的形式传毒进来，我们可以定义形参来读取这些参数。</li>
<li>浏览器会在回调函数中传递三个参数：</li>
</ol>
<p>参数</p>
<p>作用</p>
<p>第一个参数</p>
<p><strong>当前正在遍历的元素</strong></p>
<p>第二个参数</p>
<p><strong>当前正在遍历的元素索引</strong></p>
<p>第三个参数</p>
<p><strong>正在遍历的数组</strong></p>
<h3 id="⑤slice-splice"><a href="#⑤slice-splice" class="headerlink" title="⑤slice()/splice()"></a>⑤slice()/splice()</h3><h4 id="⑴slice-可以用来从数组中提取指定元素"><a href="#⑴slice-可以用来从数组中提取指定元素" class="headerlink" title="⑴slice()可以用来从数组中提取指定元素"></a>⑴slice()可以用来从数组中提取指定元素</h4><p>参数： 1. 第一个参数——截取开始位置的索引 1. 第二个参数——截取结束位置的索引（左闭右开） 第二个参数可省略，索引可传递一个负值：倒数值 返回： 截取到的数组</p>
<h4 id="⑵splice-可以用于删除数组的指定元素"><a href="#⑵splice-可以用于删除数组的指定元素" class="headerlink" title="⑵splice()可以用于删除数组的指定元素"></a>⑵splice()可以用于删除数组的指定元素</h4><p><strong>使用splice()会影响到原数组，并将被删除的元素返回</strong> 参数： 1. 第一个参数——开始位置的碎银 1. 第二个参数——<strong>删除元素的数量</strong> 1. 第三个及以后的参数——可传递新元素，这些元素将自动添加到删除索引之后</p>
<h3 id="⑥剩余方法"><a href="#⑥剩余方法" class="headerlink" title="⑥剩余方法"></a>⑥剩余方法</h3><h4 id="⑴concat-可连接两个或更多数组，并将新数组返回"><a href="#⑴concat-可连接两个或更多数组，并将新数组返回" class="headerlink" title="⑴concat() 可连接两个或更多数组，并将新数组返回"></a>⑴concat() 可连接两个或更多数组，并将新数组返回</h4><p>不仅可传数组也可传元素</p>
<h4 id="⑵join-可将数组转为字符串，并返回该串"><a href="#⑵join-可将数组转为字符串，并返回该串" class="headerlink" title="⑵join() 可将数组转为字符串，并返回该串"></a>⑵join() 可将数组转为字符串，并返回该串</h4><p>在join()中，可指定一个字符连接各元素。不指定默认为“,”</p>
<h4 id="⑶reverse-颠倒数组中的元素"><a href="#⑶reverse-颠倒数组中的元素" class="headerlink" title="⑶reverse() 颠倒数组中的元素"></a>⑶reverse() 颠倒数组中的元素</h4><p>会直接修改原数组</p>
<h4 id="⑷sort-可用来对数组中的元素排序"><a href="#⑷sort-可用来对数组中的元素排序" class="headerlink" title="⑷sort() 可用来对数组中的元素排序"></a>⑷sort() 可用来对数组中的元素排序</h4><ol>
<li>也会影响原数组</li>
<li>默认按Unicode编码排序</li>
<li>自定义排序函数→在Sort()中传入回调函数，回调函数需定义形参</li>
<li>浏览器会分别使用数组的元素作为实参调用回调函数。使用哪个元素不确定，但肯定的是在数组中第一个元素一定在第二个元素的前面。浏览器会根据回调函数的返回值来决定元素的顺序</li>
<li>返回值：</li>
</ol>
<p>返回值</p>
<p>操作</p>
<p>>0</p>
<p>交换两个元素的位置</p>
<p>\\&lt;0</p>
<p>不交换</p>
<p>\=0</p>
<p>认为二值相等，也不交换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依据数字大小进行排序（升序）</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b-a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="19-函数对象的方法"><a href="#19-函数对象的方法" class="headerlink" title="19.函数对象的方法"></a>19.函数对象的方法</h2><h3 id="①call-apply"><a href="#①call-apply" class="headerlink" title="①call()/apply()"></a>①call()/apply()</h3><ol>
<li>都能执行函数</li>
<li>与普通调用不同的是，调用<code>call()</code>和<code>apply()</code>可将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的<strong>this</strong></li>
<li><code>call()</code>方法可将要传入的实参在对象后依次传递,如 <code>fun.call(obj,1,2)</code>,这里的1和2是传递到函数fun的实参，相当于<code>fun(1,2)</code></li>
<li><code>apply()</code>方法需要将实参封装到一个数组中统一传递，如<code>fun.apply(obj,[1,2])</code></li>
</ol>
<h2 id="20-arugments对象"><a href="#20-arugments对象" class="headerlink" title="20.arugments对象"></a>20.arugments对象</h2><p>在调用函数时，浏览器每次都会传递两个隐含参数： 1. 函数上下文对象this 1. <strong>封装实参的对象arguments</strong></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li>arguments是一个<strong>类数组对象</strong>。它可以通过索引操作数据，也可获取长度</li>
<li>在调用函数时，我们所传递的实参都会在arguments中保存</li>
<li><code>arguments.Length</code>可用来获取实参的长度</li>
<li><strong>即使不定义形参也可通过arguments得到实参</strong></li>
<li>arguments中有一个属性<strong>callee</strong>，此属性对应一个函数对象，即当前函数对象</li>
</ol>
<h2 id="21-Date对象"><a href="#21-Date对象" class="headerlink" title="21.Date对象"></a>21.Date对象</h2><h3 id="①如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间"><a href="#①如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间" class="headerlink" title="①如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间"></a>①如果直接使用构造函数创建一个Date对象，则会封装为<strong>当前代码执行的时间</strong></h3><h3 id="②创建指定时间对象："><a href="#②创建指定时间对象：" class="headerlink" title="②创建指定时间对象："></a>②创建指定时间对象：</h3><p>写在构造函数中，<strong>格式为：“mm/dd/yyyy hh/mm/ss”和“mm/dd/yyyy”</strong></p>
<h3 id="③得到日期"><a href="#③得到日期" class="headerlink" title="③得到日期"></a>③得到日期</h3><p>方法： 1. getDate():获得“日” 1. getDay():获得“周几”<strong>（返回0-6,0为周日）</strong> 1. getMonth():月 （返回0-11，0→1月，11→12月） 1. <strong>getFullYear()</strong>:年 1. getTime()：获得当前对象的<strong>时间戳</strong>（1970/1/1 00:00:00到目前时间的<strong>毫秒值</strong>）计算机底层使用的都是时间戳（获得当的时间戳Date.now())</p>
<h2 id="22-Math对象"><a href="#22-Math对象" class="headerlink" title="22.Math对象"></a>22.Math对象</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol>
<li>Math不是构造函数，不能创建对象，是一个工具类</li>
<li>有常用属性（Π、e等常数）</li>
</ol>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><p>方法</p>
<p>含义</p>
<p>abs()</p>
<p>绝对值</p>
<p>ceil()</p>
<p>上舍入（向上取整）</p>
<p>floor()</p>
<p>下舍入（向下取整）</p>
<p>round()</p>
<p>四舍五入取整</p>
<p>random()</p>
<p>生成一个0-1之间的随机数</p>
<p>Math.round(Math.random()*x)</p>
<p>生成一个0-x之间的随机数</p>
<p>Math.round(Math.random()*(y-x)+x)</p>
<p>生成一个x-y之间的随机数</p>
<p>max()</p>
<p>获取多个数中的最大值</p>
<p>min()</p>
<p>获取多个数中的最小值</p>
<p>pow(x,y)</p>
<p>返回x的y次幂</p>
<p>sqrt(x)</p>
<p>对x开方</p>
<h2 id="23-包装类"><a href="#23-包装类" class="headerlink" title="23.包装类"></a>23.包装类</h2><p>在JS中提供了三个包装类，通过这三个包装类可<strong>将基本数据类型数据转换为对象</strong> 即:<code>String()</code>/<code>Number()</code>/<code>Boolean()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><strong>对象的优点：可存储属性、方法</strong> <strong>缺点：无法直接进行比较、运算</strong> 方法和属性只能添加给对象，不能添加给基本数据类型，<strong>所以当我们对比一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后调用对象的属性和方法，调用完后再将其转换为基本数据类型</strong>。</p>
<h2 id="24-String-的方法（字符串操作）"><a href="#24-String-的方法（字符串操作）" class="headerlink" title="24.String()的方法（字符串操作）"></a>24.String()的方法（字符串操作）</h2><ol>
<li>在底层字符串以数组保存，所以很多方法共用</li>
<li>以下方法均不影响原字符串</li>
</ol>
<p>方法/属性</p>
<p>功能</p>
<p>附加</p>
<p>length</p>
<p>字符串的长度</p>
<p>String.fromCharCode(…)</p>
<p>根据Unicode获取字符</p>
<p>concat()</p>
<p>连接多个字符串</p>
<p>作用与“+”相似</p>
<p>indexof()</p>
<p>检索一个字符串中是否含有指定内容</p>
<p>如果含有该内容，自返回第一次出现的索引，如果没有则返回-1。还可指定第二个参数，指定查找开始的索引位置。</p>
<p>lastindexof()</p>
<p>用法与indexof()相同，但从后往前找</p>
<p>slice()</p>
<p>截取指定内容</p>
<p>第一个参数为开始位置索引，第二个参数为结束为止索引（左闭右开）</p>
<p>substring()</p>
<p>与slice()类似，不同的是substring()不接受负值，负值默认为零，且能自动调整参数的位置</p>
<p>str.substring(2,1)→str.substring(1,2)</p>
<p>split()</p>
<p>可将一个字符串拆成数组</p>
<p>需要一个字符串作为参数，将据此拆分字符串</p>
<p>toLowerCase()</p>
<p>将字符串转为大写并返回</p>
<p>toUpperCase()</p>
<p>将字符串转为小写并返回</p>
<h2 id="25-正则表达式"><a href="#25-正则表达式" class="headerlink" title="25.正则表达式"></a>25.正则表达式</h2><blockquote>
<p>正则表达式语法参见→<a href="http://upane.cn/archives/1251">【Regex】正则表达式语法</a></p>
</blockquote>
<h3 id="①创建正则表达式对象"><a href="#①创建正则表达式对象" class="headerlink" title="①创建正则表达式对象"></a>①创建正则表达式对象</h3><h4 id="⑴常规创建"><a href="#⑴常规创建" class="headerlink" title="⑴常规创建"></a>⑴常规创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(x,y)<span class="comment">//x：正则表达式，y：匹配模式(可忽略，也可设置多个)</span></span><br></pre></td></tr></table></figure>
<h4 id="⑵使用字面量创建"><a href="#⑵使用字面量创建" class="headerlink" title="⑵使用字面量创建"></a>⑵使用字面量创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/x/y</span></span><br><span class="line"><span class="comment">//x：正则表达式，y：匹配模式(可忽略，也可设置多个)</span></span><br></pre></td></tr></table></figure>
<h4 id="⑶匹配模式"><a href="#⑶匹配模式" class="headerlink" title="⑶匹配模式"></a>⑶匹配模式</h4><ol>
<li>i→忽略大小写</li>
<li>g→全局匹配</li>
</ol>
<h3 id="②检查"><a href="#②检查" class="headerlink" title="②检查"></a>②检查</h3><p><strong>——test()方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result=reg.test(str);</span><br><span class="line"><span class="comment">//str为要检测的字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="③与正则表达式相关的字符串语法"><a href="#③与正则表达式相关的字符串语法" class="headerlink" title="③与正则表达式相关的字符串语法"></a>③与正则表达式相关的字符串语法</h3><ol>
<li><strong>split()</strong> 将字符串拆成数组<strong>（可传递正则表达式）</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.split(reg);</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>search()</strong> 搜索 若搜到，则返回第一次出现的索引，否则返回-1</li>
<li><strong>match()</strong> 可根据正则表达式将字符串中符合条件的内容提取出来</li>
<li><strong>replace()</strong> 替换 参数一：被替换的内容 参数二：替换内容</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
        <category>JavaScript</category>
        <category>Web</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>#WordPress#  目前遇到过的小问题及解决方法</title>
    <url>/2018/03/11/wordpress-%E7%9B%AE%E5%89%8D%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>算是个小总结吧<br><a id="more"></a></p>
<h3 id="1-除了主网页其他页面均显示丢失"><a href="#1-除了主网页其他页面均显示丢失" class="headerlink" title="1.除了主网页其他页面均显示丢失"></a>1.除了主网页其他页面均显示丢失</h3><p>解决方案：仪表盘&gt;设置&gt;固定链接 如下图，选择一个不为中文的链接类型即可 <a href="http://47.94.231.166/archives/84/chrome_2018-03-11_23-42-26"><img src="http://47.94.231.166/wp-content/uploads/2018/03/chrome_2018-03-11_23-42-26-300x172.png" alt=""></a></p>
<h3 id="2-无法发送认证邮件"><a href="#2-无法发送认证邮件" class="headerlink" title="2.无法发送认证邮件"></a>2.无法发送认证邮件</h3><p>解决方案：这里是由于SMTP服务器设置不正确的原因，可以通过下载插件解决，我选择的是 Easy WP SMTP ，另外在测试aol,yahoo.co.jp,qq几个邮箱中发现这几个虽然都支持SMTP发送但是实际用起来只有QQ可用。详细配置见下图↓。 <a href="http://47.94.231.166/archives/84/2018-03-11_23-49-11"><img src="http://47.94.231.166/wp-content/uploads/2018/03/2018-03-11_23-49-11-231x300.png" alt=""></a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title>【Coding！】Reverse Integer</title>
    <url>/2019/06/26/%E3%80%90coding%EF%BC%81%E3%80%91reverse-integer/</url>
    <content><![CDATA[<h3 id="原题："><a href="#原题：" class="headerlink" title="原题："></a><a href="https://leetcode.com/problems/reverse-integer/solution/">原题：</a></h3><p>Given a 32-bit signed integer, reverse digits of an integer.<br><a id="more"></a><br>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>
<p>Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<h3 id="需求分析："><a href="#需求分析：" class="headerlink" title="需求分析："></a>需求分析：</h3><ol>
<li>输入一个数，输出它的位数倒置数（123→321）</li>
<li>倒置溢出时，输出为0</li>
<li>负数倒置仍为负数</li>
</ol>
<h3 id="我的答案："><a href="#我的答案：" class="headerlink" title="我的答案："></a>我的答案：</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Reverse</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="built_in">int</span>&gt; queue=<span class="keyword">new</span> Queue&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="built_in">bool</span> isNegative = checkNegative(<span class="keyword">ref</span> x);</span><br><span class="line">        <span class="built_in">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            queue.Enqueue(pushIntger(<span class="keyword">ref</span> x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.Count()==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(!popIntger(<span class="keyword">ref</span> result,queue.Dequeue()))&#123;</span><br><span class="line">                result=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative?-result:result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">checkNegative</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">bool</span> isNegative = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isNegative = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (num == Int32.MinValue) num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> num = Math.Abs(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isNegative;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">pushIntger</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp=num%<span class="number">10</span>;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">popIntger</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> num,<span class="built_in">int</span> pop</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;(Int32.MaxValue/<span class="number">10</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==(Int32.MaxValue/<span class="number">10</span>)&amp;&amp;pop&gt;<span class="number">7</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            num=num*<span class="number">10</span>+pop;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//44ms,15M</span></span><br></pre></td></tr></table></figure>
<h3 id="原题答案："><a href="#原题答案：" class="headerlink" title="原题答案："></a>原题答案：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; Integer.MAX_VALUE/<span class="number">10</span>  (rev == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE/<span class="number">10</span>  (rev == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; -<span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode！</category>
      </categories>
      <tags>
        <tag>吃饭，睡觉，刷Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>【CLion】向CLion中导入VS项目无法运行的解决方案</title>
    <url>/2020/07/08/%E3%80%90clion%E3%80%91%E5%90%91clion%E4%B8%AD%E5%AF%BC%E5%85%A5vs%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>这几天刚刚上手CLion，准备从github导入自己的C++库，虽然导入成功，但是运行按钮是灰色的，而且显示需要手动指定CMakelists.txt，到网上搜索无果，最后自己摸索出来了，希望能帮到有同样问题的朋友。<br><a id="more"></a><br>刚刚导入的时候是这样的： <img src="https://www.z4a.net/images/2020/07/08/_2020-07-08_08-51-03.png" alt=""> <strong>先说结论： 这是由于VS默认是不在项目中创建CMake结构的，但是CLion必须要这个才能编译运行项目。</strong> 解决方法也很简单，为项目创建CMake结构即可：</p>
<h2 id="创建CMake结构"><a href="#创建CMake结构" class="headerlink" title="创建CMake结构"></a>创建CMake结构</h2><p>①在导航栏的<strong>“File”</strong>中有个<strong>“New CMake project from Sources…”</strong>，点击即可开始创建CMake结构。 <img src="https://www.z4a.net/images/2020/07/08/clion64_2020-07-08_08-51-39.png" alt=""> ②在弹出的窗口中选择当前项目，即为当前项目添加结构 <img src="https://www.z4a.net/images/2020/07/08/clion64_2020-07-08_08-52-13.png" alt=""> ③点击OK后，在之后的窗口选择要导入CMake的文件 <img src="https://www.z4a.net/images/2020/07/08/clion64_2020-07-08_08-52-58.png" alt=""> ④再次点击OK后，CMake结构已经添加，需要重载项目，等待CMake加载完成即可 <img src="https://www.z4a.net/images/2020/07/08/2020-07-08_08-53-26.png" alt=""> ⑤加载完成后，运行面板就可以使用了，此时直接编译运行项目即可。 <img src="https://www.z4a.net/images/2020/07/08/_2020-07-08_08-54-06.png" alt=""></p>
]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Clion</tag>
        <tag>VS</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】List、Dictionary以及两种筛选算法</title>
    <url>/2018/09/22/%E3%80%90c%E3%80%91list%E3%80%81dictionary%E4%BB%A5%E5%8F%8A%E4%B8%A4%E7%A7%8D%E7%AD%9B%E9%80%89%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<a id="more"></a>
<p>List与Dictionary都在<strong>System.Collections.Generic</strong>中</p>
<h1 id="①List"><a href="#①List" class="headerlink" title="①List"></a>①List</h1><p>List是C#中的一种链表，<strong>它与数组类型相似性极高</strong>，比如使用时都需要先实例化、调用时都是根据索引、能够包含所有类等等。与数组类型不同的是，如果对<a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx">IList</a> 类的类型 T 使用<strong>引用类型</strong>，则两个类的行为是<strong>完全相同</strong>的。但是，如果对类型 T 使用值类型，则需要考虑实现和装箱问题。而添加到数组中的<strong>任何引用或值类型都将隐式地向上强制转换为 Object</strong>。如果项是值类型，则必须在将其添加到列表中时进行装箱操作，在检索时进行取消装箱操作。强制转换以及装箱和取消装箱操作都会降低性能；在必须对大型集合进行循环访问的情况下，装箱和取消装箱的影响非常明显。<strong>而且List在后期也可以增减元素</strong>，而不是像数组那样一旦实例化便不可增减。于是，为了性能与后期编程考虑，<strong>存储引用类型应偏向于使用List而不是数组。</strong></p>
<h2 id="创建一个List："><a href="#创建一个List：" class="headerlink" title="创建一个List："></a>创建一个List：</h2><h6 id="1-List-lt-数据类型-gt-链表名-new-List-lt-数据类型-gt-；"><a href="#1-List-lt-数据类型-gt-链表名-new-List-lt-数据类型-gt-；" class="headerlink" title="1.List&lt;数据类型&gt; 链表名=new List&lt;数据类型&gt;；"></a>1.List&lt;数据类型&gt; 链表名=new List&lt;数据类型&gt;；</h6><p>也可以在实例化的时候赋初始值，如</p>
<h6 id="2-List-lt-数据类型-gt-链表名-new-List-lt-数据类型-gt-数据1，数据2，……-；"><a href="#2-List-lt-数据类型-gt-链表名-new-List-lt-数据类型-gt-数据1，数据2，……-；" class="headerlink" title="2.List&lt;数据类型&gt; 链表名=new List&lt;数据类型&gt;{数据1，数据2，……}；"></a>2.List&lt;数据类型&gt; 链表名=new List&lt;数据类型&gt;{数据1，数据2，……}；</h6><h6 id="或"><a href="#或" class="headerlink" title="或"></a>或</h6><h6 id="3-List-lt-数据类型-gt-链表名-new-List-lt-数据类型-gt-声明数据量类型的数组-；"><a href="#3-List-lt-数据类型-gt-链表名-new-List-lt-数据类型-gt-声明数据量类型的数组-；" class="headerlink" title="3.List&lt;数据类型&gt; 链表名=new List&lt;数据类型&gt;(声明数据量类型的数组)；"></a>3.List&lt;数据类型&gt; 链表名=new List&lt;数据类型&gt;(声明数据量类型的数组)；</h6><p>如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] temArr = &#123; <span class="string">&quot;Ha&quot;</span>, <span class="string">&quot;Hunter&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Jay&quot;</span>, <span class="string">&quot;Jim&quot;</span>, <span class="string">&quot;Kuku&quot;</span>, <span class="string">&quot;Locu&quot;</span> &#125;;</span><br><span class="line">List testList = <span class="keyword">new</span> List(temArr);</span><br></pre></td></tr></table></figure>
<h2 id="为List添加值"><a href="#为List添加值" class="headerlink" title="为List添加值"></a>为List添加值</h2><h4 id="1-list-Add-值）"><a href="#1-list-Add-值）" class="headerlink" title="1.list.Add(值）"></a>1.list.Add(值）</h4><p><strong>2.创建List的2、3方法</strong> 如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List list=<span class="keyword">new</span> list();</span><br><span class="line">list.Add(<span class="number">1</span>);</span><br><span class="line">list.Add(<span class="number">2</span>);```</span><br><span class="line">&lt;h2&gt;显示List的值&lt;/h2&gt;</span><br><span class="line">&lt;h6&gt;<span class="number">1.</span>显示特定值：&lt;/h6&gt;</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line">ist list=<span class="keyword">new</span> list();</span><br><span class="line">list.Add(<span class="number">1</span>);</span><br><span class="line">list.Add(<span class="number">2</span>);</span><br><span class="line">Console.WriteLine(list[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h6 id="2-遍历List："><a href="#2-遍历List：" class="headerlink" title="2.遍历List："></a>2.遍历List：</h6><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ist list=<span class="keyword">new</span> list();</span><br><span class="line">list.Add(<span class="number">1</span>);</span><br><span class="line">list.Add(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> x <span class="keyword">in</span> list)Console.WriteLine(x);</span><br></pre></td></tr></table></figure>
<h2 id="删除List中的值"><a href="#删除List中的值" class="headerlink" title="删除List中的值"></a>删除List中的值</h2><p> 1.List. Remove(T item)       删除一个值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">mList.Remove(<span class="string">&quot;Hunter&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>List. RemoveAt(int index);   删除下标为index的元素</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">mList.RemoveAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>List. RemoveRange(int index, int count); 从下标index开始，删除count个元素</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">mList.RemoveRange(<span class="number">3</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>4.List.Clear() 清空所有元素</p>
<h1 id="②Dictionary"><a href="#②Dictionary" class="headerlink" title="②Dictionary"></a>②Dictionary</h1><p>Dictionary与List功能相似，但是Dictionary可以同时对应<strong>任意两种变量</strong>，而不是List中的索引对变量。可以体现为从一组<strong>键（Key）</strong>到一组<strong>值（Value）</strong>的映射。 创建一个Dictionary：</p>
<h6 id="Dictionary-lt-键类型-值类型-gt-字典名-new-Dictionary-lt-键类型-值类型-gt"><a href="#Dictionary-lt-键类型-值类型-gt-字典名-new-Dictionary-lt-键类型-值类型-gt" class="headerlink" title="Dictionary&lt;键类型,值类型&gt; 字典名=new Dictionary&lt;键类型,值类型&gt;;"></a>Dictionary&lt;键类型,值类型&gt; 字典名=new Dictionary&lt;键类型,值类型&gt;;</h6><p>具体添加、删除可以类比List。  </p>
<h1 id="③两种筛选算法"><a href="#③两种筛选算法" class="headerlink" title="③两种筛选算法"></a>③两种筛选算法</h1><h3 id="1-分类筛选："><a href="#1-分类筛选：" class="headerlink" title="1.分类筛选："></a>1.分类筛选：</h3><p>对于这样一组数：1,2,3,4,5,6,2,3,4,5,6,7,8,9,3,4,5,6,7,8,9,9,9,9 以每个数作为分类标准，查找<strong>有几个数</strong>，以及<strong>每个数重复了几次：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> protect = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span>[] a = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;9&quot;</span> &#125;;</span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; a.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    dic.Add(i, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; a.Length; x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dic.ContainsKey(x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> y = x; y &lt; a.Length; y++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (dic.ContainsKey(y)) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (dic[x] == dic[y]) </span><br><span class="line">                &#123; </span><br><span class="line">                    num++; </span><br><span class="line">                    <span class="keyword">if</span> (x != y) dic.Remove(y); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (num &gt; protect)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(dic[x] + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">        Console.WriteLine(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数字的个数多于protect规定的值时，才显示这个数，可以作为一种可选筛选标准。 运行结果如图：<img src="http://47.94.231.166/wp-content/uploads/2018/09/cmd_2018-09-23_11-59-28-300x168.png" alt=""></p>
<h3 id="2-随机数筛选"><a href="#2-随机数筛选" class="headerlink" title="2.随机数筛选"></a>2.随机数筛选</h3><p>一次产生多个随机数</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">Generate</span>(<span class="params"><span class="built_in">int</span> max,<span class="built_in">int</span> min</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List result = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="built_in">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (result.Count &lt;Settingdata.Default.num)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = GetRandom(min, max);</span><br><span class="line">        <span class="keyword">if</span> (!result.Contains(temp))</span><br><span class="line">        &#123;</span><br><span class="line">            result.Add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数min为最小值（包括），max为最大值（包括） 这里的GetRandom(min, max)是一种得到随机数的方法，可以是普通的以时间为seed的方法，也可以是RNG等多种方法 下面示例较为随机的使用RNG得到随机数的方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetRandom</span>(<span class="params"><span class="built_in">int</span> minVal, <span class="built_in">int</span> maxVal</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这样产生0 ~ 100的强随机数（不含100）</span></span><br><span class="line"><span class="built_in">int</span> m = maxVal - minVal;</span><br><span class="line"><span class="built_in">int</span> rnd = <span class="built_in">int</span>.MinValue;</span><br><span class="line"><span class="built_in">decimal</span> _base = (<span class="built_in">decimal</span>)<span class="built_in">long</span>.MaxValue;</span><br><span class="line"><span class="built_in">byte</span>[] rndSeries = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">8</span>];</span><br><span class="line">System.Security.Cryptography.RNGCryptoServiceProvider rng= <span class="keyword">new</span> System.Security.Cryptography.RNGCryptoServiceProvider();</span><br><span class="line">rng.GetBytes(rndSeries);</span><br><span class="line"><span class="built_in">long</span> l = BitConverter.ToInt64(rndSeries, <span class="number">0</span>);</span><br><span class="line">rnd = (<span class="built_in">int</span>)(Math.Abs(l) / _base * m);</span><br><span class="line"><span class="keyword">return</span> minVal + rnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数minVal为最小值（包括），maxVal为最大值（包括）</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】Mini clock小时钟</title>
    <url>/2018/08/17/%E3%80%90c%E3%80%91mini-clock%E5%B0%8F%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<p>该程序可以创建一个小时钟窗口，可以使您实时关注时间，支持调整字体颜色、大小、位置等设置，特别适合将状态栏隐藏的用户使用。   程序名：小时钟（Mini Clock） 体积：96KB（不包含后期生成的数据文件） 兼容性：Microsoft .NET Framework 4.5 以上（Windows 7，Windows Server 2008，Windows Server 2008 R2，Windows Vista，Windows 8/8.1/10) 支持的系统中可能需要手动安装Microsoft .NET Framework 4.5，请参阅<a href="https://www.microsoft.com/en-us/download/details.aspx?id=36359">官方声明</a><br><a id="more"></a></p>
<h1 id="2018-9-15-更新-Ver-1-2-0-2"><a href="#2018-9-15-更新-Ver-1-2-0-2" class="headerlink" title="2018.9.15 更新 Ver.1.2.0.2"></a>2018.9.15 更新 Ver.1.2.0.2</h1><p>调整： ⚪修复解锁位置再锁定位置后鼠标穿透失效的bug ⚪修复应用不完全隐藏的bug 下载：<a href="http://47.94.231.166/wp-content/uploads/2018/08/小时钟-3.zip">小时钟</a>    </p>
<h1 id="2018-8-19-更新-Ver-1-2-0-1"><a href="#2018-8-19-更新-Ver-1-2-0-1" class="headerlink" title="2018.8.19 更新 Ver.1.2.0.1"></a>2018.8.19 更新 Ver.1.2.0.1</h1><p><img src="http://47.94.231.166/wp-content/uploads/2018/08/小时钟_2018-08-19_12-16-55.png" alt=""> 调整： ⚪去字体边框，如上图（上：旧版，下：新版） ⚪修复背景无法被关闭的bug ⚪修复左右标反的问题 已知问题： ⚪解锁位置再锁定位置后，鼠标穿透失效 下载：<a href="http://47.94.231.166/wp-content/uploads/2018/08/小时钟-2.zip">小时钟</a> 源码：<a href="http://47.94.231.166/wp-content/uploads/2018/08/小时钟源码-2.zip">小时钟源码</a>      </p>
<h1 id="2018-8-18-更新-Ver-1-2-0-0"><a href="#2018-8-18-更新-Ver-1-2-0-0" class="headerlink" title="2018.8.18 更新 Ver 1.2.0.0"></a>2018.8.18 更新 Ver 1.2.0.0</h1><p><img src="http://47.94.231.166/wp-content/uploads/2018/08/2018-08-18_18-38-31.png" alt=""> <img src="http://47.94.231.166/wp-content/uploads/2018/08/2018-08-18_18-38-40.png" alt=""> <img src="http://47.94.231.166/wp-content/uploads/2018/08/2018-08-18_18-39-04.png" alt=""> 新增： ⚪保存应用设置 ⚪可选开关背景/选择背景颜色 ⚪鼠标完全穿透窗体 ⚪微调板即位置拖动调整 调整： ⚪主窗体调整 ⚪可选每次启动时是否打开主窗体 ⚪优化算法 <strong>暂未实现的功能：</strong> ⚪字体反色 下载链接：<a href="http://47.94.231.166/wp-content/uploads/2018/08/小时钟-1.zip">小时钟</a> 源码下载：<a href="http://47.94.231.166/wp-content/uploads/2018/08/小时钟源码-1.zip">小时钟源码</a>            </p>
<h1 id="2018-8-17-第一次发布，Ver-1-0-0-0"><a href="#2018-8-17-第一次发布，Ver-1-0-0-0" class="headerlink" title="2018.8.17 第一次发布，Ver 1.0.0.0"></a>2018.8.17 第一次发布，Ver 1.0.0.0<img src="http://47.94.231.166/wp-content/uploads/2018/08/2018-08-17_23-16-35.png" alt=""></h1><h4 id="目前实现的功能："><a href="#目前实现的功能：" class="headerlink" title="目前实现的功能："></a>目前实现的功能：</h4><p>⚪利用母窗口调整时钟的位置 ⚪调整时钟的透明度、大小 ⚪调整时钟的颜色 ⚪将母窗口隐藏在状态栏，通过下划窗口实现。</p>
<h4 id="暂未实现的功能："><a href="#暂未实现的功能：" class="headerlink" title="暂未实现的功能："></a>暂未实现的功能：</h4><p>⚪保存应用设置 ⚪可选开关背景/选择背景颜色 ⚪字体反色 ⚪鼠标完全穿透窗体         下载链接：<a href="http://47.94.231.166/wp-content/uploads/2018/08/小时钟.zip">小时钟</a> 源码：<a href="http://47.94.231.166/wp-content/uploads/2018/08/小时钟源码.zip">小时钟源码</a> 详细知识点见：<a href="http://upane.cn/archives/424">【C#】“小时钟”知识点总结</a></p>
]]></content>
      <categories>
        <category>Project.IDEA</category>
        <category>从零开始的代码学习计划</category>
      </categories>
      <tags>
        <tag>AnyPin</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】Operator转换</title>
    <url>/2018/09/27/%E3%80%90c%E3%80%91operator%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="①自定义转换"><a href="#①自定义转换" class="headerlink" title="①自定义转换"></a>①自定义转换</h1><blockquote>
<p>为自己的<strong>结构</strong>或者<strong>类</strong>定义显式和隐式转换</p>
</blockquote>
<h2 id="对目标对象进行隐式转换："><a href="#对目标对象进行隐式转换：" class="headerlink" title="对目标对象进行隐式转换："></a>对目标对象进行<strong>隐式转换</strong>：</h2><p>public static <strong>implicit</strong> operator 转换类型(被转换类型 目标对象){…}</p>
<h2 id="调用："><a href="#调用：" class="headerlink" title="调用："></a>调用：</h2><p>转换类型 转换类型的对象=目标对象;</p>
<p>这行代码应当出现在对象转换为的类中，而且转换函数是没有函数名称的，如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Dog</span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Dog</span>(<span class="params">Cat cat</span>)<span class="comment">//定义隐式转换</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Cat cat=<span class="keyword">new</span> Cart();</span><br><span class="line">        Dog dog=cat;<span class="comment">//调用隐式转换</span></span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对目标类型进行显式转换："><a href="#对目标类型进行显式转换：" class="headerlink" title="对目标类型进行显式转换："></a>对目标类型进行<strong>显式转换</strong>：</h2><p>public static <strong>explicit</strong> operator 转换类型(被转换类型 目标类){…}</p>
<h2 id="调用：-1"><a href="#调用：-1" class="headerlink" title="调用："></a>调用：</h2><p>转换类型 转换类型的对象=(转换类型的对象)目标对象;</p>
<p>如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Dog</span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Dog</span>(<span class="params">Cat cat</span>)<span class="comment">//定义显式转换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat=<span class="keyword">new</span> Cart();</span><br><span class="line">    Dog dog=(Dog)cat;<span class="comment">//调用显式转换</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="②重载运算符"><a href="#②重载运算符" class="headerlink" title="②重载运算符"></a>②重载运算符</h1><blockquote>
<p>利用<strong>现有的</strong>某种运算符，针对<strong>自定义</strong>类（派生）或者结构，<strong>定义某种运算操作</strong>。</p>
</blockquote>
<p>如：父亲*母亲=儿子 语法：</p>
<p>public static <strong>Human</strong> operator * (Human male,Human female)<br>{<br>…<br>return new Human();<br>}</p>
<p><strong>Human</strong> 为运算返回值。 重载运算符的定义语法也是在类中使用，实例化该例后即可对其对象和派生出的类的对象使用（是对类还是对对象要看如何定义）。 如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Human <span class="keyword">operator</span> + (Human male,Human female)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Human();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Human male=<span class="keyword">new</span> Human();</span><br><span class="line">        Human female=<span class="keyword">new</span> Human();</span><br><span class="line">        Human child=(female+male);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可重载的运算符：</p>
<p>一元运算符：+,-,!,~,++,—,true,false（操作数必须是类或结构）</p>
<p>二元运算符：+,-,*,/,%,&amp;,!,^,&lt;&lt;,&gt;&gt;,==,!=,&gt;,&lt;,&gt;=,&lt;= （两个操作数至少有一个是类或结构）</p>
<p>以下运算符<strong>不能重载</strong>：=,&amp;&amp;,,[],()<strong>等</strong> 重载运算符<strong>不能</strong>做以下事： ⚪创造新运算符 ⚪改变运算符语法 ⚪重定义因算符如何预处理类型（int a+int b等于a-b) ⚪改变运算符的优先级和结合性</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】PinPic图片前置应用</title>
    <url>/2018/08/19/%E3%80%90c%E3%80%91pinpic%E5%9B%BE%E7%89%87%E5%89%8D%E7%BD%AE%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>是否经常需要将图片pin到最前？（比如临摹、复写），那么你可以试一下这款小应用。 PinPic是一个可以把任意图片置顶到窗口最前的应用，该应用将作为AnyPin的一个组件使用，各个组件将分步完成，全部度过测试期后完成集合应用AnyPin。目测将有较长的开发周期。<br><a id="more"></a><br>程序名：PicPin 体积：524KB 兼容性：Microsoft .NET Framework 4.5 以上（Windows 7，Windows Server 2008，Windows Server 2008 R2，Windows Vista，Windows 8/8.1/10) 支持的系统中可能需要手动安装Microsoft .NET Framework 4.5，请参阅<a href="https://www.microsoft.com/en-us/download/details.aspx?id=36359">官方声明</a> 功能： 1.复制图片，文件、word或网站上等等的图片均可，按Alt+Q即可将图片置顶在屏幕上。 2.图片可拖动，也可以滑动鼠标滚轮来调整图片大小，当图片大小超过屏幕时仍可放大，但是会出现拖动条，拖动到你想要的视角即可。 3.双击图片可临时关闭图片窗口，点击通知栏里的“PicPin”图标即可恢复。对通知栏里的图标右键&gt;退出 即可关闭此应用。 注意：Beta版为测试版本，功能可能不稳定，请知悉。      </p>
<h1 id="2018-8-20更新-Ver-0-0-5-0-Beta"><a href="#2018-8-20更新-Ver-0-0-5-0-Beta" class="headerlink" title="2018.8.20更新 Ver. 0.0.5.0 Beta"></a>2018.8.20更新 Ver. 0.0.5.0 Beta</h1><p><img src="http://47.94.231.166/wp-content/uploads/2018/08/2018-08-20_13-01-47.jpg" alt=""> 新增： ⚪鼠标滚轮改变图片大小 ⚪缩小到通知栏，右键可关闭 调整： ⚪由于.NET平台限制，窗口大小不能超过屏幕分辨率，故图片放大超过屏幕大小时出现操作条供用户改变视角 ⚪检测剪切板数据类型，实现异常抛出 ⚪添加了图标，去除窗体，隐藏白框 目前待解决的问题： ⚪键盘钩子稳定性较差   下载：<a href="http://47.94.231.166/wp-content/uploads/2018/08/PinPic-1.zip">PinPic</a> 源码：<a href="http://47.94.231.166/wp-content/uploads/2018/08/PinPic源码-1.zip">PinPic源码</a></p>
<h1 id="2018-8-19第一次发布：Ver-0-0-1-0-Alpha"><a href="#2018-8-19第一次发布：Ver-0-0-1-0-Alpha" class="headerlink" title="2018.8.19第一次发布：Ver. 0.0.1.0 Alpha"></a>2018.8.19第一次发布：Ver. 0.0.1.0 Alpha</h1><p><img src="http://47.94.231.166/wp-content/uploads/2018/08/2018-08-19_19-46-50.jpg" alt=""> 目前已经完成的功能： ⚪复制图片（包括网络图片和本地图片），按alt+Q置顶，双击最小化 ⚪可改变窗口位置 目前还未实现的功能： ⚪更改窗口大小 ⚪将应用缩小到状态栏 ⚪键盘钩子稳定性较差 下载：<a href="http://47.94.231.166/wp-content/uploads/2018/08/PinPic.zip">PinPic</a> 源码：<a href="http://47.94.231.166/wp-content/uploads/2018/08/PinPic源码.zip">PinPic源码</a></p>
]]></content>
      <categories>
        <category>Project.IDEA</category>
      </categories>
      <tags>
        <tag>AnyPin</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】Post-in Notes便利贴</title>
    <url>/2018/08/27/%E3%80%90c%E3%80%91post-in-notes%E4%BE%BF%E5%88%A9%E8%B4%B4/</url>
    <content><![CDATA[<p>作为AnyPin的第三个组件，便利贴（Post-in Notes）即日起也到了验收测试时期，这款应用可以把复制的文本“pin”到屏幕上，并且保存最多20条历史纪录。你可以将它用作复制文本的“中间编辑器”也可以用作剪切板记录器，当然也可以直接当作便利贴使用。使用过程中如果出现任何问题可以在下方留言，我会及时处理。<br><a id="more"></a><br>程序名：Post-in Notes便利贴 体积：36KB 兼容性：Microsoft .NET Framework 4.5 以上（Windows 7，Windows Server 2008，Windows Server 2008 R2，Windows Vista，Windows 8/8.1/10) 支持的系统中可能需要手动安装Microsoft .NET Framework 4.5，请参阅<a href="https://www.microsoft.com/en-us/download/details.aspx?id=36359">官方声明</a> 使用方法： ①复制文本，按下Alt+A即可将文本拼贴在屏幕上，不复制文本将创建新页面。 ②双击窗口内容，将会关闭窗口，但内容不会被删除 ③”&lt;”、“&gt;”按钮可以切换页面，最多20条纪录 ④按住标题框，即可移动窗口 ⑤鼠标在窗口上，按住ctrl，利用鼠标滚轮即可放大、缩小字体  </p>
<h1 id="2018-2-27-第一次发布-Ver-0-0-5-0-Alpha"><a href="#2018-2-27-第一次发布-Ver-0-0-5-0-Alpha" class="headerlink" title="2018.2.27  第一次发布 Ver. 0.0.5.0 Alpha"></a>2018.2.27  第一次发布 Ver. 0.0.5.0 Alpha</h1><p><img src="http://47.94.231.166/wp-content/uploads/2018/08/2018-08-27_12-41-03.png" alt=""> <img src="http://47.94.231.166/wp-content/uploads/2018/08/2018-08-27_12-41-43.png" alt=""> 暂未实现的功能： ⚪文本导出 已知问题： ⚪提示的目前页数在新增页面后会被刷新 ⚪最大标签数仅为17个 下载：<a href="http://47.94.231.166/wp-content/uploads/2018/08/Post-it-Notes便利贴.zip">Post-it Notes便利贴</a> 源码：<a href="http://47.94.231.166/wp-content/uploads/2018/08/Post-it-Notes便利贴源码.zip">Post-it Notes便利贴源码</a></p>
]]></content>
      <categories>
        <category>Project.IDEA</category>
      </categories>
      <tags>
        <tag>AnyPin</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】Walkman Playlist Tools</title>
    <url>/2018/09/10/%E3%80%90c%E3%80%91walkman-playlist-tools/</url>
    <content><![CDATA[<p><img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_15-40-56.png" alt=""> Walkman Playlist Tools是一款<strong>专为Walkman创建播放列表</strong>设计的小程序。鉴于索尼先前开发的两款软件均对播放列表的功能支持不佳，决定开发一个程序解决此问题。若想了解更多请阅览下文。<br><a id="more"></a><br><strong>程序名称</strong>：Walkman Playlis Tools（前期开发名称为Walkman List Tools） <strong>体积</strong>：7.8MB <strong>兼容性</strong>：Microsoft .NET Framework 4.6.1 以上（Windows Server 2008 R2/2012/2012 R2，Windows 7/8/8.1/10) 支持的系统中可能需要手动安装Microsoft .NET Framework 4.6.1，请参阅<a href="https://www.microsoft.com/en-us/download/details.aspx?id=49982">官方声明</a> <strong>目前迭代版本</strong>：Ver 1.0.1.0 <strong>版权信息</strong>： Bass库来自<a href="http://www.un4seen.com/">Un4seen</a> 语言识别来自开源项目<a href="https://github.com/shuyo/language-detection">Language Detect</a> 其<a href="https://download.csdn.net/download/snngimfk/5146257">.NET版本</a>由CSDN用户@snngimfk封装   <strong>主要特性：</strong></p>
<ul>
<li>方便的播放列表制作体验</li>
<li>快捷导入本地、在线播放列表</li>
<li>自动下载歌词等工具  </li>
</ul>
<p><strong>使用教程请见：</strong><a href="http://upane.cn/archives/1140">Walkman Playlist Tools使用教程（第二版）</a>   <strong>该项目目前已开源，如需源码，欢迎光临→<a href="https://github.com/yimig/Walkman-Playlist-Tools">Github项目页</a></strong> <strong>下载地址：</strong></p>
<ul>
<li><strong>安装包：</strong><a href="http://upane.cn/playlist_tools/Walkman_Playlist_Tools.exe">Walkman_Playlist_Tools.exe</a></li>
<li><strong>增量更新：</strong><a href="http://upane.cn/playlist_tools/Update_for_1_0_0_0.zip">Update for 1.0.0.0.zip</a> 说明：鉴于服务器带宽较低，下载速度较慢，如果您已经下载最新版本的前一个版本，可以下载增量更新包解压后替换掉原目录里的文件，当然也可下载普通安装包安装。 标题语言自动识别功能需要安装J#环境，如果需要请前往以下地址下载：<ul>
<li>32位：<a href="http://www.microsoft.com/en-us/download/details.aspx?id=18084">http://www.microsoft.com/en-us/download/details.aspx?id=18084</a></li>
<li>64位：<a href="http://www.microsoft.com/en-us/download/details.aspx?id=15468">http://www.microsoft.com/en-us/download/details.aspx?id=15468</a></li>
</ul>
</li>
</ul>
<p>拓展识别语言包下载：<a href="http://47.94.231.166/wp-content/uploads/2018/09/profiles.zip">profiles</a> （674KB） 使用方法：下载后将其内部文件替换软件安装目录中的profile/目录中   <strong>开发日志：</strong></p>
<h3 id="2019-3-2-Ver-1-0-1-0"><a href="#2019-3-2-Ver-1-0-1-0" class="headerlink" title="2019.3.2 Ver 1.0.1.0"></a>2019.3.2 Ver 1.0.1.0</h3><p><strong>新增</strong></p>
<ul>
<li>拖动选中功能 <a href="http://upane.cn/wp-content/uploads/2018/09/2019-03-02_13-49-41.gif"><img src="http://upane.cn/wp-content/uploads/2018/09/2019-03-02_13-49-41-1024x485.gif" alt=""></a> （点击该gif图片查看效果）</li>
</ul>
<p><strong>修改</strong></p>
<ul>
<li>修复获得在线列表时提示异常的bug</li>
<li>修复第一次启用内存卡时扫描无效的bug</li>
</ul>
<h3 id="2019-2-10-Ver-1-0-0-0"><a href="#2019-2-10-Ver-1-0-0-0" class="headerlink" title="2019.2.10 Ver 1.0.0.0"></a>2019.2.10 Ver 1.0.0.0</h3><p><strong>新增</strong></p>
<ul>
<li>导入在线播放列表</li>
<li>自动分类：按年代、导入时间</li>
<li>工具：批量管理播放列表</li>
<li>工具：自动下载歌词</li>
<li>工具：批量转换歌词格式</li>
<li>工具：根据自定义规则生成播放列表</li>
<li>设置：标记SD卡列表等等</li>
</ul>
<p><strong>修改</strong></p>
<ul>
<li>所有代码回炉重造，增加了可维护性，为之后的更新做准备</li>
<li>换了用户界面框架，增加了图标，提升了用户体验（大概？</li>
<li>应用内部可以检查更新了</li>
</ul>
<h3 id="2018-11-21-Ver-0-9-1-1-Beta"><a href="#2018-11-21-Ver-0-9-1-1-Beta" class="headerlink" title="2018.11.21 Ver 0.9.1.1 Beta"></a>2018.11.21 Ver 0.9.1.1 Beta</h3><ul>
<li>修复：缓存位置为非根目录时无法保存缓存的问题</li>
</ul>
<h3 id="2018-11-21-Ver-0-9-1-Beta"><a href="#2018-11-21-Ver-0-9-1-Beta" class="headerlink" title="2018.11.21 Ver 0.9.1 Beta"></a>2018.11.21 Ver 0.9.1 Beta</h3><ul>
<li>修复：SD卡音乐不能从工作区移动到音乐列表的问题</li>
<li>修复：音乐标题按语言分类时崩溃的问题</li>
<li>修复：可选盘符扩展到Z：（目前为D: ~ Z:)</li>
</ul>
<h3 id="2018-9-10-第一版-Ver-0-9-Beta"><a href="#2018-9-10-第一版-Ver-0-9-Beta" class="headerlink" title="2018.9.10 第一版 Ver 0.9 Beta"></a>2018.9.10 第一版 Ver 0.9 Beta</h3><p>软件基本可用，进入测试期。如发现任何问题，请在下方留言。 非常欢迎您对软件bug进行申报。</p>
]]></content>
      <categories>
        <category>Project.IDEA</category>
      </categories>
      <tags>
        <tag>Walkman Playlist Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】WPF基础：基本控件篇</title>
    <url>/2018/10/07/%E3%80%90c%E3%80%91wpf%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="①基础知识"><a href="#①基础知识" class="headerlink" title="①基础知识"></a>①基础知识</h1><h2 id="1-参数sender"><a href="#1-参数sender" class="headerlink" title="1.参数sender"></a>1.参数sender</h2><p>一般我们新建事件后vs都会自动帮我们创建事件引发的方法，比如</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender,RoutedEventArgs e</span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>sender代表发生事件的控件，被封装为了object类型，所以如果我们想要引用之，需要<strong>显示转换</strong>。如鼠标单击按钮的事件中，若我们想获得被单击的按钮控件，可以写为</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Button button =(Button)sender;</span><br></pre></td></tr></table></figure>
<h2 id="2-参数e"><a href="#2-参数e" class="headerlink" title="2.参数e"></a>2.参数e</h2><p>参数e一般为EventArgs和RoutedEventArgs类型，RoutedEventArgs类型是路由事件，是一种特殊的EventArgs类型，我们将在以后学习，现在我们主要来讨论EventArgs类型： 如果object sender看作事件的主体，那么EventArgs e就可以看作<strong>事件的参数</strong>，形象一点说，如果把用户看作农夫，要完成“锄地”的动作，就要使用“锄头”这个sender，如此“锄地”事件发生时，系统就会把锄头落地的坐标、锄地的频率等等与锄地事件有关的<strong>信息</strong>打包成事件参数e发送给我们。 那么怎样使用这些数据呢？ 与参数object相同，EventArgs类型也是事件参数的一个“大类型”，要想使用之<strong>必须经过显示转换</strong>，在这之前我们需要知道这是由鼠标触发的事件（<strong>MouseEventArgs</strong>）还是键盘触发的事件（<strong>KeyPressEventArgs</strong>）抑或是其他东西触发的事件，如果转换为了错误的事件参数就会导致程序出错。</p>
<h3 id="鼠标事件（MouseEventArgs）"><a href="#鼠标事件（MouseEventArgs）" class="headerlink" title="鼠标事件（MouseEventArgs）"></a>鼠标事件（MouseEventArgs）</h3><p>鼠标事件常用的字段有： Button：表示用户按下鼠标哪个键触发了动作（左键Left、右键Right，在枚举类型MouseButtons中） Delta：表示用户触发事件的滚轮方向，这个值是方向（上滚为1，下滚为-1）乘以一个叫WHEEL_DELTA的常数（我这里测试为120，总之跟据符号就可以得到滚轮方向，值的大小不重要） Click：触发事件所按下键的次数 Location/X/Y：触发事件时鼠标的方位</p>
<h3 id="键盘事件（KeyPressEventArgs）"><a href="#键盘事件（KeyPressEventArgs）" class="headerlink" title="键盘事件（KeyPressEventArgs）"></a>键盘事件（KeyPressEventArgs）</h3><p>键盘事件常用的字段有： KeyChar：触发事件时按下的键，注意是char类型不是keys类型。   例判断用户是否为向上滚出发的事件：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button3_MouseWheel</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MouseEventArgs args = (MouseEventArgs) e;</span><br><span class="line"><span class="keyword">if</span> (args.Delta &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox.Show(<span class="string">&quot;上滚&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>可以为Null的类型称可空类型，有些类型（如int）默认初始化为0，所以无论如何也不会为空，故称不可空类型。 可空数据类型：<strong>引用类型</strong>（自定义类、string等等） 不可空数据类型：<strong>值类型</strong>（int、boolean、decimal、DateTime等等） 注意string s=””不等于string s=null。 第一个意义为长度为零的字符串，第二个意义为<strong>没有指向</strong>任何对象的字符串。 <strong>如果需要一个可空的值类型怎么办呢？</strong> 在类型后加一个问号，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int? i&#x3D;null;</span><br></pre></td></tr></table></figure>
<p><strong>实际上，就是把值类型转换为了引用类型</strong> int类型可以隐式转换为int？类型，反之则不能。就像float可以隐式转换为double类型反之也不能一样，<strong>谨记，范围小的转换为范围大的可以隐式转换，反之只能显示转换！</strong> 如果int？ i=null转换为int类型就算显示转换也会报错。</p>
<h1 id="②WPF入门"><a href="#②WPF入门" class="headerlink" title="②WPF入门"></a>②WPF入门</h1><p>WPF使用xaml文件来设计<strong>窗口</strong>、控件等可视化交互，当然也可以在其中创建winform的类<strong>窗体</strong>（class）。它与winform最大的不同就是xaml设计的窗口、控件与主窗口功能代码在<strong>一个类</strong>中，所以WPF设计出的多窗口<strong>只需实例化</strong>无需设置访问性。</p>
<h2 id="初识xaml"><a href="#初识xaml" class="headerlink" title="初识xaml"></a>初识xaml</h2><p>xaml语法上类似于html，标题尖括号打头，反斜杠标题尖括号结尾。 这与winform相比开发起来更加直观。 如 <a href="http://upane.cn/archives/786/devenv_2018-10-03_21-34-06"><img src="http://47.94.231.166/wp-content/uploads/2018/10/devenv_2018-10-03_21-34-06.png" alt=""></a> 可在其中为控件添加各种属性，写法也有两种，常见的为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Button Name&#x3D;&quot;subButton&quot; Click&#x3D;&quot;subButton_Click&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>这种写法的优点是字少，写起来比较方便，但是当添加属性过多时就会显得长而冗杂，于是又有这种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Button Click&#x3D;&quot;subButton_Click&quot;&gt;</span><br><span class="line">&lt;Name&gt;&quot;subButton&quot;&lt;&#x2F;Name&gt;</span><br><span class="line">&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure>
<p>这种写法在控件属性较多时便显得一目了然，便于控制了。</p>
<h3 id="注意！xaml的注释方法为"><a href="#注意！xaml的注释方法为" class="headerlink" title="注意！xaml的注释方法为"></a>注意！xaml的注释方法为</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--&lt;&#x2F;span&gt;&lt;&#x2F;strong&gt;被注释的语句，可跨行&lt;strong&gt;&lt;span style&#x3D;&quot;color: #339966;&quot;&gt;--&gt;</span><br></pre></td></tr></table></figure>
<h2 id="控件的通用属性"><a href="#控件的通用属性" class="headerlink" title="控件的通用属性"></a>控件的通用属性</h2><p>Name：空间名，唯一，用于区分控件 Content：空间上的文本，不唯一 Visbility：控件的可见性（<strong>值是枚举类型，不是bool类型！</strong>在System.Windows.Visbility下，Collapsed为隐藏，Visible为可见） IsEnabled：空间是否可用，bool类型 Background：背景色，在等于号后按下Ctrl+J即可调出颜色提示栏 FontSize：字体大小 在控件中添加控件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;控件&gt;</span><br><span class="line">&lt;控件.Content&gt;</span><br><span class="line">  （...其他控件)</span><br><span class="line">&lt;&#x2F;控件.Content&gt;</span><br><span class="line">&lt;&#x2F;控件&gt;</span><br></pre></td></tr></table></figure>
<p>有的控件中只允许添加一个控件，可以添加一个布局（StackPanel、Grid）来容纳多个控件。</p>
<h1 id="③WPF控件常用属性简介"><a href="#③WPF控件常用属性简介" class="headerlink" title="③WPF控件常用属性简介"></a>③WPF控件常用属性简介</h1><blockquote>
<p>未特殊声明的情况下，以下用法仅可在XAML中使用，不可在Class中使用。</p>
</blockquote>
<h2 id="0-Button按钮"><a href="#0-Button按钮" class="headerlink" title="0.Button按钮"></a>0.Button按钮</h2><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>插入文字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XAML:</span><br><span class="line">&lt;Button Content&#x3D;&quot;TextHere&quot; &#x2F;&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&lt;Button&gt;&quot;TextHere&quot;&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure>
<p>以上这俩效果相同 插入图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XAML:</span><br><span class="line">&lt;Button&gt;</span><br><span class="line">  &lt;Button.Content&gt;</span><br><span class="line">    &lt;Image Source&#x3D;&quot;图片的相对地址&quot;&gt;&lt;&#x2F;Image&gt;</span><br><span class="line">  &lt;&#x2F;Button.Content&gt;</span><br><span class="line">&lt;&#x2F;Button&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;可省略为&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&lt;Button&gt;</span><br><span class="line">  &lt;Image Source&#x3D;&quot;图片的相对地址&quot;&gt;&lt;&#x2F;Image&gt;</span><br><span class="line">&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure>
<p>这里只有Button可省略.Content。</p>
<h2 id="⒈TextBox文本输入框"><a href="#⒈TextBox文本输入框" class="headerlink" title="⒈TextBox文本输入框"></a>⒈TextBox文本输入框</h2><blockquote>
<p>可见、可输入文本的控件，若只需要可见文本可使用TextBlock控件。</p>
</blockquote>
<p>Text：内容文本 IsReadOnly：设置是否只读，bool类型，设置为true后无法对文本进行修改（可以复制） TextWrapping：枚举类型，设置为Wrap可自动折行 MaxLength：文本框内可输入字符的最大数量，整形</p>
<h2 id="⒉PasswordBox密码框"><a href="#⒉PasswordBox密码框" class="headerlink" title="⒉PasswordBox密码框"></a>⒉PasswordBox密码框</h2><blockquote>
<p>自动掩盖输入文本的控件</p>
</blockquote>
<p>Password：输入的文本，注意不是Text了。</p>
<h2 id="⒊CheckBox复选框"><a href="#⒊CheckBox复选框" class="headerlink" title="⒊CheckBox复选框"></a>⒊CheckBox复选框</h2><p>IsChecked：表示复选框是否已被选中，bool？类型，所以不能直接用if判断</p>
<h2 id="⒋RadioButton单选按钮"><a href="#⒋RadioButton单选按钮" class="headerlink" title="⒋RadioButton单选按钮"></a>⒋RadioButton单选按钮</h2><blockquote>
<p>要求用户对一个组进行单选的控件</p>
</blockquote>
<p>IsChecked：表示单选按钮是否已被选中，bool？类型。 GroupName：组名，一组单选按钮只能选择一个。</p>
<h2 id="⒌DatePicker日期选择器"><a href="#⒌DatePicker日期选择器" class="headerlink" title="⒌DatePicker日期选择器"></a>⒌DatePicker日期选择器</h2><p>SelectedDate：选择的日期，DateTime？类型，包含日期和时间。可为null，意义为未选择。（DateTime.Now为当前时间）</p>
<h2 id="6-Image图片控件"><a href="#6-Image图片控件" class="headerlink" title="6.Image图片控件"></a>6.Image图片控件</h2><p>Source：图片路径，路径为<strong>相对路径</strong>，即以程序视图的路径，若直接把图片资源放入程序文件夹内，则可以直接输入文件名。在Class中写法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Image img &#x3D; new Image();&#x2F;&#x2F;创建一个图片控件</span><br><span class="line">img.Source&#x3D;new BitmapImage(new Uri(&quot;图片的相对路径&quot;,UriKind.Relative));</span><br></pre></td></tr></table></figure>
<h2 id="⒎ProgressBar进度条"><a href="#⒎ProgressBar进度条" class="headerlink" title="⒎ProgressBar进度条"></a>⒎ProgressBar进度条</h2><p>IsIndeterminate：不确定模式，进度条内的进度一条一条滚动前行，表示程序正在运行。bool类型，true启用。 Maximum：最大值 Minimum：最小值 Value：当前值</p>
<h2 id="⒏Menu菜单"><a href="#⒏Menu菜单" class="headerlink" title="⒏Menu菜单"></a>⒏Menu菜单</h2><p>菜单分为普通菜单（Menu）和上下文菜单（ContextMenu，俗称右键菜单）。 WPF中的Menu可以显示在任意位置，但是一般是用布局显示到页面顶部。 Menu下面可以放多个MenuItem（其实是放到Items属性中）。MenuItem下还可以放MenuItem（还是Items属性中），属性Header显示内容。</p>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Menu&gt;</span><br><span class="line">  &lt;MenuItem Header&#x3D;&quot;标题名1&quot; &#x2F;&gt; 子菜单标题</span><br><span class="line">  &lt;MenuItem Header&#x3D;&quot;标题名2&quot; &gt;</span><br><span class="line">    &lt;MenuItem Header&#x3D;&quot;标题名2.1&quot; &#x2F;&gt; 孙菜单标题</span><br><span class="line">    &lt;MenuItem Header&#x3D;&quot;标题名2.2&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;MenuItem&gt;</span><br><span class="line">&lt;&#x2F;Menu&gt;</span><br></pre></td></tr></table></figure>
<p>把Menu “拼”到窗口顶部详见布局篇 示例： <a href="http://upane.cn/archives/786/devenv_2018-10-10_16-15-15"><img src="http://47.94.231.166/wp-content/uploads/2018/10/devenv_2018-10-10_16-15-15-217x300.png" alt=""></a> 效果： <a href="http://upane.cn/archives/786/devenv_2018-10-10_11-36-47"><img src="http://47.94.231.166/wp-content/uploads/2018/10/devenv_2018-10-10_11-36-47-300x151.png" alt=""></a></p>
<h2 id="⒐ToolBar工具栏"><a href="#⒐ToolBar工具栏" class="headerlink" title="⒐ToolBar工具栏"></a>⒐ToolBar工具栏</h2><p>工具栏就是一般在菜单栏下面的用作快速打开菜单栏内项目的工具，像：<a href="http://upane.cn/archives/786/devenv_2018-10-10_16-55-09"><img src="http://47.94.231.166/wp-content/uploads/2018/10/devenv_2018-10-10_16-55-09.png" alt=""></a> 就是工具栏。</p>
<h3 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ToolBar&gt;</span><br><span class="line">  (...控件)</span><br><span class="line">&lt;\ToolBar&gt;</span><br></pre></td></tr></table></figure>
<p>示例： <a href="http://upane.cn/archives/786/devenv_2018-10-10_17-25-33"><img src="http://47.94.231.166/wp-content/uploads/2018/10/devenv_2018-10-10_17-25-33-300x194.png" alt=""></a> 效果： <a href="http://upane.cn/archives/786/wpfapp1_2018-10-10_17-25-43"><img src="http://47.94.231.166/wp-content/uploads/2018/10/WpfApp1_2018-10-10_17-25-43-300x169.png" alt=""></a> 由上图可以看出，某些控件包含入工具栏后外观会有变化。比如RadioButton、CheckBox等。</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】WPF基础：多窗口应用篇</title>
    <url>/2018/10/10/%E3%80%90c%E3%80%91wpf%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%BA%94%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="①普通窗口"><a href="#①普通窗口" class="headerlink" title="①普通窗口"></a>①普通窗口</h1><h2 id="新建一个窗口"><a href="#新建一个窗口" class="headerlink" title="新建一个窗口"></a>新建一个窗口</h2><p>与Winform相仿，WPF的窗口也是一个类，但是我们在新建窗口时新建的是一个Xaml（外观）与一个类（功能），而不是Winform那样两个类（外观+功能）了。 既然窗口是个类，那么显示窗口<strong>也需要实例化</strong>。 然后，调用Show或者ShowDialog方法，像WinForm一样。</p>
<h2 id="自定义窗口"><a href="#自定义窗口" class="headerlink" title="自定义窗口"></a>自定义窗口</h2><p>像所有控件一样，窗口也可以在Xaml中设置各种属性，常用属性如下： Title：标题 ResizeMode：定义窗口大小是否可被改变，随之也会改变右上的三个功能键。如设置为“NoResize”不能改变大小，那么三个按钮中就只剩下关闭了，且窗口边框也不可被拖动。 WindowStartupLocation：窗口起始位置，默认在左上角，可设置为“CenterScreen”屏幕中央。 WindowState：默认窗口大小，即窗口打开时默认的大小，有最大化（Maximized）最小化（Minimized）和正常大小（Normal）可选。</p>
<h2 id="窗口之间传值"><a href="#窗口之间传值" class="headerlink" title="窗口之间传值"></a>窗口之间传值</h2><p>在<strong>任何</strong>一个窗口的类中创建一个<strong>公共的字段</strong>，然后另一个窗口调用之即可。有的同学会问，如果在子窗口中创建字段母窗口调用，子窗口一关闭字段还能够被提取吗？这个是可以的，<strong>因为C#中的垃圾回收机制是没有调用，则回收。</strong>刚刚所说的窗口虽然关闭，但是后面的代码引用到了该对象的内容，那么该对象则不会被销毁，直到最后一次引用结束。</p>
<h2 id="ShowDialog"><a href="#ShowDialog" class="headerlink" title="ShowDialog"></a>ShowDialog</h2><p>ShowDialog是一种<strong>延迟方法</strong>，代码运行至此会等待窗口关闭才会继续运行，这时它与Show方法最大的区别。 另外在弹出的窗口中若给DialogResult属性赋值（Bool？<strong>可空布尔类型</strong>），<strong>则窗口会被关闭</strong>，同时ShowDialog会将该值返回。注意若用户点击了关闭按钮，那么默认返回False，而不是Null。</p>
<h1 id="②打开文件对话框"><a href="#②打开文件对话框" class="headerlink" title="②打开文件对话框"></a>②打开文件对话框</h1><h2 id="创建打开文件对话框"><a href="#创建打开文件对话框" class="headerlink" title="创建打开文件对话框"></a>创建打开文件对话框</h2><p><strong>引入库 Microsoft.Win32</strong></p>
<p>OpenFileDialog ofd=new OpenFileDialog();<br>ofd.Filter =”文本文件*.txt音乐文件*.mp3,*.wav” //筛选文件<br>if(ofd.ShowDialog()==true)//是否选择了文件<br>{<br>  string file=ofd.FileName;<br>}</p>
<p>需要注意的是，ofd.ShowDialog()返回的是<strong>bool？类型</strong>的值，故不能直接用if包含。 Filter筛选文件的标准是： <strong>用“”隔开，两个一组，前面是描述，后面是扩展名，若使用多个扩展名则用逗号隔开。</strong></p>
<h2 id="得到文件"><a href="#得到文件" class="headerlink" title="得到文件"></a>得到文件</h2><p>调用ofd.<strong>FileName</strong>可直接得到用户选中的<strong>文件地址</strong> 若想得到多个文件，则需要提前打开：</p>
<p>ofd.Multiselect=true;</p>
<p>然后调用ofd.<strong>FileNames</strong>得到一个<strong>字符串数组</strong>，其内容就是选中的文件的地址.</p>
<h1 id="③保存文件对话框"><a href="#③保存文件对话框" class="headerlink" title="③保存文件对话框"></a>③保存文件对话框</h1><p>保存文件对话框与打开文件对话框使用方式基本相同，都需要引入<strong>Microsoft.Win32</strong>，只不过调用的是<strong>SaveFileDialog</strong>。如：</p>
<p>SaveFileDialog sfd=new SaveFileDialog();<br>sfd.Filter =”文本文件*.txt音乐文件*.mp3,*.wav” //筛选文件<br>if(sfd.ShowDialog()==true)//是否选择了文件<br>{<br>  string file=sfd.FileName;<br>}</p>
<p>这里需要注意的是，如果标明了文件格式（Filter可选），用户填入名字后系统会返回“名字+扩展名”的完整地址（用户填不填扩展名无妨），若未标明则需要用户填写或者开发者提前定义好扩展名。</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】WPF基础：页面布局篇</title>
    <url>/2018/10/08/%E3%80%90c%E3%80%91wpf%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E7%AF%87/</url>
    <content><![CDATA[<p>使用拖放控件的方法构筑应用界面时最尴尬的情况便是无法修改窗体的大小，即使强制修改窗体大小控件大小也依然不变，本篇所讲的页面布局就是为修正此问题而产生的解决方案。<br><a id="more"></a><br>拖放控件的方法为窗口添加的是控件的坐标位置，所以窗口缩放时空间位置仍然不变，如果我们不使用“绝对的”坐标，而使用“相对的”<strong>框架</strong>，那么在缩放窗口时控件也能随之缩放。 下面，主要介绍两种常用“框架”：StackPanel布局和Grid布局。</p>
<h2 id="控件公用属性："><a href="#控件公用属性：" class="headerlink" title="控件公用属性："></a>控件公用属性：</h2><p>Margin：控件距离四周的边距 HorizontalAlignment：文本的水平布局，Center为居中 VerticalAlignment：文本的纵向布局，Center为居中</p>
<h1 id="①StackPanel布局"><a href="#①StackPanel布局" class="headerlink" title="①StackPanel布局"></a>①StackPanel布局</h1><p>Stack，即栈，可以理解为一种<strong>单向布局</strong>，可以将控件纵向或横向堆积，仅一维分布在布局中。</p>
<h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p><strong>XAML：</strong></p>
<p><StackPanel><br>  (…控件)
</StackPanel><br><strong>Class：</strong> 栈布局名.Children.Add(空间名)</p>
<p>如： <a href="http://upane.cn/archives/794/devenv_2018-10-08_16-50-48"><img src="http://47.94.231.166/wp-content/uploads/2018/10/devenv_2018-10-08_16-50-48.png" alt=""></a> 效果： <a href="http://upane.cn/archives/794/wpfapp1_2018-10-08_16-50-19"><img src="http://47.94.231.166/wp-content/uploads/2018/10/WpfApp1_2018-10-08_16-50-19-300x169.png" alt=""></a></p>
<h2 id="常用属性："><a href="#常用属性：" class="headerlink" title="常用属性："></a>常用属性：</h2><p>Orientation：排列方式，枚举类型：Vertical（纵向排列） Horizontal（横向排列）</p>
<h1 id="②Grid布局"><a href="#②Grid布局" class="headerlink" title="②Grid布局"></a>②Grid布局</h1><p>Grid，即表格，可以理解为可同时设置<strong>多行多列</strong>的布局，控件可二维分布在布局中。</p>
<h2 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h2><p><strong>XAML：</strong></p>
<p><Grid><br>  <Grid.ColumnDefinitions><br>    <ColumnDefinition></ColumnDefinition><br>    ….列数，有几列写几个<br>  &lt;/Grid.ColumnDefinitions&gt;<br>  <Grid.RowDefinitions><br>    <RowDefinition></RowDefinition><br>    ….行数，有几行写几个<br>  &lt;/Grid.RowDefinitions&gt;<br>  &lt;控件 Grid.Row=”行数” Grid.Column=”列数” /&gt;<br>  (…控件）
</Grid><br><strong>Class：</strong> ColumnDefinition cdf = new ColumnDefinition();<br>表格布局名.ColumnDefinitions.Add(cdf);//添加一列<br>RowDefinition rdf = new RowDefinition();<br>表格布局名.RowDefinitions.Add(rdf);//添加一行<br>Grid.SetRow(控件名,行数);//设置控件行<br>Grid.SetColumn(控件名,列数);//设置控件列<br>表格布局名.Children.Add(控件名);//添加控件</p>
<p>需要注意的是控制空间位置的“行数”和“列数”是从零开始的。 如三行五列中间一个Button： <a href="http://upane.cn/archives/794/devenv_2018-10-08_17-22-07"><img src="http://47.94.231.166/wp-content/uploads/2018/10/devenv_2018-10-08_17-22-07.png" alt=""></a> 效果： <a href="http://upane.cn/archives/794/wpfapp1_2018-10-08_17-21-45"><img src="http://47.94.231.166/wp-content/uploads/2018/10/WpfApp1_2018-10-08_17-21-45-300x169.png" alt=""></a></p>
<h2 id="常用属性：-1"><a href="#常用属性：-1" class="headerlink" title="常用属性："></a>常用属性：</h2><p>Grid.Width：列属性（ColumnDefinition）中可设置列的宽度，默认为等分 Grid.Height：行属性（RowDefinition）中可设置行的高度，默认为等分 Grid.ColumnSpan：控件跨列的个数，从所在列开始向右跨列 Grid.RowSpan：控件跨行的个数，从所在行开始向上跨行</p>
<h1 id="③布局的嵌套"><a href="#③布局的嵌套" class="headerlink" title="③布局的嵌套"></a>③布局的嵌套</h1><p>布局是可以相互嵌套的，Grid和StackPanel之间也可以互相嵌套，灵活使用以达到最佳效果。</p>
<h1 id="补充：DockPanel布局"><a href="#补充：DockPanel布局" class="headerlink" title="补充：DockPanel布局"></a>补充：DockPanel布局</h1><p>Dock即停驻、船坞，DockPanel是一种可以<strong>停驻于窗口四周</strong>的布局。</p>
<h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><p><strong>XAML：</strong> <DockPanel><br>  &lt;控件名  DockPanel.Dock=”Top”&gt;//将该控件置于窗口顶部
</DockPanel></p>
<h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h2><p><a href="http://upane.cn/archives/794/wpfapp1_2018-10-10_16-28-58"><img src="http://47.94.231.166/wp-content/uploads/2018/10/WpfApp1_2018-10-10_16-28-58-300x169.png" alt=""></a> 因为没有其他控件，所以一整个窗体都是按钮。DockPanel布局中最新的控件拥有侵占最大区域的能力，如果再在底部添加一个按钮（如下图），底部按钮侵占大部分区域，顶部按钮在未设置width的情况下被压缩至最小。 <a href="http://upane.cn/archives/794/wpfapp1_2018-10-10_16-31-57"><img src="http://47.94.231.166/wp-content/uploads/2018/10/WpfApp1_2018-10-10_16-31-57-300x169.png" alt=""></a> 可见，谁最大就看谁最后添加。</p>
<h2 id="常用属性：-2"><a href="#常用属性：-2" class="headerlink" title="常用属性："></a>常用属性：</h2><p>DockPanel.Dock：停驻位置：Top（顶部）、Bottom（底部）、Left、Right</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】事件的传统定义方法</title>
    <url>/2018/11/19/%E3%80%90c%E3%80%91%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>代码来自刘铁猛老师的视频课程,之后会更新C#事件的笔记，目前有些东西还没有搞明白，权且放一放，待时间充裕时再做研究。<br><a id="more"></a><br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line">namespace @event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*这是一个模拟顾客进店点餐的代码：</span></span><br><span class="line"><span class="comment">         代码功能按照以下顺序实现：</span></span><br><span class="line"><span class="comment">         顾客进店，坐下，思考，然后呼叫服务员点餐，服务员记账，用餐完毕付账。  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Customer customer = <span class="keyword">new</span> Customer();<span class="comment">//实例化事件的拥有着：顾客</span></span><br><span class="line">            Waiter waiter = <span class="keyword">new</span> Waiter();<span class="comment">//实例化事件的订阅者：服务员</span></span><br><span class="line">            customer.Order += waiter.Action;<span class="comment">//绑定事件的处理器（订阅事件）</span></span><br><span class="line">            customer.Action();<span class="comment">//顾客：开始行动</span></span><br><span class="line">            customer.PayTheBill();<span class="comment">//顾客：付款</span></span><br><span class="line">            Console.ReadLine();<span class="comment">//暂停程序显示数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*声明一个订单（点餐事件的信息），包含菜名和分量两个信息*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderEventArgs</span> : <span class="title">EventArgs</span><span class="comment">//并不强制，但规定凡事件的信息需继承自EventArgs类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> DishName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//菜名</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//分量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*声明订餐的委托类，注意这是个类，不要声明在其他类中*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OrderEventHander</span>(<span class="params">Customer customer, OrderEventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*声明顾客类，其包含以下信息</span></span><br><span class="line"><span class="comment">     订餐事件、走进餐馆、坐下、思考、呼叫服务员点餐的方法，并有付账方法以及一个记录款项总额的字段用于记录服务员提供的订单*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> OrderEventHander orderEventHander;<span class="comment">//声明委托成员，用于记录收听订餐事件的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> OrderEventHander Order<span class="comment">//声明点餐事件（事件成员）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">add</span><span class="comment">//添加收听该事件的方法</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.orderEventHander += <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">remove</span><span class="comment">//移除收听该事件的方法</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.orderEventHander -= <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里很像属性</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Bill &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//声明一个用于记录服务员回传款项的字段</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PayTheBill</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Customer：I will pay $&#123;0&#125;.&quot;</span>, <span class="keyword">this</span>.Bill);</span><br><span class="line">        &#125;<span class="comment">//顾客埋单</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Walkin</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Customer：Walk in the restaurant.&quot;</span>);</span><br><span class="line">        &#125;<span class="comment">//顾客走进餐馆</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetDown</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;<span class="comment">//顾客坐下</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Think</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Customer：Let me think...&quot;</span>);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="comment">//顾客想了5秒</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.orderEventHander != <span class="literal">null</span>)<span class="comment">//排除无方法收听的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                OrderEventArgs e = <span class="keyword">new</span> OrderEventArgs();<span class="comment">//实例化一个订单信息</span></span><br><span class="line">                e.DishName = <span class="string">&quot;Kongpao Chicken&quot;</span>;<span class="comment">//顾客点了宫保鸡丁</span></span><br><span class="line">                e.Size = <span class="string">&quot;large&quot;</span>;<span class="comment">//大份宫保鸡丁</span></span><br><span class="line">                <span class="keyword">this</span>.orderEventHander.Invoke(<span class="keyword">this</span>, e);<span class="comment">//呼叫服务员（执行订餐委托）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//顾客思考并下单</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)<span class="comment">//顾客进店以来点餐前的行动</span></span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Walkin();</span><br><span class="line">            <span class="keyword">this</span>.SetDown();</span><br><span class="line">            <span class="keyword">this</span>.Think();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*声明一个服务员类，包含以下信息：</span></span><br><span class="line"><span class="comment">     服务员收听到顾客的召唤（执行订餐委托）所执行的方法*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Waiter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params">Customer customer, OrderEventArgs e</span>)<span class="comment">//收听订餐委托的方法，接受顾客身份和一道菜的订单</span></span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Waiter：I will serve you the dish -&#123;0&#125;&quot;</span>, e.DishName);<span class="comment">//为顾客报菜名</span></span><br><span class="line">            <span class="built_in">double</span> price = <span class="number">10</span>;<span class="comment">//设置基准价格</span></span><br><span class="line">            <span class="keyword">switch</span> (e.Size)<span class="comment">//大份菜是基准价格的1.5倍，小份菜是基准价格的0.5倍</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;small&quot;</span>:</span><br><span class="line">                    price *= <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;large&quot;</span>:</span><br><span class="line">                    price *= <span class="number">0.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            customer.Bill += price;<span class="comment">//为顾客的账单添加一道菜的款项</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 事件的拥有者：Customer</span></span><br><span class="line"><span class="comment">     * 事件成员：Order</span></span><br><span class="line"><span class="comment">     * 事件的响应者：Waiter</span></span><br><span class="line"><span class="comment">     * 事件处理器：wait.Action(Customer customer, OrderEventArgs e)</span></span><br><span class="line"><span class="comment">     * 事件订阅：customer.Order += waiter.Action;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><a href="http://upane.cn/archives/946/event_2018-11-19_23-02-56"><img src="http://47.94.231.166/wp-content/uploads/2018/11/@event_2018-11-19_23-02-56.png" alt=""></a></p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】事件详解</title>
    <url>/2018/11/27/%E3%80%90c%E3%80%91%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="http://47.94.231.166/wp-content/uploads/2018/11/Event.html">>无扰阅读模式(测试)</a><br><a id="more"></a></p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>[Event]</p>
<hr>
<p>发生→相应”的<strong>五个动作</strong>：</p>
<ul>
<li>事件是使对象或类具备<strong>通知能力</strong>的成员</li>
<li><strong>事件功能=功能+参数（可选）</strong></li>
<li>使用：用于对象或类间的动作协调与信息传递（消息推送）</li>
</ul>
<h2 id="①原理"><a href="#①原理" class="headerlink" title="①原理"></a>①原理</h2><h4 id="事件模型中的两个“5”："><a href="#事件模型中的两个“5”：" class="headerlink" title="事件模型中的两个“5”："></a>事件模型中的两个“5”：</h4><h4 id="“发生→相应”-中的五个部分"><a href="#“发生→相应”-中的五个部分" class="headerlink" title="“发生→相应” 中的五个部分:"></a>“发生→相应” 中的五个部分:</h4><blockquote>
<h4 id="“闹钟1-响了2-我3-起床4”"><a href="#“闹钟1-响了2-我3-起床4”" class="headerlink" title="“闹钟1 响了2 我3 起床4”"></a>“闹钟1 响了2 我3 起床4”</h4><p>1发生事件的对象 2事件的内容 3对事件做出响应的对象 4对事件做出响应的对象的响应内容</p>
<h4 id="5订阅关系"><a href="#5订阅关系" class="headerlink" title="5订阅关系"></a>5订阅关系</h4></blockquote>
<h4 id="“发生→相应”的五个动作："><a href="#“发生→相应”的五个动作：" class="headerlink" title="“发生→相应”的五个动作："></a>“发生→相应”的五个动作：</h4><blockquote>
<h4 id="⑴我有一个事件→⑵一个人或一群人关心我的这个事件→⑶事件发生了→⑷关心这个事件的人被依次通知→⑸被通知的人根据拿到的事件参数对事件进行响应"><a href="#⑴我有一个事件→⑵一个人或一群人关心我的这个事件→⑶事件发生了→⑷关心这个事件的人被依次通知→⑸被通知的人根据拿到的事件参数对事件进行响应" class="headerlink" title="⑴我有一个事件→⑵一个人或一群人关心我的这个事件→⑶事件发生了→⑷关心这个事件的人被依次通知→⑸被通知的人根据拿到的事件参数对事件进行响应"></a>⑴我有一个事件→⑵一个人或一群人关心我的这个事件→⑶事件发生了→⑷关心这个事件的人被依次通知→⑸被通知的人根据拿到的事件参数对事件进行响应</h4></blockquote>
<p>提示： 1. 事件多用于桌面、手机等开发客户端的编程，因为这些程序经常是用户通过事件来“驱动”的。 1. 各编程语言对这个机制实现的方法不尽相同，Java语言无事件成员也无委托这种数据类型，其“事件”是使用<strong>接口</strong>实现的。 1. MVC、MVP、MVVM等模式，是事件模式更高级、更有效的玩法。 1. 日常开发的时候，使用已有事件的机会比较多，自己声明事件的机会比较少。 ## ②事件的应用(使用事件)</p>
<p>功能</p>
<p>实现形式</p>
<p>事件的拥有者</p>
<p>对象</p>
<p>事件成员</p>
<p>成员</p>
<p>事件响应者</p>
<p>对象</p>
<p>事件处理器</p>
<p>成员</p>
<p>事件订阅</p>
<p>(委托)*</p>
<p>*把事件处理器与事件关联在一起，本质上是一种委托类型为基础的约定</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Timer timer=<span class="keyword">new</span> Timer();<span class="comment">//定义一个事件的拥有着</span></span><br><span class="line">        timer.Interval=<span class="number">1000</span>;<span class="comment">//设置时钟每1s触发一次Elapsed事件</span></span><br><span class="line">        Boy boy=<span class="keyword">new</span> Boy();<span class="comment">//定义一个事件的响应者</span></span><br><span class="line">        timer.Elapsed+=boy.Action;<span class="comment">//用+=订阅事件</span></span><br><span class="line">        <span class="comment">//↑事件          ↑     ↑事件的处理器</span></span><br><span class="line">        <span class="comment">//               ┕事件的响应者</span></span><br><span class="line">        timer.Start();<span class="comment">//启用时钟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Boy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"><span class="built_in">object</span> sender,ElapsedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.Writeline(<span class="string">&quot;Jump!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件处理器，建议在订阅事件中自动生成（Ctrl+.+Enter），否则不易确定参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两种挂接方式"><a href="#两种挂接方式" class="headerlink" title="两种挂接方式"></a>两种挂接方式</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.button.Click+=<span class="keyword">new</span> EventHandler(<span class="keyword">this</span>.ButtonClicked);</span><br><span class="line"><span class="keyword">this</span>.button.Click+=<span class="keyword">this</span>.ButtonClicked;</span><br></pre></td></tr></table></figure>
<h2 id="③事件的声明（自定义事件）"><a href="#③事件的声明（自定义事件）" class="headerlink" title="③事件的声明（自定义事件）"></a>③事件的声明（自定义事件）</h2><h3 id="四种事件构建形式："><a href="#四种事件构建形式：" class="headerlink" title="四种事件构建形式："></a>四种事件构建形式：</h3><p><a href="http://upane.cn/archives/962/chrome_2018-11-14_17-15-02"><img src="http://47.94.231.166/wp-content/uploads/2018/11/chrome_2018-11-14_17-15-02-1024x202.png" alt=""></a> <a href="http://upane.cn/archives/962/chrome_2018-11-14_17-14-49"><img src="http://47.94.231.166/wp-content/uploads/2018/11/chrome_2018-11-14_17-14-49.png" alt=""></a></p>
<h3 id="示例（使用简化版，注释掉的为标准版）："><a href="#示例（使用简化版，注释掉的为标准版）：" class="headerlink" title="示例（使用简化版，注释掉的为标准版）："></a>示例（使用简化版，注释掉的为标准版）：</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line">namespace @event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*这是一个模拟顾客进店点餐的代码：</span></span><br><span class="line"><span class="comment">         代码功能按照以下顺序实现：</span></span><br><span class="line"><span class="comment">         顾客进店，坐下，思考，然后呼叫服务员点餐，服务员记账，用餐完毕付账。  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Customer customer = <span class="keyword">new</span> Customer();<span class="comment">//实例化事件的拥有着：顾客</span></span><br><span class="line">            Waiter waiter = <span class="keyword">new</span> Waiter();<span class="comment">//实例化事件的订阅者：服务员</span></span><br><span class="line">            customer.Order += waiter.Action;<span class="comment">//绑定事件的处理器（订阅事件）</span></span><br><span class="line">            customer.Action();<span class="comment">//顾客：开始行动</span></span><br><span class="line">            customer.PayTheBill();<span class="comment">//顾客：付款</span></span><br><span class="line">            Console.ReadLine();<span class="comment">//暂停程序显示数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*声明一个订单（点餐事件的信息），包含菜名和分量两个信息*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderEventArgs</span> : <span class="title">EventArgs</span><span class="comment">//并不强制，但规定凡事件的信息需继承自EventArgs类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> DishName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//菜名</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//分量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*声明订餐的委托类，注意这是个类，不要声明在其他类中*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OrderEventHander</span>(<span class="params">Customer customer, OrderEventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*声明顾客类，其包含以下信息</span></span><br><span class="line"><span class="comment">     订餐事件、走进餐馆、坐下、思考、呼叫服务员点餐的方法，并有付账方法以及一个记录款项总额的字段用于记录服务员提供的订单*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> OrderEventHander orderEventHander;<span class="comment">//声明委托成员，用于记录收听订餐事件的方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  //这里是标准的事件定义方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public event OrderEventHander Order//声明点餐事件（事件成员）</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            add//添加收听该事件的方法</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                this.orderEventHander += value;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            remove//移除收听该事件的方法</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                this.orderEventHander -= value;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //这里很像属性</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> OrderEventHander Order;<span class="comment">//语法糖</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Bill &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//声明一个用于记录服务员回传款项的字段</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PayTheBill</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Customer：I will pay $&#123;0&#125;.&quot;</span>, <span class="keyword">this</span>.Bill);</span><br><span class="line">        &#125;<span class="comment">//顾客埋单</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Walkin</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Customer：Walk in the restaurant.&quot;</span>);</span><br><span class="line">        &#125;<span class="comment">//顾客走进餐馆</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetDown</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;<span class="comment">//顾客坐下</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Think</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Customer：Let me think...&quot;</span>);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//顾客想了5秒</span></span><br><span class="line">             <span class="comment">/* //标准的事件调用方法</span></span><br><span class="line"><span class="comment">                 if (this.orderEventHander != null)//排除无方法收听的情况</span></span><br><span class="line"><span class="comment">                 &#123;</span></span><br><span class="line"><span class="comment">                     OrderEventArgs e = new OrderEventArgs();//实例化一个订单信息</span></span><br><span class="line"><span class="comment">                     e.DishName = &quot;Kongpao Chicken&quot;;//顾客点了宫保鸡丁</span></span><br><span class="line"><span class="comment">                     e.Size = &quot;large&quot;;//大份宫保鸡丁</span></span><br><span class="line"><span class="comment">                     this.orderEventHander.Invoke(this, e);//呼叫服务员（执行订餐委托）</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.Order != <span class="literal">null</span>)<span class="comment">//排除无方法收听的情况</span></span><br><span class="line">            <span class="comment">//这里的调用order事件实为语法糖，实际应该是一个委托</span></span><br><span class="line">            &#123;</span><br><span class="line">                OrderEventArgs e = <span class="keyword">new</span> OrderEventArgs();<span class="comment">//实例化一个订单信息</span></span><br><span class="line">                e.DishName = <span class="string">&quot;Kongpao Chicken&quot;</span>;<span class="comment">//顾客点了宫保鸡丁</span></span><br><span class="line">                e.Size = <span class="string">&quot;large&quot;</span>;<span class="comment">//大份宫保鸡丁</span></span><br><span class="line">                <span class="keyword">this</span>.Order.Invoke(<span class="keyword">this</span>, e);<span class="comment">//呼叫服务员（执行订餐委托）</span></span><br><span class="line">                <span class="comment">//这里的Order也是语法糖</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//顾客思考并下单</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)<span class="comment">//顾客进店以来点餐前的行动</span></span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Walkin();</span><br><span class="line">            <span class="keyword">this</span>.SetDown();</span><br><span class="line">            <span class="keyword">this</span>.Think();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*声明一个服务员类，包含以下信息：</span></span><br><span class="line"><span class="comment">     服务员收听到顾客的召唤（执行订餐委托）所执行的方法*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Waiter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params">Customer customer, OrderEventArgs e</span>)<span class="comment">//收听订餐委托的方法，接受顾客身份和一道菜的订单</span></span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Waiter：I will serve you the dish -&#123;0&#125;&quot;</span>, e.DishName);<span class="comment">//为顾客报菜名</span></span><br><span class="line">            <span class="built_in">double</span> price = <span class="number">10</span>;<span class="comment">//设置基准价格</span></span><br><span class="line">            <span class="keyword">switch</span> (e.Size)<span class="comment">//大份菜是基准价格的1.5倍，小份菜是基准价格的0.5倍</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;large&quot;</span>:</span><br><span class="line">                    price *= <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;small&quot;</span>:</span><br><span class="line">                    price *= <span class="number">0.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            customer.Bill += price;<span class="comment">//为顾客的账单添加一道菜的款项</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 事件的拥有者：Customer</span></span><br><span class="line"><span class="comment">     * 事件成员：Order</span></span><br><span class="line"><span class="comment">     * 事件的响应者：Waiter</span></span><br><span class="line"><span class="comment">     * 事件处理器：wait.Action(Customer customer, OrderEventArgs e)</span></span><br><span class="line"><span class="comment">     * 事件订阅：customer.Order += waiter.Action;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果： <a href="http://upane.cn/archives/946/event_2018-11-19_23-02-56"><img src="http://47.94.231.166/wp-content/uploads/2018/11/@event_2018-11-19_23-02-56.png" alt=""></a></p>
<h3 id="归纳总结："><a href="#归纳总结：" class="headerlink" title="归纳总结："></a>归纳总结：</h3><ul>
<li>事件<code>event</code>与委托类型字段的区别：语义化，防止滥用</li>
<li>事件的本质：<ol>
<li>是委托字段的一个包装器</li>
<li>该包装器对委托字段的访问起限制作用，相当于一个蒙版</li>
<li>封装的一个重要的功能就是隐藏</li>
<li>事件对外界隐藏了委托实例的大部分功能，仅暴露添加/移除事件访问器的功能</li>
</ol>
</li>
<li><p><code>EventHandle</code>委托：.Net定义好的常用事件：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender,EventArgs e</span>)</span></span><br><span class="line"><span class="function"><span class="comment">//              ↑无返回值            ↑两个最基本的类型↑</span></span></span><br></pre></td></tr></table></figure>
<p>使用时需进行类型转换：</p>
<blockquote>
<p>例：xxxEventArgs args=e as xxxEventArgs //e原为EventArgs类型</p>
</blockquote>
</li>
<li><p>用于声明事件的委托类型的命名约定：</p>
<ul>
<li>用于声明Foo事件的委托，一般命名为FooEventHandler</li>
<li>FooEventHandler委托的参数一般有两个（由win32演化而来）</li>
<li>第一个是<code>object</code>类型，名字为sender，实际上是<strong>事件的拥有者</strong>，事件的source</li>
<li>第二个是<code>EventArgs</code>类的派生类，类名一般为FooEventArgs，参数为e，也就是<strong>事件参数</strong></li>
<li>虽无官方说法，但我们可以把委托的参数列表看作是事件发生以后发送给事件响应者的“事件消息”</li>
<li>触发Foo事件的方法一般命名为OnFoo即“因何而发”、<strong>“事出有因”</strong></li>
<li>访问级别为<code>protected</code>,不应为<code>public</code></li>
</ul>
</li>
<li>事件的命名约定：<ul>
<li>带有时态动词或动词短语</li>
<li>事件拥有者“正在做”什么事，用<strong>进行时</strong>，事件拥有者“做完了”什么事，用<strong>完成时</strong>。</li>
</ul>
</li>
</ul>
<h2 id="④后记："><a href="#④后记：" class="headerlink" title="④后记："></a>④后记：</h2><p><a href="http://upane.cn/archives/962/chrome_2018-11-26_17-54-44"><img src="http://47.94.231.166/wp-content/uploads/2018/11/chrome_2018-11-26_17-54-44-1024x550.png" alt=""></a></p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】值类型转换关键字“ref”&amp;\&quot;out\&quot;</title>
    <url>/2018/08/14/%E3%80%90c%E3%80%91%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%85%B3%E9%94%AE%E5%AD%97ref/</url>
    <content><![CDATA[<p>由于值类型实参传入方法后无法被保存，所以可以用关键字“ref”将其临时“转换”为引用类型。<br><a id="more"></a><br>例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> age=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Growth</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> _age</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _age++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Growth(<span class="keyword">ref</span> age);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(age);```</span><br><span class="line"></span><br><span class="line">输出结果为<span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;需要注意的是，定义形参、传入实参时都要使用关键字“<span class="keyword">ref</span>”，且不可传入对象的字段，只能传入定义的变量。&lt;/strong&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">如果我们想输出一个传入值类型方法的结果，可以使用<span class="keyword">return</span>来传出。但是如果要传出多个值，就可以使用关键字“<span class="keyword">out</span>”了</span><br><span class="line">例：</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="built_in">int</span> age=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Growth</span>(<span class="params"><span class="built_in">int</span> _age,<span class="keyword">out</span> <span class="built_in">int</span> lastYear,<span class="keyword">out</span> <span class="built_in">int</span> nextYear</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lastYear=_age--;</span><br><span class="line">    nextYear=_age++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> ly,ny;<span class="comment">//设置变量来接收Growth输出的lastYear和nextYear</span></span><br><span class="line">Growth(age,<span class="keyword">out</span> ly,<span class="keyword">out</span> ny);</span><br><span class="line">Console.WriteLine(ly+<span class="string">&quot;,&quot;</span>+ny);</span><br></pre></td></tr></table></figure>
<p>输出结果为2,4。 <strong>对比关键字“ref”可知，使用关键字“out”时也需要定义形参、传入实参时都使用，且传出的值需要定义变量接收。</strong></p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】再谈委托</title>
    <url>/2018/11/09/%E3%80%90c%E3%80%91%E5%86%8D%E8%B0%88%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<p><a href="http://47.94.231.166/wp-content/uploads/2018/11/Delegate.html">>无扰阅读模式（测试）</a> 先报一下现况吧：目前正在做WPF版的Walkman Playlist Tools，增加和完善了很多功能，小小地图透一下： <a href="http://upane.cn/archives/874/devenv_2018-11-09_22-26-03"><img src="http://47.94.231.166/wp-content/uploads/2018/11/devenv_2018-11-09_22-26-03-1024x555.png" alt=""></a> 具体改了什么功能，先卖个关子。 这么长时间没更真的没有在摸鱼哦！真的没有！  <a href="http://upane.cn/archives/220/attachment/55"><img src="http://47.94.231.166/wp-content/uploads/2018/04/55.png" alt=""></a> 那么，我们步入正题吧：<br><a id="more"></a></p>
<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>[delegate]</p>
<hr>
<h6 id="委托？"><a href="#委托？" class="headerlink" title="委托？"></a>委托？</h6><blockquote>
<p>简单地说，委托的实质是函数的指针。</p>
</blockquote>
<h6 id="实现委托？"><a href="#实现委托？" class="headerlink" title="实现委托？"></a>实现委托？</h6><blockquote>
<p>和其他类型一样，委托在实现之前也要先定义类，这个类称为委托，而委托函数的是委托的成员（可以看作委托类的对象）。</p>
</blockquote>
<h2 id="①Action委托"><a href="#①Action委托" class="headerlink" title="①Action委托"></a>①Action委托</h2><p>前面说过，委托在实现之前必先定义类，这个类可以自己定义（之后会讲），也可以直接使用系统定义好的委托类，这里讲的<code>Action</code>和下面的<code>Func</code>就是这样的类。 <code>Action</code>委托是可添加<strong>无传入值，且无返回值（<code>void</code>）方法</strong>的委托类。</p>
<h4 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Action anyname =<span class="keyword">new</span> Action( FunctionHere );</span><br></pre></td></tr></table></figure>
<h4 id="调用（以下三条代码效果相同）："><a href="#调用（以下三条代码效果相同）：" class="headerlink" title="调用（以下三条代码效果相同）："></a>调用（以下三条代码效果相同）：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">anyname.Invoke();<span class="comment">//调用委托（完全版）</span></span><br><span class="line">anyname();<span class="comment">//调用委托（简写版）</span></span><br><span class="line">FunctionHere();<span class="comment">//原函数</span></span><br></pre></td></tr></table></figure>
<h2 id="②Func委托"><a href="#②Func委托" class="headerlink" title="②Func委托"></a>②Func委托</h2><p>Func委托是通过泛型容纳任何一种函数的委托类。</p>
<h4 id="创建：-1"><a href="#创建：-1" class="headerlink" title="创建："></a>创建：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;Type1,Type2,...ReturnType&gt; anyname=<span class="keyword">new</span> Func&lt;Type1,Type2,...ReturnType&gt;( FunctionHere )</span><br></pre></td></tr></table></figure>
<p>如上，泛型中可填入任意数量的数据类型，其中最后一个输入的数据类型用作规定函数的返回类型，其他（除了最后一个）数据类型可以规定函数的传入类型。需要注意的是，若只填入一个类型，那么这个类型是函数的返回类型。</p>
<h4 id="调用："><a href="#调用：" class="headerlink" title="调用："></a>调用：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">anyname.Invoke();<span class="comment">//调用委托（完全版）</span></span><br><span class="line">anyname();<span class="comment">//调用委托（简写版）</span></span><br><span class="line">FunctionHere();<span class="comment">//原函数</span></span><br></pre></td></tr></table></figure>
<h2 id="③委托的声明（自定义委托）"><a href="#③委托的声明（自定义委托）" class="headerlink" title="③委托的声明（自定义委托）"></a>③委托的声明（自定义委托）</h2><p>委托的声明方式与一般类不同，主要是为了照顾可读性和C、C++传统。 注意声明委托的位置，避免写错地方结果声明成嵌套类型。 委托所封装的方法必须类型兼容。</p>
<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">Calc</span>(<span class="params">doule x,<span class="built_in">double</span> y</span>)</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">   Calc calc1=<span class="keyword">new</span> Calc( FunctionHere );</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用：-1"><a href="#调用：-1" class="headerlink" title="调用："></a>调用：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">calc1.Invoke((<span class="built_in">double</span>)<span class="keyword">var</span>,(<span class="built_in">double</span>)<span class="keyword">var</span>);<span class="comment">//调用委托（完全版）</span></span><br><span class="line">calc2((<span class="built_in">double</span>)<span class="keyword">var</span>,(<span class="built_in">double</span>)<span class="keyword">var</span>);<span class="comment">//调用委托（简写版）</span></span><br><span class="line">FunctionHere((<span class="built_in">double</span>)<span class="keyword">var</span>,(<span class="built_in">double</span>)<span class="keyword">var</span>);<span class="comment">//原函数</span></span><br></pre></td></tr></table></figure>
<h2 id="④委托的使用"><a href="#④委托的使用" class="headerlink" title="④委托的使用"></a>④委托的使用</h2><blockquote>
<p>——当作数据传入函数</p>
</blockquote>
<ul>
<li>用作模板（常位于代码中部，有返回值）</li>
<li>回调方法（常位于代码尾部，无返回值，多用于执行后续操作）</li>
</ul>
<p>注意：难精通、易使用、功能性强的功能一旦滥用后果非常严重 1. 这是一种方法级别的紧耦合，现实工作中使用应慎之又慎 1. 可使得程序可读性下降，doubug难度增加 1. 把委托回调、异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护 1. 使用不当可能造成内存泄漏和程序性能下降</p>
<h2 id="⑤多播委托"><a href="#⑤多播委托" class="headerlink" title="⑤多播委托"></a>⑤多播委托</h2><p>刚刚演示的委托均为单播委托，即一个委托只有一个方法相应。由此推广，多播委托即为一个委托可有多个方法相应。</p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p>使用<code>+=</code>可在委托的成员中再添加一个方法。</p>
<h4 id="演示："><a href="#演示：" class="headerlink" title="演示："></a>演示：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Action action1=<span class="keyword">new</span> Action(Function1);</span><br><span class="line">Action action2=<span class="keyword">new</span> Action(Function2);</span><br><span class="line">Action action3=<span class="keyword">new</span> Action(Function3);</span><br><span class="line">action1+=action2;</span><br><span class="line">action1+=action3;</span><br><span class="line">action1.Invoke();</span><br><span class="line"><span class="comment">/*效果与分别调用相同：</span></span><br><span class="line"><span class="comment">action1.Invoke();</span></span><br><span class="line"><span class="comment">action2.Invoke();</span></span><br><span class="line"><span class="comment">action3.Invoke();*/</span></span><br></pre></td></tr></table></figure>
<h2 id="⑥异步调用"><a href="#⑥异步调用" class="headerlink" title="⑥异步调用"></a>⑥异步调用</h2><p>先明确几个称呼： 一个程序只有一个<strong>进程</strong>，但是可以有很多个<strong>线程</strong>。</p>
<blockquote>
<p>同步=串行=单线程； 异步=并行=多线程；</p>
</blockquote>
<ul>
<li>直接同步调用：使用方法名</li>
<li>间接同步调用：使用单播/多播委托的<code>Invoke</code>方法</li>
<li>隐式异步调用：使用委托的<code>BeginInvoke</code>方法，如 <code>csharp anyname.BeginInvoke(delegate,object) //第一个传入值为委托类型，标明该线程做完后做什么，什么都不做就填null //第二个传入值默认传入null</code> 需要注意的是，这是相比主线程而分离的分支线程，也就是说使用n次<code>BeginInvoke</code>就调用了 <strong>n+1</strong>个线程</li>
<li>显式异步调用： 1.Thread类：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Using System.Threading;</span><br><span class="line">Thread thread1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(Function1));</span><br><span class="line">Thread thread2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(Function2));</span><br><span class="line">Thread thread3=<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(Function3));</span><br><span class="line"><span class="comment">//创建了三个线程，共四个线程。</span></span><br><span class="line">thread1.Start();</span><br><span class="line">thread2.Start();</span><br><span class="line">thread3.Start();</span><br><span class="line"><span class="comment">//分别启动线程</span></span><br></pre></td></tr></table></figure>
<p>2.Task类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Using System.Threading.Task;</span><br><span class="line">Task task1=<span class="keyword">new</span> Task(<span class="keyword">new</span> Action(Function1));</span><br><span class="line">Task task2=<span class="keyword">new</span> Task(<span class="keyword">new</span> Action(Function2));</span><br><span class="line">Task task3=<span class="keyword">new</span> Task(<span class="keyword">new</span> Action(Function3));</span><br><span class="line"><span class="comment">//注意这里给Task的构造方法传入值的其实是个委托</span></span><br><span class="line">thread1.Start(); </span><br><span class="line">thread2.Start(); </span><br><span class="line">thread3.Start(); </span><br><span class="line"><span class="comment">//分别启动线程</span></span><br></pre></td></tr></table></figure>
<h2 id="⑦用接口代替委托"><a href="#⑦用接口代替委托" class="headerlink" title="⑦用接口代替委托"></a>⑦用接口代替委托</h2><p>Java的做法，降低耦合度，提高可读性</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】初探Lambda表达式与LinQ</title>
    <url>/2018/12/22/%E3%80%90c%E3%80%91%E5%88%9D%E6%8E%A2lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8Elinq/</url>
    <content><![CDATA[<p><a href="http://upane.cn/wp-content/uploads/2018/12/LinQ.html">>无扰阅读模式</a><br><a id="more"></a></p>
<h2 id="①什么是LinQ？"><a href="#①什么是LinQ？" class="headerlink" title="①什么是LinQ？"></a>①什么是LinQ？</h2><blockquote>
<p>linq是一类查询数据的方法，它常用于对数据库进行检索，但是不限于数据库（可应用于任何集合类型）。利用Linq，我们可以使用简单的语句完成对数据的搜索、归类、求集等等操作。</p>
</blockquote>
<h2 id="②预备知识：Lambda表达式"><a href="#②预备知识：Lambda表达式" class="headerlink" title="②预备知识：Lambda表达式"></a>②预备知识：Lambda表达式</h2><h3 id="㈠Lambda表达式的作用："><a href="#㈠Lambda表达式的作用：" class="headerlink" title="㈠Lambda表达式的作用："></a>㈠Lambda表达式的作用：</h3><ol>
<li>匿名方法（没有类的野方法）</li>
<li>Inline方法（随写随用，用后立刻销毁）</li>
</ol>
<h3 id="㈡使用方法："><a href="#㈡使用方法：" class="headerlink" title="㈡使用方法："></a>㈡使用方法：</h3><ol>
<li><strong>Lambda表达式应用于委托中，使用时调用委托即可</strong></li>
<li>使用形式为 <strong>（形参）=&gt; {函数体}</strong></li>
</ol>
<p>例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用系统定义好的泛型委托Func，第一、二个泛型是传入值，第三个泛型是返回值</span></span><br><span class="line">    Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt; func=<span class="keyword">new</span> Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt;((<span class="built_in">int</span> a,<span class="built_in">int</span> b)=&gt;&#123;<span class="keyword">return</span> a+b&#125;);<span class="comment">//创建包含Lambda表达式的委托成员</span></span><br><span class="line">    Console.WriteLine(func(<span class="number">100</span>,<span class="number">300</span>));<span class="comment">//调用委托显示结果。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="㈢语法糖"><a href="#㈢语法糖" class="headerlink" title="㈢语法糖"></a>㈢语法糖</h3><p>原句</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt; func=<span class="keyword">new</span> Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt;((<span class="built_in">int</span> a,<span class="built_in">int</span> b)=&gt;&#123;<span class="keyword">return</span> a+b&#125;);</span><br></pre></td></tr></table></figure>
<p>因为传入值已在委托中规定，<strong>故可以不声明形式变量类型而直接调用</strong>，同时规定了函数肯定有返回值，<strong>所以省略return</strong> ↓</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt; func=<span class="keyword">new</span> Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt;((a,b)=&gt;&#123;a+b&#125;);</span><br></pre></td></tr></table></figure>
<p>因为建立Lambda表达式的过程肯定是新建了一个委托成员，<strong>故可以省去new及调用“构造方法”的语句</strong> ↓</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt; func=(a,b)=&gt;&#123;a+b&#125;;</span><br></pre></td></tr></table></figure>
<p>如果Lambda表达式的内容就一句，完全连大括号也没必要写，最后就成了</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt; func=(a,b)=&gt;a+b;</span><br></pre></td></tr></table></figure>
<h2 id="③使用LinQ进行数据处理"><a href="#③使用LinQ进行数据处理" class="headerlink" title="③使用LinQ进行数据处理"></a>③使用LinQ进行数据处理</h2><blockquote>
<p>LinQ本是模仿SQL的语法，但是那种语法在C#程序中就显得格格不入，为此微软又开发了形似C#方法的LinQ语法，为方便理解，以下所讲的语法都是这种语法。</p>
</blockquote>
<p>LinQ类似C#方法的语法大多就是利用以上所讲的Lambda表达式语法形式进行书写的，例如，我们有学生的数据集合<code>StudentData</code>，集合中有很多条学生信息，每条学生信息又包含学生的姓名(Name)、年级(Grade)、班级(Class)等等数据。</p>
<h3 id="㈠现在我们想得到所有的学生姓名，可以这样写："><a href="#㈠现在我们想得到所有的学生姓名，可以这样写：" class="headerlink" title="㈠现在我们想得到所有的学生姓名，可以这样写："></a>㈠现在我们想得到所有的学生姓名，可以这样写：</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nameList=studentData.Select(p=&gt;p.Name).ToList();</span><br><span class="line"><span class="comment">//studentData是StudentData类的一个对象</span></span><br></pre></td></tr></table></figure>
<p>这句话的意思就是 <strong>“选择studentData每条数据中的Name，并且将其返回为一个列表”</strong>。 值得注意的是，当我们输入<code>Select()</code>后，编译器会自动给出提示： <a href="http://upane.cn/wp-content/uploads/2018/12/2018-12-22_12-02-09.png"><img src="http://upane.cn/wp-content/uploads/2018/12/2018-12-22_12-02-09.png" alt=""></a> 注意Func后面的泛型，<strong>这就是提示我们这个Select函数仅接受输入值为StudentData类型，返回TResult类型的委托成员</strong>，这也间接限制了我们的Lambda表达式书写格式。</p>
<h3 id="㈡同理，如果我们想要搜索所有名字为“张三”的学生，可以这样写："><a href="#㈡同理，如果我们想要搜索所有名字为“张三”的学生，可以这样写：" class="headerlink" title="㈡同理，如果我们想要搜索所有名字为“张三”的学生，可以这样写："></a>㈡同理，如果我们想要搜索所有名字为“张三”的学生，可以这样写：</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student=studentData.Where(p=&gt;p.Name==<span class="string">&quot;张三&quot;</span>).ToList();</span><br></pre></td></tr></table></figure>
<p>这次当我们输入<code>Where()</code>后，编译器自动给出提示为： <a href="http://upane.cn/wp-content/uploads/2018/12/2018-12-22_12-10-39.png"><img src="http://upane.cn/wp-content/uploads/2018/12/2018-12-22_12-10-39.png" alt=""></a> 可以看到这个<code>Where()</code>函数仅接受 <strong>输入值为StudentData类型，返回值为bool类型的委托成员</strong>。 这样我们就得到了所有名字叫”张三”的学生名单。（别忘了句尾的.ToList()） 关于更多LinQ函数，可以去<a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable?view=netframework-4.7.2" title="微软官网">微软官网</a>查询：<a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable?view=netframework-4.7.2">https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable?view=netframework-4.7.2</a></p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】”声明“与”实例化“的区别</title>
    <url>/2018/08/09/%E3%80%90c%E3%80%91%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>实例化必先声明，声明是实例化的第一步<br><a id="more"></a><br>例如，创建一个数组可写为 <strong>数组类型[ ]  数组名=new  数组类型[长度]   int [ ] array =new int [5];</strong> 但这其实是一个组合式，可拆分为： ①<strong>声明：</strong>数组类型 [] 数组名                         int [ ] array; ②<strong>实例化：</strong>数组名 = new 数组类型[长度]    array = new int [5];</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】区别对象关键字“this”</title>
    <url>/2018/08/12/%E3%80%90c%E3%80%91%E5%8C%BA%E5%88%AB%E5%AF%B9%E8%B1%A1%E5%85%B3%E9%94%AE%E5%AD%97this/</url>
    <content><![CDATA[<p>如果有一个类中存在字段a，又存在方法b，而方法b又有形参a，在将字段a与形参a互相赋值的过程中常会引起混淆，为了区别之引入关键字“this”。用“this.a”可以表示类中的字段a。同样的，this还可以用于方法、属性。<br><a id="more"></a><br>使用this关键字，可以对相同名字的字段与方法中的形参进行区分，也可以减少由类名较长带来的麻烦，在后期检查时也更简单明了，建议在同类中的调用尽量使用this。</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】委托和事件</title>
    <url>/2018/09/30/%E3%80%90c%E3%80%91%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="①委托"><a href="#①委托" class="headerlink" title="①委托"></a>①委托</h1><p>1.委托像是一种特殊的类，这种类<strong>只能存储方法</strong>，不存储字段属性，而且它是<strong>存储别的对象的方法</strong>。（储存没有类的“野方法”用lambda表达式） 2.委托这种类还可以被直接执行，它执行起来就像一个方法，只不过实际上它是在执行别的对象的方法。</p>
<h2 id="委托的声明"><a href="#委托的声明" class="headerlink" title="委托的声明"></a>委托的声明</h2><p>委托使用关键字<strong>delegate</strong>声明，声明时，还要包括委托包含的方法的<strong>返回类型</strong>和<strong>传入值</strong>，若声明一个委托为Act，且其无返回值（void），无传入值，如下：</p>
<p><strong>delegate</strong> void <strong>Act()</strong>;</p>
<h2 id="委托的定义"><a href="#委托的定义" class="headerlink" title="委托的定义"></a>委托的定义</h2><p>声明委托后即可对其进行定义，刚刚声明了委托类，下面还要具体定义该类下的“委托对象”，即“成员”。如下：</p>
<p>Pet pet=new Pet(); <strong>Act</strong> act=Pet.Speaking;//声明成员后添加第一个方法<br>act+=Pet.Feed;//为成员添加第二个方法</p>
<p>注意这里传入pet对象的Speaking方法时<strong>并没有带方法后常加的括号</strong>，这是因为我们在声明委托时就定义了此中包含的方法不能有传入参数。 注意同一个委托对象可以同时包含静态与非静态方法，只不过包括静态方法是”类.方法“而非静态方法是”对象.方法“。 使用<strong>“+=”</strong>添加超过一个方法，使用<strong>“-=”</strong>删去一个方法。 这样以来，成员act就可以传入多个不同对象的方法，委托也可以多次声明出不同的成员。</p>
<h2 id="调用委托"><a href="#调用委托" class="headerlink" title="调用委托"></a>调用委托</h2><p>调用委托时，直接写出要调用的成员名加传入参数即可，如上面的例子，调用act即为</p>
<p>act();</p>
<p>形式与调用了一个方法很相似。</p>
<h1 id="②Lambda表达式"><a href="#②Lambda表达式" class="headerlink" title="②Lambda表达式"></a>②Lambda表达式</h1><p>Lambda表达式由匿名方法进化而来，它允许用户往委托中存储“没有类的野方法” 语法： 以①中的act“委托对象”为例，我们使用lambda表达式为它添加一个“没有类的野方法”：</p>
<p>act=()\=&gt;{…}</p>
<p>这样，在运行act“委托对象”时，{…}中的内容也会被运行。</p>
<h1 id="③事件"><a href="#③事件" class="headerlink" title="③事件"></a>③事件</h1><p>事件的通知需要有事件的“发布者”与事件的“订阅者”。 事件发生时，通知订阅者，就是调用订阅者的<strong>“注册函数”</strong>。注册，就是告诉发布者<strong>调用哪个注册函数</strong>。</p>
<h2 id="事件的声明"><a href="#事件的声明" class="headerlink" title="事件的声明"></a>事件的声明</h2><p>事件实际上就是对一个委托进行了声明（委托→成员），既然如此必须先有被声明的委托，然后使用关键字<strong>event</strong>对其进行声明。如下例，就将Handler委托声明成了NewDog事件。</p>
<p>delegate void Handler();<br>public <strong>event</strong> Handler NewDog;</p>
<p>需要注意的是使用事件声明委托后其会被隐式自动初始化为null，所以之后的添加方法需要使用<strong>“+=”</strong>。 方法可以是实例方法、静态方法、Lambda表达式。</p>
<h2 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h2><p>需要触发事件（广播事件）时，就可以使用</p>
<p>if(NewDog!=null)//如果NewDog事件不为空（无方法接收）<br>{<br>  NewDog();（广播事件/调用NewDog包括的方法）<br>}</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】对象初始化器</title>
    <url>/2018/08/12/%E3%80%90c%E3%80%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<p>目前为止，我们知道两种在调用对象时初始化的方法，即<br><a id="more"></a></p>
<h4 id="①分步："><a href="#①分步：" class="headerlink" title="①分步："></a>①分步：</h4><blockquote>
<p>[cc lang=”csharp”]Child child1=new Child（） child1.Name=”小明”; child1.Age=12[/cc]</p>
</blockquote>
<h4 id="②利用构造方法："><a href="#②利用构造方法：" class="headerlink" title="②利用构造方法："></a>②利用构造方法：</h4><blockquote>
<p>[cc lang=”csharp”]class Child { 。。。。。。。 public Child(string name,int age){ Name=name; Age=age; }} class Program { static void main(string args[]){ Child child1=new Child(“小明”,”12”); 。。。。。。。 }}[/cc]</p>
</blockquote>
<h4 id="可以看出，分步法虽然在类Child中书写简易，但在类Program中书写繁琐，利用构造方法相反。现在，介绍第三种方法，即利用对象初始化器的方法，则可以在两者之前找到平衡点。"><a href="#可以看出，分步法虽然在类Child中书写简易，但在类Program中书写繁琐，利用构造方法相反。现在，介绍第三种方法，即利用对象初始化器的方法，则可以在两者之前找到平衡点。" class="headerlink" title="可以看出，分步法虽然在类Child中书写简易，但在类Program中书写繁琐，利用构造方法相反。现在，介绍第三种方法，即利用对象初始化器的方法，则可以在两者之前找到平衡点。"></a>可以看出，分步法虽然在类Child中书写简易，但在类Program中书写繁琐，利用构造方法相反。现在，介绍第三种方法，即利用对象初始化器的方法，则可以在两者之前找到平衡点。</h4><p><strong>_Child child1=new Child（）{Name=“小明”，Age=“12”}；_</strong> 其中圆括号也可省略，进而简写为 <strong>_Child child1=new Child{Name=“小明”，Age=“12”}；_</strong> <strong>注意：使用对象初始化器只能是构造方法无参数时才能使用</strong></p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】定义多泛型、泛型约束与接口并用</title>
    <url>/2020/05/04/%E3%80%90c%E3%80%91%E5%AE%9A%E4%B9%89%E5%A4%9A%E6%B3%9B%E5%9E%8B%E3%80%81%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%B9%B6%E7%94%A8/</url>
    <content><![CDATA[<p>说起来挺智障的，今天有个需求就是实现多个泛型，但是忘了怎么写了，搜了一圈竟然没搜着，偶然看见有人提起Dictionary，心想那不就是多泛型吗，赶紧试了试发现能用，如下：<br><a id="more"></a><br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型TA中需要实现的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAFunc</span></span><br><span class="line">&#123;</span><br><span class="line">    A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型TB中需要实现的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBFunc</span></span><br><span class="line">&#123;</span><br><span class="line">    B()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Tag类中给两泛型TA、TB同时添加约束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tag</span>&lt;<span class="title">TA</span>,<span class="title">TB</span>&gt; </span><br><span class="line">    <span class="keyword">where</span> <span class="title">TA</span>:<span class="title">IAFunc</span></span><br><span class="line">    <span class="keyword">where</span> <span class="title">TB</span>:<span class="title">IBFunc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//做点什么...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，又发现一个更智障的问题：我想在这个Tag类中实现一个接口，但是惊讶地发现不知道该在哪写了！又是一顿搜索，仍然没找到答案，硬试，试出来了：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型TA中需要实现的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAFunc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">A</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//泛型TB中需要实现的接口</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">interface</span> IBFunc</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">B</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">interface</span> ITag</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">C</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//在Tag类中给两泛型TA、TB同时添加约束</span></span></span><br><span class="line"><span class="function"><span class="comment">//在泛型尖括号后与where前用冒号实现接口的引用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> Tag&lt;TA,TB&gt; :ITag</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TA:IAFunc</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TB:IBFunc</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//做点什么...</span></span><br><span class="line">    <span class="comment">//别忘了实现C()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前还批评java的extends与implement写着麻烦，看来遇到这种高级用法的时候还是Java更直观一些。C#虽然冒号走遍天下，事一多反而不知道冒号该加哪了。</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>多泛型</tag>
        <tag>接口</tag>
        <tag>泛型</tag>
        <tag>泛型约束</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】“小时钟”知识点总结</title>
    <url>/2018/08/18/%E3%80%90c%E3%80%91%E5%B0%8F%E6%97%B6%E9%92%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一个小时钟看似功能简单，但却使用了多窗口、侧边栏停靠、timer触发等等重要的图形化应用知识。下面将对每一个知识进行单独总结，方便日后学习。<br><a id="more"></a></p>
<h1 id="窗口类"><a href="#窗口类" class="headerlink" title="窗口类"></a>窗口类</h1><h2 id="①创建和控制多窗口"><a href="#①创建和控制多窗口" class="headerlink" title="①创建和控制多窗口"></a><strong>①创建和控制多窗口</strong></h2><p>创建多窗口：在项目名上右键，添加，windows窗口。<img src="http://47.94.231.166/wp-content/uploads/2018/08/devenv_2018-08-18_09-31-55.png" alt=""> 控制多窗体： 首先，用新创建的窗体类（窗体名即类名）实例化一个窗体对象 在某个控件被触发时，使用方法<strong>Show.对象名()</strong>弹出目标窗口（ShowDialog.对象名()可以在弹出新窗体后禁用原窗体（无法操作化）） 如，想让窗体Form1在一开始便弹出窗体clock1，可用以下语句</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    clock clock1 = <span class="keyword">new</span> clock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        clock1.Show ();<span class="comment">//窗口Form1一载入即载入窗口clock1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="②更改窗口参量"><a href="#②更改窗口参量" class="headerlink" title="②更改窗口参量"></a><strong>②更改窗口参量</strong></h2><p>Ⅰ.更改窗口参量时，对于多窗口使用窗口<strong>方法名.参量</strong>，没有就先实例化，对于本窗口自身<strong>直接用This.参量</strong>。 Ⅱ.有的参量是变量，比如布尔型的True、False可以直接赋值，但是如果提示不是变量就需要用new实例化进行“赋值”。 Ⅲ.如果参量不是静态的，比如时间，要将此传输进This.Text，但是This.Text只支持静态参量，就可以利用Timer控件，在控件中创建一个静态变量，并且此静态变量每秒刷新一次，将此静态变量赋给This.Text即可。</p>
<h4 id="“抹除”窗口背景："><a href="#“抹除”窗口背景：" class="headerlink" title="“抹除”窗口背景："></a>“抹除”窗口背景：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.BackColor = System.Drawing.Color.Black;<span class="comment">//随便传送一个颜色</span></span><br><span class="line"><span class="keyword">this</span>.TransparencyKey = System.Drawing.Color.Black;<span class="comment">//将传送的颜色设置为透明，该方法设置的透明可以透过窗体使鼠标点击下方控件</span></span><br></pre></td></tr></table></figure>
<p>使用该方法“抹除”背景后，鼠标可直接操作原背景框下面的程序，除非有自身控件挡住，但该方法无法更改透明度，完全透明的背景会使字体边框有残痕，很不美观。</p>
<h4 id="取消挂载任务栏："><a href="#取消挂载任务栏：" class="headerlink" title="取消挂载任务栏："></a>取消挂载任务栏：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.ShowInTaskbar = <span class="literal">false</span>;<span class="comment">//不在任务栏显示```</span></span><br><span class="line">&lt;h4&gt;窗口置顶：&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="keyword">this</span>.TopMost = <span class="literal">true</span>;<span class="comment">//窗口置顶```</span></span><br><span class="line">&lt;h4&gt;更改窗体透明度：&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="keyword">this</span>.Opacity = <span class="number">0.5</span>D;<span class="comment">//传入double型变量```</span></span><br><span class="line"></span><br><span class="line">注意该方法更改窗体透明度后窗体内的空间透明度也会随之改变。</span><br><span class="line">&lt;h4&gt;更改窗口位置：&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="keyword">this</span>.Location = <span class="keyword">new</span> Point(X,Y);<span class="comment">//不是变量、无法更改的窗口参量可以用new设置```</span></span><br><span class="line"></span><br><span class="line">(X,Y)是一个点，单独更改某一个参量也可以用<span class="keyword">this</span>.Location.Height和<span class="keyword">this</span>.Location.Weight。</span><br><span class="line">&lt;h4&gt;更改字体/大小：&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="keyword">this</span>.Font = <span class="keyword">new</span> System.Drawing.Font(<span class="string">&quot;宋体&quot;</span>, <span class="number">15</span>);```</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&lt;h4&gt;更改窗口状态：&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="keyword">this</span>.Visible = <span class="literal">false</span>; <span class="comment">//隐藏</span></span><br><span class="line"><span class="keyword">this</span>.WindowState = FormWindowState.Minimized; <span class="comment">//最小化</span></span><br><span class="line"><span class="keyword">this</span>.WindowState = FormWindowState.Maximized; <span class="comment">//最大化</span></span><br><span class="line"><span class="keyword">this</span>.WindowState = FormWindowState.Normal; <span class="comment">//正常</span></span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&lt;h1&gt;控件类&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;①实体控件&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&lt;h4&gt;label标签：&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">更改字体颜色：</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code <span class="keyword">class</span>=<span class="string">&quot;language-csharp line-numbers&quot;</span>&gt;<span class="keyword">this</span>.label1.ForeColor = Color.FromArgb(<span class="number">211</span>, <span class="number">210</span>, <span class="number">199</span>); <span class="comment">//柔和灰```</span></span><br><span class="line"></span><br><span class="line">&lt;strong&gt;trackbar轨迹条：&lt;/strong&gt;</span><br><span class="line"></span><br><span class="line">获取，更改当前值：trackbar1.Value</span><br><span class="line">&lt;h4&gt;&lt;strong&gt;combobox组合框：&lt;/strong&gt;&lt;/h4&gt;</span><br><span class="line">&lt;strong&gt;添加组合&lt;/strong&gt;：将鼠标移到组合框上单击，选择黑色箭头，选择编辑项&lt;img <span class="keyword">class</span>=<span class="string">&quot;alignnone size-full wp-image-433&quot;</span> src=<span class="string">&quot;http://47.94.231.166/wp-content/uploads/2018/08/devenv_2018-08-18_10-23-07.png&quot;</span> alt=<span class="string">&quot;&quot;</span> width=<span class="string">&quot;990&quot;</span> height=<span class="string">&quot;561&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;选择组合&lt;/strong&gt;：添加选项后，编译器将自动生成目录（index），编程时，既可以根据选项值选择，也可以根据目录选择。</span><br><span class="line"></span><br><span class="line">根据选项值选择：</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="keyword">switch</span> (comboBox1.SelectedItem.ToString())<span class="comment">//按选项值选择</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;深黑&quot;</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;纯白&quot;</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;柔和灰&quot;</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">211</span>, <span class="number">210</span>, <span class="number">199</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;荷兰白&quot;</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">226</span>, <span class="number">225</span>, <span class="number">185</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;日本靛蓝&quot;</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">42</span>, <span class="number">61</span>, <span class="number">69</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;深帝国蓝&quot;</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">5</span>, <span class="number">60</span>, <span class="number">94</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;简约蓝&quot;</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">31</span>, <span class="number">122</span>, <span class="number">140</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;赭石色&quot;</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">211</span>, <span class="number">139</span>, <span class="number">93</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">按目录选择：</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="keyword">switch</span> (comboBox1.SelectedIndex)<span class="comment">//按目录选择</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">211</span>, <span class="number">210</span>, <span class="number">199</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">226</span>, <span class="number">225</span>, <span class="number">185</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">42</span>, <span class="number">61</span>, <span class="number">69</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">5</span>, <span class="number">60</span>, <span class="number">94</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">31</span>, <span class="number">122</span>, <span class="number">140</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: clock1.label1.ForeColor = Color.FromArgb(<span class="number">211</span>, <span class="number">139</span>, <span class="number">93</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;```</span><br><span class="line">&lt;h2&gt;②虚拟控件&lt;/h2&gt;</span><br><span class="line">&lt;h4&gt;timer控件:&lt;/h4&gt;</span><br><span class="line">timer控件可以按时间触发事件，以毫秒为单位（<span class="number">1</span>s=<span class="number">1000</span>ms）</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;建立：&lt;/strong&gt;使用时，将工具箱里的timer控件拖入窗体即可，在下方就可以找到该控件，右击属性可以设置间隔时间。</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;触发：&lt;/strong&gt;在动作_Tick中可直接设置间隔时间到时出发的动作</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timer1_Tick</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)<span class="comment">//设置更新时间，自动更新时间，传送静态值到label1.Text，绕过了不能直接传送动态值的问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    label1.Text = DateTime.Now.Hour + <span class="string">&quot;:&quot;</span> + DateTime.Now.Minute + <span class="string">&quot;:&quot;</span> + DateTime.Now.Second;<span class="comment">//更新目前时间到label1.Text</span></span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;notifyIcon状态栏图标控件：&lt;/strong&gt;</span><br><span class="line"></span><br><span class="line">可以在状态栏创建应用图标，在单击时可出发动作。</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;建立：&lt;/strong&gt;与timer一样直接拖入即可，但是notifyIcon一定要在属性中设置图标，否则不会再状态栏显示。</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;触发：&lt;/strong&gt;可设置多种触发方式，如单击双击等，一般触发后代码为还原窗体大小+激活窗体</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyIcon1_MouseClick</span>(<span class="params"><span class="built_in">object</span> sender, MouseEventArgs e</span>)<span class="comment">//点击状态栏的触发效果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WindowState == FormWindowState.Minimized)<span class="comment">//最小化时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//还原窗体显示</span></span><br><span class="line">        WindowState = FormWindowState.Normal;</span><br><span class="line">        <span class="comment">//激活窗体并给予它焦点</span></span><br><span class="line">        <span class="keyword">this</span>.Activate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="①保存设置"><a href="#①保存设置" class="headerlink" title="①保存设置"></a>①保存设置</h2><p>对解决方案右键，添加，新建项，选择设置文件，对文件命名。 <img src="http://47.94.231.166/wp-content/uploads/2018/08/devenv_2018-08-19_12-26-35.png" alt=""> 调用设置：直接将“设置名.Default.变量名”赋给目标变量即可 存储设置：直接讲变量赋给“设置名.Default.变量名”，然后键入<strong>设置名.Default.Save();</strong>  </p>
<h2 id="②鼠标穿透"><a href="#②鼠标穿透" class="headerlink" title="②鼠标穿透"></a>②鼠标穿透</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> uint WS_EX_LAYERED = <span class="number">0x80000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> WS_EX_TRANSPARENT = <span class="number">0x20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> GWL_STYLE = (<span class="number">-16</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> GWL_EXSTYLE = (<span class="number">-20</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> LWA_ALPHA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;user32&quot;</span>, EntryPoint = <span class="meta-string">&quot;SetWindowLong&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> uint <span class="title">SetWindowLong</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">IntPtr hwnd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">int</span> nIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">uint dwNewLong</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;user32&quot;</span>, EntryPoint = <span class="meta-string">&quot;GetWindowLong&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> uint <span class="title">GetWindowLong</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">IntPtr hwnd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">int</span> nIndex</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;user32&quot;</span>, EntryPoint = <span class="meta-string">&quot;SetLayeredWindowAttributes&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">SetLayeredWindowAttributes</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">IntPtr hwnd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">int</span> crKey,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">int</span> bAlpha,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">int</span> dwFlags</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 设置窗体具有鼠标穿透效果</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetPenetrate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GetWindowLong(<span class="keyword">this</span>.Handle, GWL_EXSTYLE);</span><br><span class="line">SetWindowLong(<span class="keyword">this</span>.Handle, GWL_EXSTYLE, WS_EX_TRANSPARENT  WS_EX_LAYERED);</span><br><span class="line">SetLayeredWindowAttributes(<span class="keyword">this</span>.Handle, <span class="number">0</span>, <span class="number">100</span>, LWA_ALPHA);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上是鼠标穿透的代码，原代码来自网址：https://bbs.csdn.net/topics/390325341</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>从零开始的代码学习计划</category>
      </categories>
  </entry>
  <entry>
    <title>【C#】控件知识点总结（ListView、TabControl、RichTextBox）</title>
    <url>/2018/09/20/%E3%80%90c%E3%80%91%E6%8E%A7%E4%BB%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88listview%E3%80%81tabcontrol%E3%80%81textbox%EF%BC%89/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="①ListView："><a href="#①ListView：" class="headerlink" title="①ListView："></a>①ListView：</h1><p>ListView是一种数据归类的控件，可以将数据以不同形式呈现给用户，下面将以Detail视图为例介绍ListView的使用方法。 首先需要判断数据呈现方式是否方便以Detail呈现。标准的Detail视图是这样的： <img src="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-20_18-21-28-300x263.png" alt=""> 即一行有多个数据，或者说一个数据有多种属性，这样最适合使用Detail视图，但是对于这种： <img src="http://47.94.231.166/wp-content/uploads/2018/09/舍长神器_2018-09-20_18-23-30-171x300.png" alt=""> 即一行只有一个数据，或者数据不具有其他属性，就完全没必要使用，改为使用List视图。使用Detail视图未免有些小题大做，且影响美观。 使用Detail视图的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">listView.View = System.Windows.Forms.View.Details;</span><br></pre></td></tr></table></figure>
<p>确定使用Detail视图后，我们就可以准备在其中添加列名了。添加方法如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">listView.Columns.Add(<span class="string">&quot;姓名&quot;</span>, <span class="number">260</span>, HorizontalAlignment.Center);</span><br><span class="line"><span class="comment">//listView.Columns.Add(&quot;列名&quot;, 列视图长度, 文字呈现方式（居中等）);</span></span><br></pre></td></tr></table></figure>
<p>如此，可以连续定义多个列名，注意，使用列表前一定要先定义好列名，否则无法插入数据。 然后，又有以下常用可选项：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">listView.FullRowSelect = <span class="literal">true</span>;<span class="comment">//设置一选选一行，而不是选具体某一行的某一项</span></span><br><span class="line">listView.CheckBoxes = <span class="literal">true</span>;<span class="comment">//为每项添加一个勾选框</span></span><br><span class="line">listView.MultiSelect = <span class="literal">true</span>;<span class="comment">//可多选</span></span><br><span class="line">listView.GridLines = <span class="literal">true</span>;<span class="comment">//为每一行添加行线</span></span><br><span class="line">listView.AllowColumnReorder = <span class="literal">true</span>;<span class="comment">//设置用户是否可以拖动列名来更改默认的列位置</span></span><br></pre></td></tr></table></figure>
<p>至此，一个Detail视图的Listview就定义好了，我们定义它肯定是为了让它显示数据，那么如何给它添加数据呢？</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ListViewItem lv = <span class="keyword">new</span> ListViewItem();<span class="comment">//实例化一个ListViewItem，这就像当时列表的一行</span></span><br><span class="line">lv.Text = <span class="string">&quot;1&quot;</span>;<span class="comment">//为ListViewItem添加首项，就是第一列</span></span><br><span class="line">lv.SubItems.Add(<span class="string">&quot;2&quot;</span>);<span class="comment">//为ListViewItem添加第二项，就是第二列</span></span><br><span class="line"><span class="keyword">this</span>.listView1.Items.Add(lv);<span class="comment">//将lv这一项添加到列表Listview1中</span></span><br></pre></td></tr></table></figure>
<p>以此类推，我们可以在一行中依次添加数据直到达到定义列数，如此再添加任意行。注意，添加首项，也就是第一列，与第二项，也就是第二列的方式不同。   到这里写入数据也完成了，如果要输出数据呢？</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (ListViewItem item <span class="keyword">in</span> listView.Items)<span class="comment">//遍历行</span></span><br><span class="line">&#123;</span><br><span class="line">    Label1.Text+=item.SubItems[<span class="number">0</span>].Text + <span class="string">&quot;&quot;</span> + item.SubItems[<span class="number">1</span>].Text;</span><br><span class="line">&#125;<span class="comment">//读取列，这里一共两列，以“”分隔数据打印出来</span></span><br></pre></td></tr></table></figure>
<p>这里可以看出，item.Text=”1”（写）对应item.SubItems[0].Text（读） item.SubItems.Add(“2”)（写）对应item.SubItems[1].Text（读） 以此类推。 特殊项：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//↓删除框选的行</span></span><br><span class="line"><span class="keyword">foreach</span> (ListViewItem lvi <span class="keyword">in</span> listView.CheckedItems) <span class="comment">//选中项遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    listView.Items.RemoveAt(lvi.Index); <span class="comment">// 按索引移除</span></span><br><span class="line">    <span class="comment">//listView1.Items.Remove(lvi); //按项移除</span></span><br><span class="line">    <span class="comment">//↓清空列表</span></span><br><span class="line">    listView.Items.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="②TabControl"><a href="#②TabControl" class="headerlink" title="②TabControl"></a>②TabControl</h1><p>TabControl是一种可以存放其他控件的控件，准确地说并不是TabControl可以存放其他控件，而是TabControl所控制的TabPage这种控件可以容纳其他控件。如图<img src="http://47.94.231.166/wp-content/uploads/2018/09/WindowsFormsApp2_2018-09-20_20-59-08.png" alt=""> 这一整个是一个TabControl控件，而那里面包含的两个标签页称为两个TabPage控件。 首先，我们来看TabControl控件： 它的作用是控制里面的TabPage控件，我们可以添加一个TabPage控件：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">TabPage tpage = <span class="keyword">new</span> TabPage();<span class="comment">//创建一个新TabPage对象</span></span><br><span class="line">tpage.Text = <span class="string">&quot;New List &quot;</span> ;<span class="comment">//更改标签页对象名</span></span><br><span class="line">tpage.Name = <span class="string">&quot;New List &quot;</span> ;<span class="comment">//更改标签页对象现实的文字</span></span><br><span class="line">TabControl.TabPages.Add(tpage);<span class="comment">//向TabControl控件中添加这个标签页对象</span></span><br></pre></td></tr></table></figure>
<p>也可以删除一个TabPage控件：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">TabControl.TabPages.Remove(TabControl.TabPages[<span class="number">0</span>]);<span class="comment">//删除此TabControl控件中的第一个标签页</span></span><br></pre></td></tr></table></figure>
<p>查看目前选中的标签页：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">label1.Text=TabControl.SelectedIndex.ToString();</span><br></pre></td></tr></table></figure>
<p>这里可以看出，每添加一个TabPage，TabControl控件都会给它添加一个索引，并且索引从零开始。 再看里面的TabPage控件，它的主要用法是查看其中是否包含某种控件并引用之：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//↓如果目前所选标签页中包含ListView控件，那么允许其多选</span></span><br><span class="line"><span class="keyword">foreach</span> (Control control <span class="keyword">in</span> TabControl.SelectedTab.Controls)<span class="comment">//便利标签页中的所有控件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (control <span class="keyword">is</span> ListView)<span class="comment">//如果控件为ListView类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListView lv = (ListView)control;<span class="comment">//将其声明为lv</span></span><br><span class="line">        lv.MultiSelect = <span class="literal">true</span>;<span class="comment">//允许该控件多选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="③RichTextBox"><a href="#③RichTextBox" class="headerlink" title="③RichTextBox"></a>③RichTextBox</h1><p>该控件是可设置字体格式的文本框，但是由于微软的限制该控件无法透明化，此时需要新建一个类，并且写入以下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TransTextBox</span> : <span class="title">RichTextBox</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">&quot;kernel32.dll&quot;</span>, CharSet = CharSet.Auto)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">LoadLibrary</span>(<span class="params"><span class="built_in">string</span> lpFileName</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">override</span> CreateParams CreateParams</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            CreateParams prams = <span class="keyword">base</span>.CreateParams;</span><br><span class="line">            <span class="keyword">if</span> (LoadLibrary(<span class="string">&quot;msftedit.dll&quot;</span>) != IntPtr.Zero)</span><br><span class="line">            &#123;</span><br><span class="line">                prams.ExStyle = <span class="number">0x020</span>;</span><br><span class="line">                prams.ClassName = <span class="string">&quot;RICHEDIT50W&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> prams;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后找到：工具&gt;选项&gt;Windows窗体设计器&gt;常规&gt;自动填充工具箱&gt;True 这时就可以从工具箱中找到该控件了，空间名为类名，即TransTextBox。</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】数组基础</title>
    <url>/2018/08/08/%E3%80%90c%E3%80%91%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>正则表达式：</p>
<h4 id="数组类型-数组名-new-数组类型-长度"><a href="#数组类型-数组名-new-数组类型-长度" class="headerlink" title="数组类型[ ]  数组名=new  数组类型[长度]"></a>数组类型[ ]  数组名=new  数组类型[长度]</h4><a id="more"></a>
<p>①数组索引从<strong>零</strong>开始递增 ②<strong>数组经过初始化以后，数组元素有默认的初始值</strong>， <strong>double</strong> 类型为 0.0 ， <strong>int</strong> 类型为 0 ， <strong>char</strong> 类型为 ‘a’ ， <strong>bool</strong> 类型为 <strong>false</strong> ， <strong>string</strong> 类型为 <strong>null </strong> ③ <strong>数组名.Length</strong> 属性会返回数组的长度 ④实例化数组且赋值：int [ ] a=new int [ 3 ]<strong>{1,2,3}</strong>         <img src="http://img.mukewang.com/55a70bfa0001cad606270324.jpg" alt="">   二维数组：</p>
<h4 id="数组类型-，-数组名-new-数组类型-x长度，y长度"><a href="#数组类型-，-数组名-new-数组类型-x长度，y长度" class="headerlink" title="数组类型[ ，]  数组名=new  数组类型[x长度，y长度]"></a>数组类型[ <strong>，</strong>]  数组名=new  数组类型[x长度，y长度]</h4><p>  ①int[,] a = new int [3,3]<strong>{ { 1, 2, 3 }, { 4, 5, 6 },{ 7, 8, 9 } };</strong> ②返回数组中一维数组的个数：<strong>数组名.GetLongLength(0)</strong></p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】方法中的值类型和引用类型</title>
    <url>/2018/08/14/%E3%80%90c%E3%80%91%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>值类型：内存中存储的是值，如int、double等 引用类型：内存中存储的是内存地址，如string、int[]等<br><a id="more"></a><br>现有Child类，中存在年龄字段Age=4 传入引用类型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Growth</span>(<span class="params">Child child</span>)<span class="comment">//构造引用类型形参child</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    child.Age++;</span><br><span class="line">&#125;```</span><br><span class="line">传入值类型：</span><br><span class="line">```csharp</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Growth</span>(<span class="params"><span class="built_in">int</span> age</span>)<span class="comment">//构造值类型形参age</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    age++</span><br><span class="line">&#125;```</span><br><span class="line">现调用之</span><br><span class="line">```csharp</span><br><span class="line">Child xiaoMing=<span class="keyword">new</span> Child；</span><br><span class="line">Growth(xiaoMing.Age)；</span><br><span class="line">Console.WriteLine(xiaoMing.Age);</span><br><span class="line">Growth(xiaoMing)；</span><br><span class="line">Console.WriteLine(xiaoMing.Age);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：传入字段（值类型）中输出为4，但传入对象（引用类型）中输出为5。 <strong>按引用传参，用方法修改形参，实参往往也会被修改。</strong> <strong>按值传参，用方法修改形参，实参往往不会被修改。</strong></p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】构造方法</title>
    <url>/2018/08/12/%E3%80%90c%E3%80%91%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>实例化新对象时，使用表达式 _<strong>类名  对象名=new 类名（）</strong>；_，这里的new后接的类名加括号似乎是一个方法名，而实际上，这确实是一个方法名，这个方法就是<strong>构造方法</strong>。<br><a id="more"></a><br>构造方法的作用是<strong>为属性*赋值</strong>。我们注意到，刚刚提到的构造方法我们之前并没有对其进行定义，所以，<strong>在没有定义构造方法时，则会生成一个无参数的构造方法</strong>。而且，我们只在表达式_类名  对象名=new 类名（）_中使用构造方法，即只能用<strong>new+方法名调用构造方法</strong>。那么，如果我们想自己定义一个构造方法呢？请看实例： 在类Data中，我们定义了一个构造方法，即蓝色选中部分<img src="http://47.94.231.166/wp-content/uploads/2018/08/devenv_2018-08-12_18-31-38.png" alt=""> 这样，在调用时，我们就可以向其中输入变量，这里我们用“冯毅”替换“伏晨”，即<img src="http://47.94.231.166/wp-content/uploads/2018/08/devenv_2018-08-12_18-33-32.png" alt=""> 由此，我们可以总结出建立构造方法时，<strong>通常将构造方法声明为public，而且没有也不能有返回值类型，最后就是构造方法名必须与类名相同</strong>。 <strong>*构造方法其实也可以对字段进行修改</strong></p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】枚举类型</title>
    <url>/2018/08/13/%E3%80%90c%E3%80%91%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>有的类型本身就具有范围，例如性别，只有男或女，如果被赋予别的值虽然编译会通过但却不符合语言逻辑。为解决这样的问题，引入<strong>枚举类型</strong>。<br><a id="more"></a><br>枚举类型与整形、浮点型等等一样是一种数据类型，<strong>它本质上是从0开始的整形变量</strong>，所以它也是一种<strong>值类型</strong>。 定义枚举类型的正则表达式为：</p>
<h6 id="定义方法："><a href="#定义方法：" class="headerlink" title="定义方法："></a>定义方法：</h6><blockquote>
<p>enum 类型名                                                 enum  sex {                                                                     { 枚举值1，枚举值2……..枚举值n                   男，女 }                                                                     }</p>
</blockquote>
<h6 id="调用方法："><a href="#调用方法：" class="headerlink" title="调用方法："></a>调用方法：</h6><blockquote>
<p>声明：类型名  变量名=类型名.枚举值；       sex.hunam1=sex.男；</p>
</blockquote>
<h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><p>定义枚举：</p>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="http://47.94.231.166/wp-content/uploads/2018/08/devenv_2018-08-13_12-54-58.png" alt=""></h6><p>定义类：</p>
<h6 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="http://47.94.231.166/wp-content/uploads/2018/08/devenv_2018-08-13_12-55-08.png" alt=""></h6><p>主程序：</p>
<h6 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="http://47.94.231.166/wp-content/uploads/2018/08/devenv_2018-08-13_12-55-15.png" alt=""></h6><p>  因为枚举类型本质上就是整形，所以可以用整数来代替枚举值，首先选定一个枚举值，将鼠标放在枚举值上，编译器会给出该枚举值代表的整数，在调用该枚举值时，就可以写为</p>
<blockquote>
<p>（枚举类型名）整数</p>
</blockquote>
<p>这是一个强制转换语句，如用上例的内容举例，那么 （sex）0         =           sex.男</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】泛型</title>
    <url>/2018/09/28/%E3%80%90c%E3%80%91%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>泛型指一种模具，将相对应的数据注入即可得到泛型指定类型<br><a id="more"></a></p>
<h1 id="①泛型类"><a href="#①泛型类" class="headerlink" title="①泛型类"></a>①泛型类</h1></blockquote>
<p>//这是一个宠物笼子模型<br>class Cage{  //填充对应的宠物类型即可得到专属的笼子<br>  <strong>T</strong>[] petsArry; //<strong>T</strong>是一个替代值，就像形参，亦可定义多个<br>  public void PutIn(<strong>T</strong> pet){…}<br>  public <strong>T</strong> TakeOut(int index){…}<br>}</p>
<p>//调用时<br>var dogCage = new Cage();<br>var cavyCage = new Cage();<br>//Dog、Cavy是两个类<br>//var是一个简写，当然也可以写成Cage与Cage<br>dogCage.PutIn(new Dog());//放入第一只狗<br>dogCage.PutIn(new Dog());//放入第二只狗<br>Dog dog=dogCage.TakeOut(0);//取出第一只狗</p>
<p>代码示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Pet</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Pet</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cage</span></span><br><span class="line">&#123; <span class="comment">//填充对应的宠物类型即可得到专属的笼子</span></span><br><span class="line">    T[] petsArry; <span class="comment">//T是一个替代值，就像形参</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PutIn</span>(<span class="params">T pet</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; petsArry.Length) petsArry[num++] = pet;</span><br><span class="line">        <span class="keyword">else</span> Console.WriteLine(<span class="string">&quot;笼子已满&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">TakeOut</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> petsArry[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cage</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        petsArry=<span class="keyword">new</span> T[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> dogCage = <span class="keyword">new</span> Cage(<span class="number">2</span>);</span><br><span class="line">        dogCage.PutIn(<span class="keyword">new</span> Dog());</span><br><span class="line">        dogCage.PutIn(<span class="keyword">new</span> Dog());</span><br><span class="line">        Dog dog=dogCage.TakeOut(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关键字dufault："><a href="#关键字dufault：" class="headerlink" title="关键字dufault："></a>关键字<strong>dufault</strong>：</h2><p>返回指定类的默认值。如果泛型中需要对初始化却又不能确定泛型中注入的类型就可以使用该关键字将其初始化为默认值。 即</p>
<blockquote>
<p>引用类型→<strong>null</strong> 数值类型→<strong>0</strong> bool→<strong>false</strong> char→<strong>‘\\0’</strong> enum→相关枚举值<strong>对应0的值</strong>（第一个）</p>
</blockquote>
<h2 id="为什么需要泛型类？"><a href="#为什么需要泛型类？" class="headerlink" title="为什么需要泛型类？"></a>为什么需要泛型类？</h2><p>用基类或者公共的接口，甚至是所有类的基类object，也可以实现一个cage类，但是类型<strong>太宽泛</strong>，需要<strong>显示转换类型</strong>，并且<strong>判断真实类型</strong>是什么。</p>
<blockquote>
<p>泛型类的优势： ⚪代码量更小，无论多少种笼子，我们只需要一个实现 ⚪只有需要的类型才会被实例化 ⚪易于维护，修改模板，所有的实例都将改变</p>
</blockquote>
<h1 id="②泛型方法"><a href="#②泛型方法" class="headerlink" title="②泛型方法"></a>②泛型方法</h1><blockquote>
<p>泛型方法就是方法的模型，给定具体的类型，就可以实例化出一个操作该类型的具体方法。</p>
</blockquote>
<p>→泛型类中往往有泛型方法，普通类中也可以由泛型方法。</p>
<p>class Dog{<br>  void DogIsHappy(<strong>T</strong> target){…}<br>  //定义让狗狗开心的函数，即使狗狗开心，大括号内部为具体行为<br>  …<br>}</p>
<p>class Ball{…}//定义“球”类</p>
<p>//Main函数中（调用时）<br>Dog dog =new dog();//实例化一个狗狗对象<br>dog.IsHappy(new Person);//定义狗狗遇到球就开心<br>dog.IsHappy(3);//定义狗狗遇到数字3就开心</p>
<h1 id="③约束"><a href="#③约束" class="headerlink" title="③约束"></a>③约束</h1><blockquote>
<p>控制泛型，缩小泛型参数的范围</p>
</blockquote>
<p>→无论多么广泛总要有个范围，范围越小，约好控制 →泛型类、泛型方法都可被约束</p>
<blockquote>
<h6 id="约束条件："><a href="#约束条件：" class="headerlink" title="约束条件："></a>约束条件：</h6><p><strong>类名</strong>→<strong>该类</strong>或者<strong>继承</strong>该类的类 <strong>class</strong>→<strong>任何</strong>类 <strong>struct</strong>→<strong>任何</strong>值 <strong>接口名</strong>→<strong>该接口</strong>类型或任何实现该接口的<strong>类型</strong> <strong>new()</strong>→带有<strong>无参</strong>共有构造函数的类</p>
</blockquote>
<p>  约束叠加规则 <strong>泛型语句 where T 主约束 + 接口约束 + 构造约束</strong> →层层递进，逐层收紧。 主约束：<strong>只能有一个</strong>，包括类名，class，struct 接口约束：<strong>任意多个</strong> T 为参数，视实际情况替换 如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Cage <span class="keyword">where</span> T:Pet,IClimbTree,<span class="keyword">new</span>()&#123;...&#125;</span><br><span class="line"><span class="comment">//T必须是Pet类或由Pet类派生的类，且接受接口IClimbTree，且构造函数为无参。</span></span><br></pre></td></tr></table></figure>
<h1 id="④泛型接口"><a href="#④泛型接口" class="headerlink" title="④泛型接口"></a>④泛型接口</h1><blockquote>
<p>泛型接口允许我们将接口成员的<strong>参数</strong>和<strong>返回类型</strong>设置为泛型参数的接口</p>
</blockquote>
<p>//定义泛型接口<br>interface IMyself{<br><strong>T</strong> Myself(<strong>T</strong> self);<br>}<br>//实现泛型接口<br>class A:IMyself{<br>public <strong>A</strong> Myself(<strong>A</strong> self);<br>}//类型参数可以是实现类本身或者是其他类型</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】类和结构</title>
    <url>/2018/08/13/%E3%80%90c%E3%80%91%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><img src="http://47.94.231.166/wp-content/uploads/2018/08/WINWORD_2018-08-13_10-35-52.png" alt=""><br><a id="more"></a><br>注：结构的声明方法为</p>
<blockquote>
<p>static 结构名  对象名</p>
</blockquote>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】类的继承</title>
    <url>/2018/08/28/%E3%80%90c%E3%80%91%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="①共同"><a href="#①共同" class="headerlink" title="①共同"></a>①共同</h1><p>使用继承可以使一个类在创建时就具有另一个已知类的所有内容，大大节省了工作时间。 使用方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">class Child ：Parent</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，可写为“Child继承自Parent”，或“Parent派生出Child”。 注意，Object是任何类的基类，可多辈派生，但子类只能有一个父类。</p>
<h4 id="关键字base："><a href="#关键字base：" class="headerlink" title="关键字base："></a>关键字base：</h4><p>1.在派生类中使用<strong>“base.基类方法()”</strong>即可调用基类方法。 2.构造方法派生：在派生类的构造方法声明后接<strong>“:base()”</strong>即可调用基类的构造方法重写该构造方法。</p>
<h4 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h4><p>在实例化派生的对象时的顺序是：</p>
<blockquote>
<p><strong>实例成员初始化→基类构造函数→派生类构造函数</strong></p>
</blockquote>
<p>所以无论是否在初始化时调用基类构造函数，其都会被调用，这是一种隐式调用，当然也可以写成显式形式，如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span>(<span class="params"></span>)</span>&#123;...&#125;<span class="comment">//基类构造函数</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>:<span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Public <span class="title">Cat</span>(<span class="params"></span>):<span class="title">Pet</span>(<span class="params"></span>)</span>&#123;...&#125;<span class="comment">//使用冒号显式调用基类构造函数</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这里面构造方法Cat()与Pet()都会被执行一遍。 当然，这种冒号调用构造函数的方法更多的是用在<strong>类自身的构造函数之间互相调用</strong>。</p>
<h1 id="②相异"><a href="#②相异" class="headerlink" title="②相异"></a>②相异</h1><p>那么，若想在子类中添加相异于父类的内容该怎么办呢？</p>
<h4 id="1-隐藏方法"><a href="#1-隐藏方法" class="headerlink" title="1.隐藏方法"></a>1.隐藏方法</h4><p>该方法可以在子类中屏蔽父类的方法/字段，即，如果父类中存在一个方法，开发者却想在子类中添加一个与父类方法相异的重名方法，就可在子类中创建隐藏方法。 需要注意的是，隐藏方法需要与方法的重载区别，因此在隐藏“方法”时使用与原方法相同的方法名、类型、变量个数。 使用方法： 在子类型中创建类型、名字与原方法/字段相同的方法/字段，并且前面加关键字 new。  </p>
<h4 id="2-虚方法和多态"><a href="#2-虚方法和多态" class="headerlink" title="2.虚方法和多态"></a>2.虚方法和多态</h4><p>在实际编程工作时，我们倾向于使用更基本的类作为容器，比如笔类型可能派生出各种类型的笔：中性笔、铅笔等，每只笔有与其他笔相同的地方也有不同的地方，但我们在对每只笔进行操作时，倾向于以更大的单位即笔进行操作，将每种笔实例化为数组的值，这样就可以批量对笔进行集中处理。 因为各种笔的类型不同，但是都继承自大类型笔，这时，我们就可以利用形如 Pen Pen1=new Pencil(); 或 Pen[] Pens =new Pen[]{ new Pencil(), new markPen()}; 即，声明为父类型，但使用子类型的构造方法，来构造同样使用父类型作为容器的类型使用。但是需要注意的是该方法实例化的对象不可使用子类中新增的方法和字段。但是对于父类型和子类型都有的方法，就可以使用<strong>虚方法</strong>来进行区分。 比如，父类型Pen有方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">public</span> <span class="title">penWrite</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Pen is Writing&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类型Pencil有方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="title">PenWrite</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Pencil is Writing&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Main方法中执行以下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Pen Pen1=<span class="keyword">new</span> Pencil();</span><br><span class="line">Pen1.PenWrite();</span><br></pre></td></tr></table></figure>
<p>可输出“Pencil is Writing”，由此看来，程序执行了子类型中的函数，而非父类型中的函数，所以可用此方法使用数组分别调用每个子类型的特征。 注意： Ⅰ.重写虚方法必须具有相同的可访问性，且基类方法不能是private Ⅱ.不能重写static方法或者非虚方法 Ⅲ.方法、属性、索引器、事件，都可以声明为virtual或override。 例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot;is speaking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot;Pet&#x27;s Name is &quot;</span> + Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;宠物的名字是&quot;</span> + Name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot; is speaking:&quot;</span> + <span class="string">&quot;wow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot; is speaking:&quot;</span> + <span class="string">&quot;meow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Pet[] pets = <span class="keyword">new</span> Pet[] &#123; <span class="keyword">new</span> Dog(<span class="string">&quot;Jack&quot;</span>), <span class="keyword">new</span> Cat(<span class="string">&quot;Tom&quot;</span>) &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;pets.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pets[i].Speak();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>Jack is speaking:wow<br>Tom is speaking:meow</p>
<h1 id="③抽象成员"><a href="#③抽象成员" class="headerlink" title="③抽象成员"></a>③抽象成员</h1><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>抽象方法(abstract)比虚方法(virtual)更“虚”，<strong>它在基类中直接不写函数体，只能在派生类中重写该方法，否则无法被调用。</strong> 如</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"></span>)</span>;<span class="comment">//基类中不能写函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>:<span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Meow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//派生类中使用override重写抽象方法，并添加函数体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Cat cat=<span class="keyword">new</span> Cat();</span><br><span class="line">        cat.Speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong>不止可以抽象方法，还可以抽象属性、事件、索引。</strong></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>抽象类只有一个存在目的，就是被继承！</strong> 抽象类不能实例化，用abstract修饰。 抽象类可以包含抽象成员与普通成员，以及他们的任意组合。 抽象类的抽象成员在派生类中也需要用override关键字实现。 实际上，抽象类指的就是<strong>没有普遍性的基类</strong>，比如全世界有很多种语言，没有一个统一的语言可以被世界上所有人所共用。此时用基类声明语言，我们明知不会有一个统一的语言，就使用抽象类限制之。</p>
<h1 id="④密闭类和密闭方法"><a href="#④密闭类和密闭方法" class="headerlink" title="④密闭类和密闭方法"></a>④密闭类和密闭方法</h1><p>密闭类可以防止其他人通过<strong>继承</strong>来修改该类，密闭方法可以防止其他人<strong>重写</strong>该方法。 有同学问，不将基类方法声明为virtual不就不能被重写了？ 话是这样没错。但是，在派生类的派生类中的被重写（override）的方法<strong>默认还是可以被重写的</strong>，为了破除这个限制，我们才引用了密闭方法（sealed）。 密闭方法与密闭类的使用方法是一样的，都是在声明该方法/类之前使用<strong>sealed修饰符</strong>对其进行限制。</p>
<h1 id="⑤接口"><a href="#⑤接口" class="headerlink" title="⑤接口"></a>⑤接口</h1><h2 id="1-定义接口："><a href="#1-定义接口：" class="headerlink" title="1.定义接口："></a>1.定义接口：</h2><p>接口是<strong>声明</strong>一组函数成员，但不具体写出的一种引用类型。可以将其看作是一种类（class)。 接口有什么作用呢？接口可以作为许多类的某种<strong>共同方法</strong>普遍存在，比如猫、狗和蛇都会抓老鼠，我们就可以把抓老鼠设置为一个接口，在声明接口时声明一个数组。这样就可以在“让会抓老鼠的动物抓老鼠”时直接遍历调用接口即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">CatchAnimal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CatchMice</span>(<span class="params"></span>)</span>;<span class="comment">//默认为public，且不能添加访问修饰符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CatchBrid</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CatchFish</span>(<span class="params"></span>)</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口只能被类<strong>实现</strong>，实现时，使用”:”，与派生相像，但不是派生。 一个类可以实现多个接口，但只能派生自一个基类。 类在实现接口时，必须实现接口的所有函数成员，且所有函数成员必须添加public访问修饰符。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>:<span class="title">Pet</span>,<span class="title">CatchAnimal</span> <span class="comment">//“猫”类继承自“宠物”类，且实现了“CatchAnimal”接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CatchMice</span>(<span class="params"></span>)</span>&#123;...&#125;;<span class="comment">//必须添加public</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CatchBrid</span>(<span class="params"></span>)</span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CatchFish</span>(<span class="params"></span>)</span>&#123;...&#125;;</span><br><span class="line">......<span class="comment">//“猫”类的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-调用接口"><a href="#2-调用接口" class="headerlink" title="2.调用接口"></a>2.调用接口</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Cat cat =<span class="keyword">new</span> Cat();</span><br><span class="line">CatchAnimal catchs= cat;<span class="comment">//声明与接口相关联的对象</span></span><br><span class="line">c.CatchMice()<span class="comment">//通过对象调用</span></span><br><span class="line">catchs.CatchMisce()<span class="comment">//通过接口调用</span></span><br></pre></td></tr></table></figure>
<p>特殊情况：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Pet cat =<span class="keyword">new</span> Cat();</span><br><span class="line">CatchAnimal catchs=(CatchAnimal) cat;<span class="comment">//声明与接口相关联的对象，声明时注意强制转换</span></span><br><span class="line"><span class="comment">//c.CatchMice() //此时不可通过对象调用</span></span><br><span class="line">catchs.CatchMisce()<span class="comment">//只能通过接口调用</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】遍历数组关键字“foreach”</title>
    <url>/2018/08/09/%E3%80%90c%E3%80%91%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%85%B3%E9%94%AE%E5%AD%97foreach/</url>
    <content><![CDATA[<p>正则表达式：</p>
<h4 id="foreach-数组类型-迭代变量-in-数组名）"><a href="#foreach-数组类型-迭代变量-in-数组名）" class="headerlink" title="foreach( 数组类型  迭代变量 in 数组名）"></a><strong>foreach( 数组类型  迭代变量 in 数组名）</strong></h4><a id="more"></a>
<p>例： <img src="http://img.mukewang.com/55a767f800019c2f05440518.jpg" alt=""> 两者运行结果相同。 注意， ①迭代变量不可被赋值。 ②多维数组仍用一个迭代变量</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】闰年判断器Plus</title>
    <url>/2018/08/14/%E3%80%90c%E3%80%91%E9%97%B0%E5%B9%B4%E5%88%A4%E6%96%AD%E5%99%A8plus/</url>
    <content><![CDATA[<p><img src="http://47.94.231.166/wp-content/uploads/2018/04/78.png" alt="">丢。。。。。丢人<br><a id="more"></a><br>一个月了，终于做出来了人生中第一个“图形化”程序—闰年计算器！ 就这个<img src="http://47.94.231.166/wp-content/uploads/2018/08/闰年判断器_2018-08-14_17-42-36.png" alt=""> <img src="http://47.94.231.166/wp-content/uploads/2018/04/77.png" alt=""> <img src="http://47.94.231.166/wp-content/uploads/2018/04/88.png" alt=""></p>
<h4 id="退群！"><a href="#退群！" class="headerlink" title="退群！"></a><img src="http://47.94.231.166/wp-content/uploads/2018/04/70.png" alt="">退群！</h4><p>嘛。。。。万事开头难嘛。。。。</p>
]]></content>
      <categories>
        <category>从零开始的代码学习计划</category>
      </categories>
      <tags>
        <tag>阶段性练习</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】隐式转换与显式转换，装箱与拆箱</title>
    <url>/2018/09/27/%E3%80%90c%E3%80%91%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<p>隐式转换（Implicit）：<strong>系统默认</strong>的、<strong>不需要加以声明</strong>就可以进行的转换。如 float转换为double类型。 显式转换（Explicit）：利用<strong>强制类型转换</strong>运算符进行转换。如(int)a,a.ToString(),Convert.ToInt32(a)等等。<br><a id="more"></a></p>
<h4 id="栈：存放值类型的内存"><a href="#栈：存放值类型的内存" class="headerlink" title="栈：存放值类型的内存"></a><strong>栈</strong>：存放<strong>值类型</strong>的内存</h4><h4 id="堆：存放引用类型的内存"><a href="#堆：存放引用类型的内存" class="headerlink" title="堆：存放引用类型的内存"></a><strong>堆</strong>：存放<strong>引用类型</strong>的内存</h4><h1 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h1><p><strong>装箱</strong>：跟据<strong>值类型</strong>的值，在<strong>堆</strong>上创建一个完整的<strong>引用类型</strong>对象，并返回对象的<strong>引用</strong>，是一种<strong>隐式转换</strong>。 <strong>装箱的意义</strong>：将值类型<strong>转化为引用类型(如object)</strong>来进行统一的操作(如作为函数的参数)与统一的存储(object[])。 装箱示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">object</span> oi=<span class="literal">null</span>;</span><br><span class="line">oi=i;<span class="comment">//装箱</span></span><br></pre></td></tr></table></figure>
<p><strong>装箱本质</strong>：装箱的本质就是在堆上创建了<strong>引用类型的副本</strong>，新创建的引用类型和原来的值类型<strong>相互独立</strong>。</p>
<h1 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h1><p>拆箱：将装箱后的对象<strong>转换回值类型</strong>的过程，是一种<strong>显式转换</strong>。 如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">object</span> oi=i;<span class="comment">//装箱</span></span><br><span class="line"><span class="built_in">int</span> j=(<span class="built_in">int</span>)oi;<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>
<h1 id="装箱与拆箱的应用举例"><a href="#装箱与拆箱的应用举例" class="headerlink" title="装箱与拆箱的应用举例"></a>装箱与拆箱的应用举例</h1><p>将各种类型的元素装箱为Object类型，然后创建一个Object数组一并包括之：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Object[] array=<span class="keyword">new</span> Object[<span class="number">3</span>];<span class="comment">//创建包括三个元素的Object数组array</span></span><br><span class="line">array[<span class="number">0</span>]=<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>];<span class="comment">//第一个元素赋值为一个包含三个元素的字符串型数组</span></span><br><span class="line">array[<span class="number">1</span>]=<span class="number">3</span>;<span class="comment">//第二个元素赋值为一个整形数据“3”</span></span><br><span class="line">array[<span class="number">2</span>]=<span class="keyword">new</span> Dog();<span class="comment">//第三个元素赋值为Dog类的新对象</span></span><br><span class="line"><span class="comment">//导入数据，注意这里是隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>[] a=(<span class="built_in">string</span>[])array[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> b=(<span class="built_in">int</span>)array[<span class="number">1</span>];</span><br><span class="line">Dog dog=(Dog)array[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//导出数据，注意这里是显式转换</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】集合</title>
    <url>/2018/09/29/%E3%80%90c%E3%80%91%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>C#中存在多种集合形式，其中主要分为偏向数据<strong>存取效率</strong>的集合与偏向数据<strong>存取方式</strong>的集合。</p>
</blockquote>
<p>具体如下： 偏向数据存取效率：<strong>Arrays（数组）、ArrayList（动态数组）、List（列表）、Dictionary（字典）</strong> 偏向数据存取方式：<strong>Stack（栈）、Queue（队列）</strong><br><a id="more"></a></p>
<h1 id="①数组（Array）"><a href="#①数组（Array）" class="headerlink" title="①数组（Array）"></a>①数组（Array）</h1><p>数组我们早已熟悉，其方便之处就在于可以<strong>定义多维数组</strong>，且赋值和调用时<strong>无需装箱拆箱</strong>，效率高。缺点就是静态定义，定义时必须<strong>确定元素类型</strong>（定义成Object类型后也可以存储多种类型，但是需要装箱与拆箱）、<strong>后期无法增减元素</strong>。</p>
<h1 id="②动态数组（ArrayList）"><a href="#②动态数组（ArrayList）" class="headerlink" title="②动态数组（ArrayList）"></a>②动态数组（ArrayList）</h1><p>动态数组与数组的优缺点正好相反：优点是后期可以增减元素、定义时无需确定元素类型，所以理论上同一个动态数组可以包括不同的类型。但缺点是<strong>不能定义多维数组</strong>、赋值和调用时<strong>必须装箱和拆箱</strong>，效率低下。 定义方法：</p>
<p><strong>ArrayList</strong> array=new <strong>ArrayList()</strong>;</p>
<p>添加元素时，使用Add方法：</p>
<p>array.Add(new Dog());<br>array.Add(3);<br>array.Add(new string[3]);</p>
<p>移除元素时，使用<strong>Remove</strong>方法，也可以使用<strong>RemoveAt</strong>方法按照索引移除元素：</p>
<p>array.Remove(3)//移除元素3<br>array.RemoveAt(0)//移除第一个元素<br>array.Count//返回当前数组的元素数量</p>
<p>后面的列表、字典也以这种方式添加、删除元素。</p>
<h1 id="③列表（List）与字典（Dictionary）"><a href="#③列表（List）与字典（Dictionary）" class="headerlink" title="③列表（List）与字典（Dictionary）"></a>③列表（List）与字典（Dictionary）</h1><p>列表和字典使用<strong>泛型</strong>确定元素类型，故与动态数组相比继承了其后期<strong>可增减</strong>的优势，还有<strong>不需要装、拆箱</strong>的效率优势，<strong>所以如无特殊需要，可用List替代动态数组。</strong>字典与列表相比，其索引也可以是泛型。具体介绍见之前的文章：<a href="http://upane.cn/archives/625">【C#】List、Dictionary以及两种筛选算法</a></p>
<h1 id="④栈（Stack）"><a href="#④栈（Stack）" class="headerlink" title="④栈（Stack）"></a>④栈（Stack）</h1><p>栈是使用<strong>先入后出</strong>的元素读取形式。其使用<strong>泛型</strong>确定元素类型，我们不能具体调用栈中的某个元素，只可以访问栈中的首元素，也就是<strong>最后一个</strong>放进栈中的元素。（可以使用<strong>ToArray()</strong>将栈转为一个数组，如此即可对其中的某个元素进行操作） 定义：</p>
<p>Stack<strong><T></strong> stack=new Stack<strong><T></strong>();</p>
<p>向栈中添加元素（<strong>Push</strong>）：</p>
<p>stack.Push(T t);</p>
<p>返回栈的首元素（<strong>最后放入的</strong>）（<strong>Peek</strong>）：</p>
<p>T t=stack.Peek();</p>
<p>删除栈的首元素，并将其返回（<strong>Pop</strong>）：</p>
<p>T t=stack.Pop();</p>
<p>既可使用<strong>Count()</strong>方法返回栈的元素数量，也可以读取<strong>Length</strong>属性得到栈的元素数量：</p>
<p>int num1=stack.Count();<br>int num2=stack.Length;</p>
<h1 id="⑤队列（Queue）"><a href="#⑤队列（Queue）" class="headerlink" title="⑤队列（Queue）"></a>⑤队列（Queue）</h1><p>队列使用<strong>先进先出</strong>的元素读取形式，与栈相同：其使用<strong>泛型</strong>确定元素类型，我们不能具体调用队列中的某个元素，只可以访问队列中的首元素。但与栈不同的是，这里的首元素指的是<strong>第一个</strong>放进队列中的元素。（可以使用<strong>ToArray()</strong>将队列转为一个数组，如此即可对其中的某个元素进行操作） 定义：</p>
<p>Queue<strong><T></strong> queue=new Queue<strong><T></strong>();</p>
<p>向队列中添加元素（<strong>Enqueue</strong>）：</p>
<p>queue.Enqueue(T t);</p>
<p>返回队列的首元素（<strong>最先放入的</strong>）（<strong>Peek</strong>）：</p>
<p>T t=queue.Peek();</p>
<p>删除队列的首元素，并将其返回（<strong>Dequeue</strong>）：</p>
<p>T t=stack.Dequeue();</p>
<p>与栈相同，既可使用<strong>Count()</strong>方法返回队列的元素数量，也可以读取<strong>Length</strong>属性得到元素的元素数量：</p>
<p>int num1=queue.Count();<br>int num2=queue.Length;</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】静态成员与静态类</title>
    <url>/2018/09/26/%E3%80%90c%E3%80%91%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E9%9D%99%E6%80%81%E7%B1%BB/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="①静态成员"><a href="#①静态成员" class="headerlink" title="①静态成员"></a>①静态成员</h1><p>标识为static的字段、方法、属性、构造函数、事件，就是静态成员。 <strong>静态成员将被类的所有实例共享，所有实例都访问同一内存位置。静态成员和实例成员在内存中被分开保存。</strong> 静态成员可直接通过类名访问，没有实例也可以访问。 <strong>静态函数不能访问实例成员，仅能访问其他静态成员。</strong></p>
<h2 id="静态构造函数："><a href="#静态构造函数：" class="headerlink" title="静态构造函数："></a>静态构造函数：</h2><p>静态构造函数用于<strong>初始化静态字段</strong>。 在引用任何静态成员之前，和创建任何实例之前调用。 与类同名，使用static，无参数，<strong>无访问修饰符</strong>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Dog</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="②静态类"><a href="#②静态类" class="headerlink" title="②静态类"></a>②静态类</h1><p>如果类<strong>只包含</strong>静态的方法和属性，并标识为static 静态类<strong>不能创建实例</strong>，<strong>不能被继承</strong> 可以为静态类定义一个静态构造函数 静态类的作用： 1.作为基础类库，储存很多信息 2.作为<strong>扩展方法：</strong> 在不知晓源代码、密闭类不能派生时，就可以使用静态类作为拓展方法。 但是拓展方法需要<strong>指明对象</strong>（可在未实例化之前）。   如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Write</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Writepaper</span>(<span class="params"><span class="keyword">this</span> Pen pencil</span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Pen</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Pen pencil=<span class="keyword">new</span> Pen();</span><br><span class="line">pencil.Writepaper()<span class="comment">//就像Pen类中包含Writepaper方法一样，可直接被调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>扩展方法所属的类必须是static类 拓展方法本身必须是static方法 拓展方法的第一个参数类型，必须是<strong>this+类名</strong></p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【C#】面向对象的编程</title>
    <url>/2018/08/12/%E3%80%90c%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><h2 id="①-面向对象的三种技术手段："><a href="#①-面向对象的三种技术手段：" class="headerlink" title="① 面向对象的三种技术手段："></a>① 面向对象的三种技术手段：</h2><p><img src="http://47.94.231.166/wp-content/uploads/2018/08/面向对象.jpg" alt=""><br><a id="more"></a></p>
<h2 id="②-类与对象："><a href="#②-类与对象：" class="headerlink" title="② 类与对象："></a>② 类与对象：</h2><p><img src="http://47.94.231.166/wp-content/uploads/2018/08/类.jpg" alt=""> 静态特征：可以理解为程序所需数据存储，字段就是数据，属性则定义存储的方法（只读、只写、可写） 命名规则：变量用Camel标记法，常量用Pascal标记法，成员变量用Camel标记法，方法名和类名用Pascal标记法 Camel标记法，即“骆驼”标记法，像骆驼的驼峰一样，第一个单词首字母小写，其他单词大写，所以my button→myButton。 Pascal标记法，和Camel相似，但是首字母仍然大写。 ============================================================== 如： <img src="http://47.94.231.166/wp-content/uploads/2018/08/2018-08-12_10-00-14.png" alt=""> ① 面向对象的重点在于创建对象，所以一定不要忘记实例化对象，在以后引用的时候不能写“类.方法”或者“类.属性”，而是“对象.方法”，“对象.属性”。 实例化正则表达式： _类名  对象名=new 类名（）；_ ② 修饰符public，private可对数据方法、属性进行访问限制，但是单纯的开放封闭不能解决很多问题，所以引入属性概念，即</p>
<blockquote>
<p>public 数据类型 属性名 { get{return 目标变量 ；}    //可读 set{目标变量=value ；}   //可写 }</p>
</blockquote>
<p>注意，这里的数据类型可以有int、double等，也可以是数组类型int[]、double[] 封装快捷键：Ctrl+R+E</p>
<h6 id="③-方法的重载："><a href="#③-方法的重载：" class="headerlink" title="③ 方法的重载："></a>③ 方法的重载：</h6><p>同一个类中，方法名相同但参数或类型不同，仍可以编译通过的情况。 按照调用时输入变量的类型和数量，系统可自动选择两相同名称的方法函数。 <strong>构造方法也可重载</strong></p>
<h6 id="④Return"><a href="#④Return" class="headerlink" title="④Return"></a>④Return</h6><p>1.通过return结束方法的调用 当方法运行至</p>
<blockquote>
<p>return；</p>
</blockquote>
<p>时，结束该方法，继续下一条语句 2.使用return 为方法返回一个值 注意方法内return的变量是函数内部变量，函数内外有隔离性，外部定义相同名称的变量承接该值。</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【HTML】一篇文章通遍HTML基础</title>
    <url>/2018/10/25/%E3%80%90html%E3%80%91%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%80%9A%E9%81%8Dhtml%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>上周由于有任务所以加急学了HTML+CSS基础，并且做了一个网页。就最终作品来说算是比较完整地还原了自己想象中的网站，虽然兼容性很差，但是考虑到deadline如此，也是非常满意了。 同样由于赶工所以一周的学习都没有留痕迹，为了防止遗忘特在此从头到尾完整回忆一边HTML语法。<br><a id="more"></a></p>
<h1 id="①先说说HTML"><a href="#①先说说HTML" class="headerlink" title="①先说说HTML"></a>①先说说HTML</h1><p>HTML全称HyperText Markup Language，很多同学学完后会问“明明所有标签都可以用div代替啊？那还用记那么多标签的拼写干什么？”注意了啊（敲黑板），它名字里可是有Markup在里面，要是全用div那你Mark什么？ <a href="http://upane.cn/archives/220/attachment/23"><img src="http://47.94.231.166/wp-content/uploads/2018/04/23.png" alt=""></a> 编写规则（转义字符）： 有些字符在html中有特殊意义，要想让它们以文本形式显示而不是被认为是一个语句需要进行转义，就有了下面的规则：</p>
<p>**[空格]  &nbsp;<br>&lt;      &lt;</p>
<blockquote>
<pre><code> &amp;gt;
</code></pre><p>&amp;      &amp;<br>￥     &yen;<br>©      &copy;<br>®      &reg;** </p>
</blockquote>
<p>具体框架结构详见上一篇。</p>
<h1 id="②再扯扯doctype"><a href="#②再扯扯doctype" class="headerlink" title="②再扯扯doctype"></a>②再扯扯doctype</h1><p><strong>&lt;!doctype html&gt;</strong></p>
<p>很多同学都忽略了开头这个doctype，现在的很多IDE也会在创建HTML文件时自动加上这一句。但是少了它HTML就完全不能被执行了，因为它的含义是<strong>该文档使用HTML标准规范</strong>，浏览器看不到这个就按普通文档算！</p>
<h1 id="③然后，再谈谈属性"><a href="#③然后，再谈谈属性" class="headerlink" title="③然后，再谈谈属性"></a>③然后，再谈谈属性</h1><p>标签中可以夹属性，如</p>
<input **checked type="text"** />

<p>每个属性都可以赋值，那么，上面这个checked算是个什么呢？ 这是个省略语句，展开应该是<strong>checked=”checked”</strong>。 如此，标签名赋名字相同的值时，就可以省略。 那么，有哪些属性可以省略呢？</p>
<p><strong>可省略的属性      代表功能<br>checked         复选框选中<br>readonly        该文本框只读（不可输入）<br>defer           全部页面载入后再加载脚本（增加网页加载速度）<br>ismap           用户点击此页面后将鼠标位置发送给服务器<br>nohref          area标签中表示该区域没有相关链接<br>noshade         规定水平线的颜色呈现为纯色，而不是有阴影的颜色<br>nowrap          文本框内文字不自动换行<br>selected        下拉列表中预先选择该项<br>disabled        该按钮不可用<br>multiple        上传文件等可选择多个<br>noresize        规定用户无法调整框架的大小</strong></p>
<h1 id="④最后，我们再分分标签"><a href="#④最后，我们再分分标签" class="headerlink" title="④最后，我们再分分标签"></a>④最后，我们再分分标签</h1><p>标签分为哪几种？按照其呈现的形式，我们可将其分为<strong>行级元素</strong>与<strong>块级元素</strong>。 我们知道，HTML网页在不使用分层、position的情况下会默认将标签从上到下排列，但是有些元素好像可以“横着排”，比如连续使用两个<span>标签的文本显示起来就在一行而不是纵向排列，这就是<strong>行级元素</strong>。而默认纵向排列，即使多个加起来不满一行也不会横向排列的标签就是<strong>块级元素</strong>。 如图，“1”使用h1标签，是块级元素，所以即使它就一个数字的内容也会占满一行 <a href="http://upane.cn/archives/843/chrome_2018-10-23_17-44-34"><img src="http://47.94.231.166/wp-content/uploads/2018/10/chrome_2018-10-23_17-44-34-1024x122.png" alt=""></a> 而“222222222222”使用span标签，是行级元素，所以有多少字就占宽度，不会一次占满。 <a href="http://upane.cn/archives/843/chrome_2018-10-23_17-47-36"><img src="http://47.94.231.166/wp-content/uploads/2018/10/chrome_2018-10-23_17-47-36.png" alt=""></a> got it？ 那么，哪些标签是块级元素，哪些是行级元素呢？ <strong>块级元素：</strong> <address>…&lt;/adderss&gt; <center>...</center>  地址文字 <h1>...</h1>  标题一级 <h2>…</h2>  标题二级 <h3>…</h3>  标题三级 <h4>…</h4>  标题四级 <h5>…</h5>  标题五级 <h6>…</h6>  标题六级 <hr>  水平分割线 <p>...</p>  段落 <pre>...</pre>  预格式化 <blockquote>...</blockquote>  段落缩进   前后5个字符 <marquee>…</marquee>  滚动文本 <ul>...</ul>  无序列表 <ol>...</ol>  有序列表 <dl>...</dl>  定义列表 <table>...</table>  表格 <form>...</form>  表单 <div>...</div> <strong>行级元素：</strong> <span>…</span> <a>…</a>  链接 <br>  换行 <b>…</b>  加粗 <strong>…</strong>  加粗 <img >  图片 <sup>…</sup>  上标 <sub>…</sub>  下标 <i>…</i>  斜体 <em>…</em>  斜体 <del>…</del>  删除线 <u>…</u>  下划线 <input>…</input>  文本框 <textarea>…</textarea>  多行文本 <select>…</select>  下拉列表</p>
<h1 id="⑤剩下的，就都不难了"><a href="#⑤剩下的，就都不难了" class="headerlink" title="⑤剩下的，就都不难了"></a>⑤剩下的，就都不难了</h1><p>下面将罗列各个标签，文档中的标记代表如下： <span>hi</span>  这里的hi称为<strong>在标签里</strong> <meta name="author" content="Tim"> 这里的name和content称为标签的<strong>属性</strong> 标记形式（Note）=【Sig=Single=单标记=成单出现   Dou=Double=双标记=成双出现】 元素类型（Element）=【Blo=Block=块级元素  Row=Row=行级元素 Non=None=非显示元素】 表达式：[Note.Element] 属性:{内容枚举（小写，各例用逗号连接）/内容概括（大写）} 若有红色标记的属性则代表该属性不可忽略（不赋值），若忽略则该标签不可用 如： <strong><img></strong> <strong>[Sig.Row]</strong> src={“PATH”} position:{static,relative,absolute,fixed} 含义为：img标签为单标记的行级元素，其中有两个属性src和position，src填入内容为路径，且该属性不可被忽略，而position内容为static,relative,absolute,fixed其中的一个。</p>
<h2 id="1-文档头部标记"><a href="#1-文档头部标记" class="headerlink" title="1.文档头部标记"></a>1.文档头部标记</h2><p><strong>⑴<meta> 定义页面信息标记</strong> <strong>[Sig.Non]</strong> 标记定义页面的原信息，信息可包括多种形式。 属性： <meta name="名称" content="值" /> 名称可被替换为多种固定类型，可在值中定义名称的内容。 可选择的名称为： keywords：搜索引擎辅助标签，为网站增加特征点，各标签之间用逗号隔开。 description：网页描述，辅助搜索引擎 author：声明网页作者 <meta http-equiv="名称" content="值" /> 指定浏览器对网页的行为，如解码方式、跳转等。 可选择的名称为： Content-Type：（对应值text/html;charset=utf-8）声明以utf-8解码 refresh：（对应值10;url=”A”）载入页面10秒后跳转至A网页 <strong>⑵<link>引用外部文件标记</strong> <strong>[Sig.Non]</strong> 该标签用于引入外部文件 常用属性： href:{URL}：引入的文件链接 rel:{stylesheet}：表示引入内容为一个外部样式表 type:{text/css,text/javascript}：表示引入文件类型为css样式表或者JavaScript脚本 <strong>⑶<title>设置页面标题标记</strong> <strong>[Dou.Non]</strong> 标签内的内容将显示在浏览器标题上 ⑷<style>内嵌样式标记 [Dou.Non] 标签中的值将作为css样式载入html标签，但为了分离css设计和html骨架所以不推荐使用该标签定义css内容，应更多地使用分离的文件承载css与html文件。</p>
<h2 id="2-文本控制标记"><a href="#2-文本控制标记" class="headerlink" title="2.文本控制标记"></a>2.文本控制标记</h2><p><strong>⑴<hx>标题标记</strong> <strong>[Dou.Blo]</strong> 设置标题，x=1~6，其中h1只能用一次。 常用属性： align:{left,center,right}：对齐方式 <strong>⑵<p>段落标记</strong> <strong>[Dou.Blo]</strong> 表示一段文本 <strong>⑶<hr />水平线标记</strong> <strong>[Sig.Blo]</strong> 产生一个水平分割线 常用属性： align:{left,right,center}：设置水平线对齐方式 size:{Pixel}：设置水平线粗细，默认2px color:{COLOR}：设置水平线颜色 width{Pixel、%}：设置水平线高度 <strong>⑷<br />换行标记</strong> <strong>[Sig.Non]</strong> <strong>任何用<br />控制文本位置的程序猿都该被火刑</strong> _--某愤怒的编辑_</p>
<h2 id="3-文本格式化标记"><a href="#3-文本格式化标记" class="headerlink" title="3.文本格式化标记"></a>3.文本格式化标记</h2><p><strong>⑴<b>文本粗体标记</strong> <strong>[Dou.Row]</strong> 使内含文字格式化为粗体，无其他意义。 <strong>⑵<strong>强调文本标记（粗体）</strong> <strong>[Dou.Row]</strong> 同样使文字格式化为粗体，但是具有强调意义，该意义会被搜索引擎理解。 <strong>⑶<i>文本斜体标记</strong> <strong>[Dou.Row]</strong> 使内含文字格式化为斜体，无其他意义。 <strong>⑷<em>强调文本标记（斜体）</strong> <strong>[Dou.Row]</strong> 同样使文字格式化为斜体，但是具有强调意义，该意义会被搜索引擎理解。 <strong>⑸<del>删除线标记</strong> <strong>[Dou.Row]</strong> 为内含文字添加删除线。该标记还有<s>的写法，但不推荐使用。 <strong>⑹<ins>下划线标记</strong> <strong>[Dou.Row]</strong> 为内含文字添加下划线。该标记还有<u>的写法，但不推荐使用。</p>
<h2 id="4-功能标记"><a href="#4-功能标记" class="headerlink" title="4.功能标记"></a>4.功能标记</h2><p><strong>⑴<img>图像标记</strong> <strong>[Sig.Row]</strong> 插入一个图像，默认原图像大小，不进行缩放。 src={PATH}：图像文件路径 alt={TEXT}：图片不能正常加载时显示的文字，也是搜索引擎获取图片信息的方式。从优化网页的角度看也是不可被忽略的。 title={TEXT}：鼠标悬停时显示的内容 width/height：图像的宽/高，值设定一个值会等比例放大，否则图像将拉伸 vspace={PIXEL}：设置图像顶部和底部的留白（垂直边距） hspace={PIXEL}：设置图像左侧核右侧的留白（水平边距） align={left,right,top,middle,bottom}：图像位于文字左（left）、右侧（right），图片顶部（top）、中线（middle）、底部（bottom）与文字第一行对其，其余在图片下 <strong>⑵<a>超链接标记</strong> <strong>[Dou.Row]</strong> 标签内可为其他可见标签，用户点击时跳转至固定的目标 href={URL,PATH}：跳转目标位置 target={_blank,_self}：目标窗口弹出方式，有新窗口打开（_blank）和从原窗口（_self）打开</p>
<h2 id="5-排版标签"><a href="#5-排版标签" class="headerlink" title="5.排版标签"></a>5.排版标签</h2><p><strong>⑴<ul>无序列表</strong> <strong>[Dou.Blo]</strong> 创建一个无序列表，列表各项用<li>分隔</p>
<ul>
  <li>我不是</li>
  <li>我没有</li>
  <li>我可没说啊</li>
</ul>

<p>使用效果如下：</p>
<ul>
<li>我不是</li>
<li>我没有</li>
<li>我可没说啊</li>
</ul>
<p><strong>⑵<ol>有序列表</strong> <strong>[Dou.Blo]</strong> 创建一个有序列表，列表各项用<li>分隔</p>
<ol> 
  <li>我不是</li> 
  <li>我没有</li> 
  <li>我可没说啊</li> 
</ol>

<p>效果如下：</p>
<ol>
<li>我不是</li>
<li>我没有</li>
<li>我可没说啊</li>
</ol>
<p><strong>⑶<dt>无符列表</strong> <strong>[Dou.Blo]</strong> 创建一个没有符号（圆圈、序号）的列表，各项用<dd>分隔</p>
<dt> 
   <dd>我不是</dd> 
   <dd>我没有</dd> 
   <dd>我可没说啊</dd> 
</dt>

<p>效果如下： 我不是 我没有 我可没说啊 <strong>⑷<nav>导航栏标签</strong> <strong>[Dou.Blo]</strong> 代表内容为一个导航栏，并不会有什么优化，只是标记这是个导航栏，通常在其中套一个列表。 常用作以下场合： 传统顶部导航条、侧边导航栏、页内导航、翻页操作 <strong>⑸<header>标题标签</strong> <strong>[Dou.Blo]</strong> 代表一个标题，但是同样不会对版式有什么优化，里面可以嵌套h1等达到标题效果。可以是页面的标题也可以是板块的标题，内容也可多可少，比如在里面套一个副标题。所以此标签在一个页面允许出现多次。 <strong>⑹<article>文章标签</strong> <strong>[Dou.Blo]</strong> 代表一篇文章或者一个评论等，也不会对版式有什么优化，只是一个标记而已。 <strong>⑺<aside>附属标签</strong> <strong>[Dou.Blo]</strong> 定义侧边栏、广告等信息，无板式优化。 <strong>⑻<section>版块标签</strong> <strong>[Dou.Blo]</strong> 定义一个版块，但不是用于排版目的，若用于排版请用div 若article、nav、aside更适合时应用此更详细的标签 无板式优化 <strong>⑼<footer>页脚标签</strong> <strong>[Dou.Blo]</strong> 定义一个页脚版块，但是该标签本身无版式优化，所以就算使用了footer还是该在哪里就在哪里，不会浮于底部。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>HTML</category>
        <category>Web</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>【HTML】交互控件</title>
    <url>/2018/11/11/%E3%80%90html%E3%80%91%E4%BA%A4%E4%BA%92%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<p><a href="http://47.94.231.166/wp-content/uploads/2018/11/Interactive_contols.html">>无扰阅读模式（测试）</a><br><a id="more"></a></p>
<h1 id="交互控件"><a href="#交互控件" class="headerlink" title="交互控件"></a>交互控件</h1><p>[Interactive contols]</p>
<hr>
<h6 id="何为交互控件？"><a href="#何为交互控件？" class="headerlink" title="何为交互控件？"></a>何为交互控件？</h6><blockquote>
<p>交互控件就是可以与用户完成<strong>交互动作</strong>（如点击、输入）的一种特殊化语义的标签</p>
</blockquote>
<h2 id="①交互元素"><a href="#①交互元素" class="headerlink" title="①交互元素"></a>①交互元素</h2><h3 id="Ⅰ-下拉菜单栏（Detail元素与Summary元素）"><a href="#Ⅰ-下拉菜单栏（Detail元素与Summary元素）" class="headerlink" title="Ⅰ. 下拉菜单栏（Detail元素与Summary元素）"></a>Ⅰ. 下拉菜单栏（Detail元素与Summary元素）</h3><p><code>details</code>与<code>summary</code>常常共同使用，并且常用于制作下拉菜单栏。</p>
<h4 id="details-amp-summary元素"><a href="#details-amp-summary元素" class="headerlink" title="details&amp;summary元素"></a>details&amp;summary元素</h4><p>[Dou.Blo]</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;否认三连&lt;&#x2F;summary&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;我不是&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;我没有&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;我可没说过啊&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure>
<h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><p>否认三连</p>
<ul>
<li>我不是</li>
<li>我没有</li>
<li>我可没说过啊</li>
</ul>
<p><strong>不难看出，下拉菜单的实质是一个<code>Summary</code>标签用于下拉菜单显示标题，然后使用一个列表标签表示菜单选项</strong></p>
<h3 id="Ⅱ-进度条（progress元素和meter元素）"><a href="#Ⅱ-进度条（progress元素和meter元素）" class="headerlink" title="Ⅱ.进度条（progress元素和meter元素）"></a>Ⅱ.进度条（progress元素和meter元素）</h3><h4 id="㈠progress元素"><a href="#㈠progress元素" class="headerlink" title="㈠progress元素"></a>㈠progress元素</h4><p>[Dou.Row] <code>progress</code>元素可以定义一个普通进度条，其常用属性有：</p>
<p>属性</p>
<p>说明</p>
<p>max</p>
<p>定义进度条的最大值，默认为1元素</p>
<p>min</p>
<p>定义进度条的最低值，默认为0</p>
<p>value</p>
<p>定义进度条显示的值</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;progress value&#x3D;60 max&#x3D;100&gt;&lt;&#x2F;progress&gt;</span><br></pre></td></tr></table></figure>
<h4 id="效果：-1"><a href="#效果：-1" class="headerlink" title="效果："></a>效果：</h4><h4 id="㈡meter元素"><a href="#㈡meter元素" class="headerlink" title="㈡meter元素"></a>㈡meter元素</h4><p>[Dou.Row] <code>meter</code>元素凭借可以定义较高值与较低值的优势更多的是<strong>显示数据</strong></p>
<p>属性</p>
<p>说明</p>
<p>high</p>
<p>定义一个“高值范围”，若进度条的值高于此值则告诉浏览器“过高”</p>
<p>low</p>
<p>定义一个“低值范围”，若进度条的值低于此值则高速浏览器“过低”</p>
<p>max</p>
<p>定义进度条的最大值，默认为1</p>
<p>min</p>
<p>定义进度条的最低值，默认为0</p>
<p>optimum</p>
<p>定义一个“最佳值”，若该值高于high，则代表值越高越好，若低于low，则代表值越低越好</p>
<p>value</p>
<p>定义进度条显示的值</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h6&gt;学生成绩&lt;&#x2F;h6&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">学霸：&lt;meter value&#x3D;90 max&#x3D;100 high&#x3D;80 low&#x3D;60&gt;&lt;&#x2F;meter&gt;90&lt;br&#x2F;&gt;</span><br><span class="line">班长：&lt;meter value&#x3D;75 max&#x3D;100 high&#x3D;80 low&#x3D;60&gt;&lt;&#x2F;meter&gt;75&lt;br&#x2F;&gt;</span><br><span class="line">学渣：&lt;meter value&#x3D;50 max&#x3D;100 high&#x3D;80 low&#x3D;60&gt;&lt;&#x2F;meter&gt;50&lt;br&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h4 id="效果：-2"><a href="#效果：-2" class="headerlink" title="效果："></a>效果：</h4><h6 id="学生成绩"><a href="#学生成绩" class="headerlink" title="学生成绩"></a>学生成绩</h6><p>学霸：90<br>班长：75<br>学渣：50  </p>
<h2 id="②表单"><a href="#②表单" class="headerlink" title="②表单"></a>②表单</h2><p>表单是一种要求用户输入的可视化控件集合</p>
<h3 id="创建一个表单"><a href="#创建一个表单" class="headerlink" title="创建一个表单"></a>创建一个表单</h3><p>创建表单需要引入<code>form</code>元素，通过更改form元素的属性可以初步确定数据的发送对象、发送方式等信息。</p>
<h4 id="form"><a href="#form" class="headerlink" title="form"></a>form</h4><p>[Dou.Blo]</p>
<h5 id="常用属性："><a href="#常用属性：" class="headerlink" title="常用属性："></a>常用属性：</h5><p>属性</p>
<p>说明</p>
<p>action</p>
<p>该属性确定发送数据的目标页面地址</p>
<p>method</p>
<p>该属性确定发送数据的方式，有<code>get</code>和<code>post</code>可选，默认为<code>post</code>前者为数据一次性传送，后者为分步传送。但<code>get</code>保密性差，且有数据限制，所以推荐使用<code>post</code></p>
<p>novalidate</p>
<p>指定是否为用户输入该form中的控件内容进行检查</p>
<h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>[<strong>Sig</strong>.Blo] 需要注意的是，<code>input</code>元素需要嵌套在form元素中才可用！</p>
<p>属性</p>
<p>属性值</p>
<p>说明</p>
<p>效果</p>
<p>type</p>
<p>text</p>
<p>单行为本输入框</p>
<p>-</p>
<p>password</p>
<p>密码输入框</p>
<p>-</p>
<p>radio</p>
<p>单选按钮</p>
<p>-</p>
<p>checkbox</p>
<p>复选框</p>
<p>-</p>
<p>button</p>
<p>普通按钮</p>
<p>-</p>
<p>submit</p>
<p>提交按钮</p>
<p>-</p>
<p>reset</p>
<p>重置按钮</p>
<p>-</p>
<p>image</p>
<p>图片形式的<strong>提交按钮</strong></p>
<p>-</p>
<p>hidden</p>
<p>隐藏域</p>
<p>-</p>
<p>file</p>
<p>文件域</p>
<p>-</p>
<p>email</p>
<p>E-mail地址输入区域</p>
<p>-</p>
<p>url</p>
<p>URL地址输入区域</p>
<p>-</p>
<p>number</p>
<p>数字输入区域</p>
<p>-</p>
<p>range</p>
<p>一定范围的数字输入区域(轨迹条）</p>
<p>-</p>
<p>date、month、week、time、datetime（-local）</p>
<p>时间选择区域（示例为<code>date</code>）</p>
<p>-</p>
<p>search</p>
<p>搜索区域</p>
<p>-</p>
<p>color</p>
<p>颜色输入区域</p>
<p>-</p>
<p>tel</p>
<p>电话号码输入区域</p>
<p>name</p>
<p>开发人员任取</p>
<p>空间名称</p>
<p>value</p>
<p>开发人员任取</p>
<p>空间默认值</p>
<p>size</p>
<p>正整数</p>
<p>空间在页面中显示的宽度</p>
<p>readonly</p>
<p>readonly</p>
<p>控件只读（不可修改）</p>
<p>disabled</p>
<p>disabled</p>
<p>控件禁用</p>
<p>checked</p>
<p>checked</p>
<p>控件默认选中</p>
<p>maxlength</p>
<p>正整数</p>
<p>空间允许输入的最大字符数量</p>
<p>autocomplete</p>
<p>on/off</p>
<p>设定是否自动完成表单字段内容</p>
<p>autofocus</p>
<p>autofocus</p>
<p>指定页面加载后是否自动将焦点移至本控件</p>
<p>form</p>
<p>fom的元素id</p>
<p>设定字段隶属于哪一个或多个表单</p>
<p>list</p>
<p>datalist的元素id</p>
<p>指定字段的候选数据值列表</p>
<p>multiple</p>
<p>multiple</p>
<p>指定输入框是否可以选择多个值</p>
<p>min、max和step</p>
<p>数值</p>
<p>指定输入框所允许的最大值、最小值及间隔</p>
<p>pattern</p>
<p>字符串</p>
<p>验证输入内容是否与正则表达式匹配</p>
<p>placeholder</p>
<p>字符串</p>
<p>为<code>input</code>类型的输入框提供一种提示</p>
<p>required</p>
<p>required</p>
<p>规定输入框填写内容不可为空</p>
]]></content>
      <categories>
        <category>web</category>
        <category>HTML</category>
        <category>Web</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>【HTML】初识HTML</title>
    <url>/2018/10/15/%E3%80%90html%E3%80%91%E5%88%9D%E8%AF%86html/</url>
    <content><![CDATA[<p>HTML全名叫“超文本标记语言”，优势是可以被任何浏览器执行，可以说是一种脚本语言….. <a href="http://upane.cn/archives/220/attachment/57"><img src="http://47.94.231.166/wp-content/uploads/2018/04/57.png" alt=""></a>Boss让这周末初步学完HTML+CSS，没时间介绍啦直接开写！<br><a id="more"></a></p>
<h1 id="HTML和CSS、Javascript有什么区别？"><a href="#HTML和CSS、Javascript有什么区别？" class="headerlink" title="HTML和CSS、Javascript有什么区别？"></a>HTML和CSS、Javascript有什么区别？</h1><p>一言难尽啊，如果把一个网页比喻成一个人，形象地说HTML就是人的骨架（结构），CSS就是人的肉体外表（外观），Javascript就是人的灵魂（逻辑代码），没有Javascript只有HTML和CSS就相当于植物人，没有CSS只有HTML和Javascript就相当于咱 <a href="http://upane.cn/archives/220/attachment/55"> <img src="http://47.94.231.166/wp-content/uploads/2018/04/55.png" alt=""></a> 那没有HTML….废话这人能不要脸还能不要骨头吗？</p>
<h1 id="结构！结构！"><a href="#结构！结构！" class="headerlink" title="结构！结构！"></a>结构！结构！</h1><p>HTML说白了就是强调结构的脚本，是网页的骨架，这个结构参照人体可分为脑袋（Head）和身体（Body）。 <a href="http://upane.cn/archives/834/chrome_2018-10-15_22-46-32"><img src="http://47.94.231.166/wp-content/uploads/2018/10/chrome_2018-10-15_22-46-32-300x300.png" alt=""></a> （随便撸一份网页源码都可以看到Head和Body）</p>
<h2 id="脑袋里装的什么呢？"><a href="#脑袋里装的什么呢？" class="headerlink" title="脑袋里装的什么呢？"></a>脑袋里装的什么呢？</h2><p>程序运行由此进入，所以这里是对整个页面的总结，比如页面的编码格式、标题都在此存放。</p>
<h2 id="身体里装的什么呢？"><a href="#身体里装的什么呢？" class="headerlink" title="身体里装的什么呢？"></a>身体里装的什么呢？</h2><p>那当然是页面主体，也就是用户接触到的可视化部分。</p>
<h1 id="标签：大写的重要"><a href="#标签：大写的重要" class="headerlink" title="标签：大写的重要"></a><h1>标签：大写的重要</h1></h1><blockquote>
<h2 id="要么说人家HTML先进，都是成双成对的！"><a href="#要么说人家HTML先进，都是成双成对的！" class="headerlink" title="要么说人家HTML先进，都是成双成对的！"></a>要么说人家HTML先进，都是成双成对的！</h2></blockquote>
<h2 id="格式：成双成对"><a href="#格式：成双成对" class="headerlink" title="格式：成双成对"></a>格式：成双成对</h2><p>①有<h1>就有</h1>, 有<button>就有</button> 你要棒打鸳鸯？Sorry，不通过！ <a href="http://upane.cn/archives/220/70-2"><img src="http://47.94.231.166/wp-content/uploads/2018/04/70.png" alt=""></a> ②标签两边靠，内容挤中间，如</p>
<button>点我啊你敢吗</button>

<p>这是一个按钮，效果就是这样的： 点我啊你敢吗 ③嵌套书写，如<button><h1>我就是写写</h1></button> ④大小写随便，一般都是<strong>小写</strong></p>
<h2 id="HelloWorld引发的讨论"><a href="#HelloWorld引发的讨论" class="headerlink" title="HelloWorld引发的讨论"></a>HelloWorld引发的讨论</h2><p>一段字符串可以怎么改？ 加CSS！ ↓ <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <title>Html和CSS的关系</title> <style type="text/css"> h1{                            👈给“身上”的h1标题添加大括号里的格式 font-size:12px;          👈字体大小，12像素 color:#930;                👈字体颜色，HEX16进制格式 text-align:center;       👈对齐方式：居中 } </style> </head> <body> <h1>Hello World!</h1>👈你被强化了！ </body> </html> ↑</p>
<h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><p></p>段落标签，表示里面的字符串是一段，遇到心情好的浏览器没准给你预格式化一下什么的，如

<p>有蒸羊羔、蒸熊掌、蒸鹿尾儿、烧花鸭、烧雏鸡、烧子鹅、卤猪、卤鸭、酱鸡、腊肉、松花小肚儿、晾肉、香肠儿、什锦苏盘、熏鸡白肚儿、清蒸八宝猪、江米酿鸭子、罐儿野鸡、</p>

<p>罐儿鹌鹑、卤什件儿、卤子鹅、山鸡、兔脯、菜蟒、银鱼、清蒸哈什蚂、烩鸭丝、烩鸭腰、烩鸭条、清拌鸭丝、黄心管儿、焖白鳝、焖黄鳝、豆豉鲇鱼、锅烧鲤鱼、烀烂甲鱼、抓炒鲤鱼、</p>

<p>抓炒对儿虾、软炸里脊、软炸鸡、什锦套肠儿、卤煮寒鸦儿、麻酥油卷儿、熘鲜蘑、熘鱼脯、熘鱼肚、熘鱼片儿、醋熘肉片儿、烩三鲜、烩白蘑、烩鸽子蛋、炒银丝、烩鳗鱼、炒白虾、</p>

<p>炝青蛤、炒面鱼、炒竹笋、芙蓉燕菜、炒虾仁儿、烩虾仁儿、烩腰花儿、烩海参、炒蹄筋儿、锅烧海参、锅烧白菜、炸木耳、炒肝尖儿、桂花翅子、清蒸翅子、炸飞禽。炸汁儿、炸排骨、</p>

<h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><p>给一串字符加超链接 <a href="地址"></a> 如</p>
<p><a href="http://upane.cn">主页面</a></p>
<p>效果如下：你一点就跳到主页了。 <a href="http://upane.cn">主页面</a></p>
<h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><p><img src="地址"> **没有</img>!**</p>
<h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><p>在<head></head>标签中可以添加<title></title>标签，以此更改网页的标题，该标签将在选项卡或窗口标题显示，并不会显示在页面中。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><!--注释文字-->
<p>欧呦这个注释好麻烦，不过可以一次框选多行，也算是值吧。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>HTML</category>
        <category>Web</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】IO流作业</title>
    <url>/2018/12/05/%E3%80%90java%E3%80%91io%E6%B5%81%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> IOExperiment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String fileName = <span class="string">&quot;test.txt&quot;</span>;<span class="comment">//创建一个常量，用于保存文件名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> CreatFile(<span class="string">&quot;D:\\&quot;</span>+fileName,<span class="string">&quot;Hello Java&quot;</span>);<span class="comment">//调用CreatFile类的构造方法创建D盘的文件</span></span><br><span class="line">        ReadFile read=<span class="keyword">new</span> ReadFile(<span class="string">&quot;D:\\&quot;</span>+fileName);<span class="comment">//创建读取类</span></span><br><span class="line">        <span class="keyword">new</span> CreatFile(<span class="string">&quot;E:\\&quot;</span>+fileName,read.BeginRead());<span class="comment">//使用读取类读取文件内容，并以此创建新的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建文件类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreatFile</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filePath;<span class="comment">//文件的位置</span></span><br><span class="line">    <span class="keyword">private</span> String fileContent;<span class="comment">//文件的内容</span></span><br><span class="line">    <span class="keyword">private</span> BufferedWriter outputstream;<span class="comment">//输出数据流</span></span><br><span class="line">    <span class="comment">//构造函数，需要分别传入文件位置和文件内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreatFile</span><span class="params">(String filePath,String content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath=filePath;</span><br><span class="line">        <span class="keyword">this</span>.fileContent=content;<span class="comment">//赋值</span></span><br><span class="line">        BeginCreate();<span class="comment">//调用方法构建文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造文件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BeginCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            outputstream=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(filePath));<span class="comment">//实例化输出流，这里可能抛出异常，所以使用catch捕获之</span></span><br><span class="line">            outputstream.write(fileContent);<span class="comment">//把文件内容写入文件</span></span><br><span class="line">            outputstream.flush();<span class="comment">//刷新并清空流数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)<span class="comment">//捕获创建文件的异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();<span class="comment">//打印异常原因</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(outputstream!=<span class="keyword">null</span>)outputstream.close();<span class="comment">//不管异常是否存在，终需要关闭流</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)<span class="comment">//捕获关闭流时的异常</span></span><br><span class="line">            &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadFile</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filePath;<span class="comment">//文件的位置</span></span><br><span class="line">    BufferedReader inputstream;<span class="comment">//输入流</span></span><br><span class="line">    <span class="comment">//读取文件类的构造方法，只需要传入文件位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadFile</span><span class="params">(String filePath)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath=filePath;<span class="comment">//赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取文件的方法，因为需要返回文件的内容，所以设为公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">BeginRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String result=<span class="keyword">null</span>;<span class="comment">//要返回字符串，考虑到读取失败的情况，遂在此声明并初始化返回值，以杜绝无值返回的问题</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            inputstream = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filePath));<span class="comment">//创建输入流</span></span><br><span class="line">            result=inputstream.readLine();<span class="comment">//读取文件的第一行，将读取结果传给result</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)<span class="comment">//考虑到读取失败的问题，需捕获读取时的异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(inputstream!=<span class="keyword">null</span>)inputstream.close();<span class="comment">//不管读取成功与否，终需要关闭输入流</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)<span class="comment">//捕获输入流关闭失败的异常</span></span><br><span class="line">            &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回读取结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>课堂作业</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】Java基础知识</title>
    <url>/2018/10/14/%E3%80%90java%E3%80%91java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>这一系列的笔记都是针对像我一样从C#转到Java的同学准备的，由于Java与C#关联性较高，很多代码都有重合，所以主要写一些两者的不同，以便日后翻阅。算是站在C#基础上的提升吧。<br><a id="more"></a><br>与C#依赖于.Net框架一样，Java依赖于JVM（Java Runtime Environment，Java运行环境），但是这个环境不在Windows里预装，所以在编程之前，需要先下好JDK（Java Development Kit，Java开发套件）。使用的IDE是JetBrain公司开发的<strong>IntelliJ IDEA</strong>，现在也在更新其教程，有兴趣的同学可以去看看。</p>
<h1 id="①注释"><a href="#①注释" class="headerlink" title="①注释"></a>①注释</h1><p>注释一行和注释一段与C#相同，<strong>都是//与/_….._/</strong> Java中<strong>注释文档</strong>的书写格式为</p>
<p>/**<br>*</p>
<h1 id="这里写方法的用途"><a href="#这里写方法的用途" class="headerlink" title="这里写方法的用途"></a>这里写方法的用途</h1><p>*@param args 形参args的含义<br>*@return 返回值的含义<br>*/</p>
<p>这个写了倒是不会在编译时给出提醒，但是编译后可以选择同时生成一个HTML文件，打开后即是界面非常人性化的注释文档了。不过在开发过程中用途并不大，没有C#的文档注释实用，就暂时不展开讲了。</p>
<h1 id="②常量与变量"><a href="#②常量与变量" class="headerlink" title="②常量与变量"></a>②常量与变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量的定义方法与C#不同：</p>
<p>C#：<br>const int TEXT_NUM;<br>Java:<br><strong>final</strong> int TEXT_NUM;</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>常用变量中大部分与C#相同，只是bool变量改名为<strong>boolean</strong>，声明string类型首字母必须大写<strong>String</strong> 还有需要注意的就是Java中<strong>不存在</strong>C#中<strong>var</strong>那样的模糊定义类型</p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>转义字符还是用 <strong>/</strong></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>隐式转换规则与C#相同。 显式转换写法也与C#相同，但是Java没有Convert类，所以对于某些只用括号不能转换的类型时（String→int）需要<strong>调用要转换为的类型所在的类</strong>进行转换，如</p>
<p>新类型.parse新类型（变量名）;<br>Int.parseInt(x);<br>Double.parseDouble(x);</p>
<p>注意这里类型<strong>首字母要大写</strong></p>
<h1 id="③运算符"><a href="#③运算符" class="headerlink" title="③运算符"></a>③运算符</h1><p>运算符和C#都一样，但是需要特别注意的是，不管是Java、C、C#、Python还是C++，<strong>浮点类型都不可判断相等！</strong> 像这样：</p>
<p>float a=1.5;<br>float b=0.7+0.8;<br>if(<strong>b==a</strong>)<br>{<br>  System.out.println(“A and B is Equal”);<br>}<br>else<br>{<br>  System.out.println(“A and B is Different”);<br>}</p>
<p>这可万万使不得！<a href="http://upane.cn/archives/220/attachment/28"><img src="http://47.94.231.166/wp-content/uploads/2018/04/28.png" alt=""></a> 因为转换丢失，精度会有误差，相等的俩数也会显式不相等！ 要想比较两个浮点数可以<strong>让它们相减求精度</strong>。   逻辑运算符相同不讲。</p>
<h2 id="位运算符："><a href="#位运算符：" class="headerlink" title="位运算符："></a>位运算符：</h2><p>位运算符虽然和C#相同，但是在学C#的时候就没怎么认真学过，在这里再复习一下吧： 位运算符是对<strong>位（bit）</strong>进行运算的符号，就是二进制数。在使用位运算符之后程序会先将两边的值转换为二进制，然后进行运算。</p>
<p>运算符</p>
<p>含义</p>
<p>示例</p>
<p>~</p>
<p>按位非（NOT）</p>
<p>~a</p>
<p>&amp;</p>
<p>按位与（AND）</p>
<p>a&amp;b</p>
<p>¦</p>
<p>按位或（OR）</p>
<p>a¦b</p>
<p>^</p>
<p>按位异或（XOR）</p>
<p>a^b</p>
<p>¦</p>
<p>按位或（OR）</p>
<p>a¦b</p>
<p>>&gt;</p>
<p>右移x位（位数不变，整体右移，低位丢弃，最高位用原最高位补充）</p>
<p>a&gt;&gt;x</p>
<p>>&gt;&gt;</p>
<p>无符号右移x位（位数不变，整体右移，最高位用0补充）</p>
<p>a&gt;&gt;&gt;x</p>
<p>&lt;&lt;</p>
<p>左移x位（位数不变，整体左移，高位丢弃，最低位用0补充）</p>
<p>a&lt;</p>
<h1 id="④数组"><a href="#④数组" class="headerlink" title="④数组"></a>④数组</h1><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><p>数组的定义都是一样的，就是注意定义二维数组的时候还可以利用<strong>分别实例化</strong>定义<strong>不规则的二维数组</strong>，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> [][]x;</span><br><span class="line">x=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">x[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1.1</span>,<span class="number">1.2</span>&#125;;</span><br><span class="line">x[<span class="number">1</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]&#123;<span class="number">2.1</span>,<span class="number">2.2</span>;<span class="number">2.3</span>,<span class="number">2.4</span>&#125;;</span><br><span class="line">x[<span class="number">2</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">3.1</span>,<span class="number">3.2</span>,<span class="number">3.3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>图例如下：</p>
<p>1.1</p>
<p>1.2</p>
<p>2.1</p>
<p>2.2</p>
<p>2.3</p>
<p>2.4</p>
<p>3.1</p>
<p>3.2</p>
<p>3.3</p>
<p>这里<strong>x.length=3</strong>,<strong>x[0].length=2</strong>。</p>
<h2 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h2><p>我们先定义一种说法，即<strong>虚复制</strong>和<strong>实复制</strong>，虚复制是指仅复制引用变量的内存地址，当一个发生改变另一个也会改变，实复制是指复制了引用变量其中的值，一个发生改变后另一个不变。 目前有四种方法可以对数组进行复制：</p>
<h3 id="1-直接相等"><a href="#1-直接相等" class="headerlink" title="1.直接相等"></a>1.直接相等</h3><p>也就是array2=array1，这是一种<strong>虚复制</strong>。</p>
<h3 id="2-使用循环语句依次赋值"><a href="#2-使用循环语句依次赋值" class="headerlink" title="2.使用循环语句依次赋值"></a>2.使用循环语句依次赋值</h3><p>就是for(int i=0;i&lt;array1.length;i++)array2[i]=array1[i]; 这是一种<strong>实复制</strong>。</p>
<h3 id="3-使用clone-方法"><a href="#3-使用clone-方法" class="headerlink" title="3.使用clone()方法"></a>3.使用clone()方法</h3><p>即int array2=array1.clone(); 这是一种<strong>实复制</strong>。</p>
<h3 id="4-使用System-arraycopy-方法"><a href="#4-使用System-arraycopy-方法" class="headerlink" title="4.使用System.arraycopy()方法"></a>4.使用System.arraycopy()方法</h3><p>其用法为 System.arraycopy(&lt;数据类型&gt; 被复制的数组名,复制起始索引,&lt;数据类型&gt; 复制到的数组名,复制元素的数量); 如，从整型一维数组array1中的第3个元素开始复制5个元素到整型一维数组array2中，可写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.arraycopy(<span class="keyword">int</span> array1,<span class="number">2</span>,<span class="keyword">int</span> array2,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Java学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】抽象类作业</title>
    <url>/2018/11/16/%E3%80%90java%E3%80%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;Square:\nPlease enter the dim of Square:&quot;</span>);</span><br><span class="line">        Square square=<span class="keyword">new</span> Square(scanner.nextDouble());<span class="comment">//实例化正方形对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Area:&quot;</span>+square.callArea()+<span class="string">&quot;,Perimeter:&quot;</span>+square.callPerimeter());<span class="comment">//打印数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Rectangle:\nPlease enter the Width of Rectangle:&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> width=scanner.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;Please enter the Length of Rectangle:&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> length=scanner.nextDouble();<span class="comment">//实例化长方形对象</span></span><br><span class="line">        Rectangle rectangle=<span class="keyword">new</span> Rectangle(length,width);</span><br><span class="line">        System.out.println(<span class="string">&quot;Area:&quot;</span>+rectangle.callArea()+<span class="string">&quot;,Perimeter:&quot;</span>+rectangle.callPerimeter());<span class="comment">//打印数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span>//建立抽象类<span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dim;<span class="comment">//一个边长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(<span class="keyword">double</span> dim)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dim=dim;</span><br><span class="line">    &#125;<span class="comment">//使用构造函数初始化这条边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">callArea</span><span class="params">()</span></span>;<span class="comment">//建立抽象函数“求面积”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">callPerimeter</span><span class="params">()</span></span>;<span class="comment">//建立抽象函数“求周长”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span>//建立正方形类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">double</span> dim)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">callArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dim*dim;</span><br><span class="line">    &#125;<span class="comment">//实现求面积方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">callPerimeter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dim*<span class="number">4</span>;</span><br><span class="line">    &#125;<span class="comment">//实现求周长方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span>//建立矩形类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dim2;<span class="comment">//矩形有两条不一样长的边，故再建立一个字段存放第二条边的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> length,<span class="keyword">double</span> width)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(length);<span class="comment">//一条边由父类Shape的构造函数初始化</span></span><br><span class="line">        dim2=width;<span class="comment">//另一条边在此初始化</span></span><br><span class="line">    &#125;<span class="comment">//将两条边初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">callArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dim*dim2;</span><br><span class="line">    &#125;<span class="comment">//实现求面积的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">callPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (dim+dim2)*<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="comment">//实现求周长的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>课堂作业</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】类的继承实验：Student类</title>
    <url>/2018/11/10/%E3%80%90java%E3%80%91%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E9%AA%8C%EF%BC%9Astudent%E7%B1%BB/</url>
    <content><![CDATA[<a id="more"></a>
<p>11.24新增抛出异常练习</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student student=<span class="keyword">new</span> Student();<span class="comment">//实例化一个学生对象</span></span><br><span class="line">        String name,dep;</span><br><span class="line">        <span class="keyword">int</span> age;<span class="comment">//声明三个必要变量，为传入函数值做准备</span></span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> Scanner(System.in);<span class="comment">//声明一个得到用户输入文字的功能对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生姓名：&quot;</span>);<span class="comment">//提示语</span></span><br><span class="line">        name=scanner.next();<span class="comment">//得到用户输入的一段字符串，并将其赋给name</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生年龄：&quot;</span>);</span><br><span class="line">        age=scanner.nextInt();<span class="comment">//得到用户输入的一段整形数字，并将其赋给age</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生院系：&quot;</span>);</span><br><span class="line">        dep=scanner.next();</span><br><span class="line"></span><br><span class="line">        student.setNameAgeDep(name,age,dep);<span class="comment">//调用函数设置学生的信息</span></span><br><span class="line">        student.show();<span class="comment">//调用函数显示学生信息</span></span><br><span class="line">        System.out.println(student);<span class="comment">//直接打印出学生对象（隐式调用toString函数）</span></span><br><span class="line">        Student student2=<span class="keyword">new</span> Student();<span class="comment">//设置第二个学生对象用户比对学生姓名</span></span><br><span class="line">        student2.setNameAgeDep(<span class="string">&quot;AAA&quot;</span>,<span class="number">20</span>,<span class="string">&quot;Information&quot;</span>);<span class="comment">//设置第二个学生的信息</span></span><br><span class="line">        <span class="keyword">if</span>(student.equals(student2))System.out.println(<span class="string">&quot;学生重名&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;学生不重名&quot;</span>);<span class="comment">//比较学生是否重名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//人“类”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//包含字段姓名与年龄</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置姓名与年龄的访问器，如不需要重写toString与equals函数则不需要设置</span></span><br><span class="line">    <span class="comment">//应尽量避免对父类的改动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示目前类的调用情况</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了个人构造方法Person()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置人“类”的姓名与年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetNameAge</span><span class="params">(String name,<span class="keyword">int</span> age)</span><span class="keyword">throws</span> AgeException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">if</span>(age&lt;=<span class="number">0</span>age&gt;=<span class="number">25</span>)<span class="keyword">throw</span> <span class="keyword">new</span> AgeException();</span><br><span class="line">        <span class="comment">//设置学生年龄不得小于0，或大于25。若超过此值，则抛出异常。以下赋值语句将失效。</span></span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示人“类”的姓名与年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;，年龄：&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类，继承自人“类”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//派生类新字段：院系</span></span><br><span class="line">    <span class="keyword">private</span> String dep;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置学生的名字、年龄、所在院系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNameAgeDep</span><span class="params">(String name,<span class="keyword">int</span> age,String dep)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">super</span>.SetNameAge(name,age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AgeException e) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\nYou type a worng age info.\n&quot;</span>);</span><br><span class="line">        &#125;<span class="comment">//捕获异常AgeException，并提示用户输入错误。</span></span><br><span class="line">        <span class="keyword">this</span>.dep=dep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提示调用类的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;也调用了学生构造方法Student()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示学生信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;院系：&quot;</span> + dep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写toString函数，使对象可被直接输出为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;学生姓名为&quot;</span>+getName()+<span class="string">&quot;，年龄为&quot;</span>+getAge()+<span class="string">&quot;，院系为&quot;</span>+dep+<span class="string">&quot;。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写equals函数，使之能比较学生姓名是否相等（即检测学生重名情况）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Student student)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(getName().equals(student.getName()))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgeException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">(String msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">(Throwable cause)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">(String msg,Throwable cause)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span> (msg,cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>课堂作业</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】可连续计算的整数计算器</title>
    <url>/2018/12/08/%E3%80%90java%E3%80%91%E8%AE%A1%E7%AE%97%E5%99%A8%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p><strong>先说思路：在主页面里添加两个控件：顶部的文本框和下方承载按钮的面板控件，然后在下方的面板控件中依次填入按钮。</strong> 但是这里还有一个问题就是如何填入大量的按钮。16个按钮一个一个实例化再填入将会造成较大的工作量，但是像课本中那样写个名字数组再一股脑地实例化又会破坏语义性，在后期我们绑定事件时造成非常大的麻烦。为了在其中找到一个折中点，<strong>我们选用数字按钮使用数组实例化，而功能按钮（加减乘除等）单独实例化。</strong><br><a id="more"></a><br><a href="http://upane.cn/wp-content/uploads/2018/12/java_2018-12-19_11-16-37.png"><img src="http://upane.cn/wp-content/uploads/2018/12/java_2018-12-19_11-16-37.png" alt=""></a> 注意看图，数字是倒序显示的，所以不要忘了在保存插入顺序的数组中倒序插入数字按钮。 <strong>内部逻辑：创立四个变量，用于存储第一个操作数（被加数/被减数/被乘数/被除数）、第二个操作数（加数/减数/乘数/除数）、运算符号（char）、判断目前操作数的Boolean判断值。 判断值初始化为False，表示操作第一个操作数，按下的数字将存储于此，按下运算符后，存储运算符号并改变判断值，移动到第二个操作数，等待用户输入。按下等于号后，判断运算符号并进行相应运算。</strong> 上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> firstnum;<span class="comment">//第一个操作数</span></span><br><span class="line">    <span class="keyword">int</span> secondnum;<span class="comment">//第二个操作数</span></span><br><span class="line">    <span class="keyword">char</span> func;<span class="comment">//存储计算符号</span></span><br><span class="line">    <span class="keyword">boolean</span> isFirstnum=<span class="keyword">true</span>;<span class="comment">//存储是否已为第一个操作数赋值</span></span><br><span class="line">    TextField textField;<span class="comment">//存储显示框，否则子类无法得到值</span></span><br><span class="line"></span><br><span class="line">    MainWindow(String title)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(title);<span class="comment">//调用JFrame的构造函数为窗口标题赋值</span></span><br><span class="line">        initializeWindow();<span class="comment">//初始化窗口</span></span><br><span class="line">        initializeControls();<span class="comment">//初始化控件</span></span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);<span class="comment">//设置窗口可见性 每次设置可见性时系统刷新窗口</span></span><br><span class="line">        <span class="comment">// 如果在这之前设置可见性会导致后面添加的控件知道界面再次刷新时才可见</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化窗口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">initializeWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">400</span>,<span class="number">200</span>);<span class="comment">//设置窗口大小</span></span><br><span class="line">        <span class="keyword">this</span>.setLocation(<span class="number">400</span>,<span class="number">400</span>);<span class="comment">//设置窗口首次出现的位置</span></span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<span class="comment">//设置用户点击退出时的策略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化窗口内部的控件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeControls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JButton[] buttons=<span class="keyword">new</span> JButton[<span class="number">10</span>];<span class="comment">//建立一个数组，用来存放数字按钮</span></span><br><span class="line">        JButton[] order = <span class="keyword">new</span> JButton[<span class="number">16</span>];<span class="comment">//建立一个数组，用来存放按钮在表格中的插入顺序</span></span><br><span class="line">        JPanel mainjp = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> BorderLayout());<span class="comment">//实例化主窗口（承载边界停靠面板）的面板</span></span><br><span class="line">        JPanel buttonjp = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">4</span>, <span class="number">4</span>));<span class="comment">//实例化存放按钮（承载表格面板）的面板</span></span><br><span class="line">        textField = <span class="keyword">new</span> TextField();<span class="comment">//实例化文本框</span></span><br><span class="line">        textField.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        mainjp.add(textField, BorderLayout.NORTH);<span class="comment">//将文本框固定在主窗口面板的上方</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</span><br><span class="line">            buttons[i] = <span class="keyword">new</span> JButton(Integer.toString(i));<span class="comment">//实例化数字按钮，并为其显示内容赋值</span></span><br><span class="line">            buttons[i].addActionListener(<span class="keyword">new</span> NumEventListener());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) order[i] = buttons[buttons.length - i - <span class="number">1</span>];<span class="comment">//将数字按钮以倒序插入表格的插入顺序中（显示顺序为9→0）</span></span><br><span class="line">        JButton addition = <span class="keyword">new</span> JButton(<span class="string">&quot;+&quot;</span>);<span class="comment">//实例化控制按钮“加”，并为其显示内容赋值</span></span><br><span class="line">        addition.addActionListener(<span class="keyword">new</span> FuncEventListener());</span><br><span class="line">        order = insert(order, addition, <span class="number">3</span>);<span class="comment">//将其插入到表格插入顺序数组索引为3的位置（第一行最右边），以下同</span></span><br><span class="line">        JButton subtraction = <span class="keyword">new</span> JButton(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        subtraction.addActionListener(<span class="keyword">new</span> FuncEventListener());</span><br><span class="line">        order = insert(order, subtraction, <span class="number">7</span>);</span><br><span class="line">        JButton multiplication = <span class="keyword">new</span> JButton(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        multiplication.addActionListener(<span class="keyword">new</span> FuncEventListener());</span><br><span class="line">        order = insert(order, multiplication, <span class="number">11</span>);</span><br><span class="line">        JButton clear = <span class="keyword">new</span> JButton(<span class="string">&quot;AC&quot;</span>);</span><br><span class="line">        <span class="comment">//=========================================动作：按下AC按钮清空输入内容==============================================</span></span><br><span class="line">        clear.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                firstnum=<span class="number">0</span>;</span><br><span class="line">                secondnum=<span class="number">0</span>;</span><br><span class="line">                isFirstnum=<span class="keyword">true</span>;</span><br><span class="line">                textField.setText(<span class="string">&quot;&quot;</span>);<span class="comment">//还原各值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        order = insert(order, clear, <span class="number">13</span>);</span><br><span class="line">        JButton equal = <span class="keyword">new</span> JButton(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="comment">//========================================动作：按下等于按钮计算结果=================================================</span></span><br><span class="line">        equal.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (func)<span class="comment">//判断符号，运算出结果</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :textField.setText(String.valueOf(firstnum+secondnum));<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :textField.setText(String.valueOf(firstnum-secondnum));<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :textField.setText(String.valueOf(firstnum*secondnum));<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :textField.setText(String.valueOf(firstnum/secondnum));<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                isFirstnum=<span class="keyword">true</span>;<span class="comment">//还原输入数字的位置，以便连续计算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//=================================================================================================================</span></span><br><span class="line">        order = insert(order, equal, <span class="number">14</span>);</span><br><span class="line">        JButton division = <span class="keyword">new</span> JButton(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        division.addActionListener(<span class="keyword">new</span> FuncEventListener());</span><br><span class="line">        order = insert(order, division, <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">for</span> (JButton button : order) buttonjp.add(button);<span class="comment">//以面板插入顺序数组的索引顺序为按钮面板添加按钮</span></span><br><span class="line">        mainjp.add(buttonjp, BorderLayout.CENTER);<span class="comment">//将按钮面板固定在主界面的中心</span></span><br><span class="line">        <span class="keyword">this</span>.add(mainjp);<span class="comment">//将主界面添加到该窗口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为插入数组而写的算法，将某个元素插入数组的某个位置，该位置后的元素依次后移</span></span><br><span class="line">    <span class="comment">//传入值为操作的数组、插入的元素、插入元素的索引，返回值为修改完毕的数组</span></span><br><span class="line">    <span class="keyword">private</span> JButton[] insert(JButton[] order, JButton newbutton, <span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//元素按照索引顺序依次后移一位，直到检测到索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = order.length - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">            order[i] = order[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        order[index] = newbutton;<span class="comment">//将索引位置的元素替换为新元素</span></span><br><span class="line">        <span class="keyword">return</span> order;<span class="comment">//返回修改后的数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数字按钮的按下动作</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NumEventListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            JButton button=(JButton)e.getSource();<span class="comment">//得到被按下的按钮</span></span><br><span class="line">            textField.setText(textField.getText() + button.getText());<span class="comment">//连续添加数字，以得到多位数字</span></span><br><span class="line">            <span class="keyword">if</span> (isFirstnum) firstnum = Integer.parseInt(textField.getText());<span class="comment">//判断输入的位置</span></span><br><span class="line">            <span class="keyword">else</span> secondnum = Integer.parseInt(textField.getText());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//功能按钮（运算符号）的按下动作</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FuncEventListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            JButton button=(JButton)e.getSource();<span class="comment">//得到被按下的按钮</span></span><br><span class="line">            func=button.getText().charAt(<span class="number">0</span>);<span class="comment">//将按钮代表的符号存到func变量</span></span><br><span class="line">            isFirstnum=<span class="keyword">false</span>;<span class="comment">//移动输入位置到第二个操作数</span></span><br><span class="line">            firstnum=Integer.parseInt(textField.getText());<span class="comment">//将目前的值存入第一个操作数，以便连续运算</span></span><br><span class="line">            textField.setText(<span class="string">&quot;&quot;</span>);<span class="comment">//清空显示框的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>课堂作业</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】js学习小笔记 1#</title>
    <url>/2019/04/21/%E3%80%90js%E3%80%91js%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>你捡起了道具：<strong>遗失的纸片1#</strong> 一张普通的纸片，隐隐约约能够看到目录：“<strong>js的输出形式、基本语法、字面量和变量、标识符、js中的数据类型</strong>”。边角还有被撕扯的痕迹，它们应该属于一个笔记本，但不知为什么被主人撕下来丢掉了。 提示：集齐所有纸片应该可以得到一本技能书。 👇点击下方按钮调查<br><a id="more"></a></p>
<h2 id="1-js的输出形式"><a href="#1-js的输出形式" class="headerlink" title="1.js的输出形式"></a>1.js的输出形式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">//弹出警告框</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">//向body中输出一个内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello World&quot;</span>)<span class="comment">//像控制台中输出内容</span></span><br></pre></td></tr></table></figure>
<h2 id="2-js编写的位置"><a href="#2-js编写的位置" class="headerlink" title="2.js编写的位置"></a>2.js编写的位置</h2><ol>
<li>可将js代码编写到标签的<code>onclick</code>标签中</li>
<li>可将js代码编写在超链接的<code>href</code>属性中，点击时执行 例：<code>href=&quot;javascript:alert(&#39;Say somthing&#39;);&quot;</code></li>
<li>写在<code>script</code>标签中</li>
<li>外部文件通过<code>script</code>标签引入<code>src=&quot;外部文件地址&quot;</code>（可在不同页面同时引用，也可利用到浏览器的缓存机制，<strong>推荐使用</strong>），<code>script</code>标签一旦引入外部文件则无法编写代码，但可以再写一个标签。</li>
</ol>
<h2 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3.基本语法"></a>3.基本语法</h2><ol>
<li>注释：与C#相同，没有三斜杠</li>
<li><strong>js严格区分大小写</strong></li>
<li><strong>js中每一条语句以分号结尾</strong>，如不写分号浏览器会自动添加，但会影响性能有时还可能加错分号</li>
<li>js中会忽略多个空格和换行</li>
</ol>
<h2 id="4-字面量和变量"><a href="#4-字面量和变量" class="headerlink" title="4.字面量和变量"></a>4.字面量和变量</h2><ol>
<li><strong>字面量→值（“a”、“你好”、1535……）</strong></li>
<li>字面量都是可直接使用的，但一般不直接使用</li>
<li>变量可保存字面量，且值可变</li>
<li>声明变量：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>
<h2 id="4-标识符"><a href="#4-标识符" class="headerlink" title="4.标识符"></a>4.标识符</h2><p><strong>在js中，所有可以由我们自主命名的都可以成为标识符</strong>，例：变量名、函数名、属性名……</p>
<h3 id="规则（与C-类似）："><a href="#规则（与C-类似）：" class="headerlink" title="规则（与C#类似）："></a>规则（与C#类似）：</h3><ol>
<li>可含字母、数字、_、$</li>
<li>标识符不能以数字开头</li>
<li>标识符不能是ES中的关键字或保留字</li>
<li><strong>标识符一般采用camel命名法</strong></li>
</ol>
<p><strong>js底层保存标识符时实际上是采用unicode编码，故理论上所有utf-8字符均可作为标识符</strong></p>
<h2 id="6-js中的数据类型"><a href="#6-js中的数据类型" class="headerlink" title="6.js中的数据类型"></a>6.js中的数据类型</h2><ol>
<li>string 字符串</li>
<li>number 数值</li>
<li>boolean 布尔值</li>
<li>null 空值</li>
<li>undiefined 未定义</li>
<li>object 对象</li>
</ol>
<p>除6.object为<strong>引用数据类型</strong>外，其他均为<strong>基本数据类型</strong>。</p>
<ol>
<li>字符串<code>var str=&quot;hello&quot;;</code><strong>单/双引号均可</strong></li>
<li>js也使用“/”转义</li>
<li>如果number表示的数字超过了最大值，则返回<strong><code>infinity</code>/<code>-infinity</code></strong></li>
<li><code>NaN</code>也是一个数字，代表<strong>“Not a Number”——非数字</strong></li>
<li>若用js进行浮点运算，可能得到一个不精确的结果</li>
<li><code>null</code>表示为<strong>空对象</strong> <code>undefined</code>表示<strong>一个声明但未定义的变量</strong></li>
</ol>
]]></content>
      <categories>
        <category>web</category>
        <category>JavaScript</category>
        <category>Web</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】js学习小笔记 2#</title>
    <url>/2019/04/22/%E3%80%90js%E3%80%91js%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>你捡起了道具：<strong>遗失的纸片2#</strong> 一张普通的纸片，隐隐约约能够看到目录：“<strong>强制类型转换、运算符、语句、对象、函数、作用域</strong>”。边角还有被撕扯的痕迹，它们应该属于一个笔记本，但不知为什么被主人撕下来丢掉了。 提示：集齐所有纸片应该可以得到一本技能书。 👇点击下方按钮调查<br><a id="more"></a></p>
<h2 id="7-强制类型转换"><a href="#7-强制类型转换" class="headerlink" title="7.强制类型转换"></a>7.强制类型转换</h2><h3 id="转string"><a href="#转string" class="headerlink" title="转string:"></a>转<code>string</code>:</h3><ol>
<li><strong>直接调用被转换对象的<code>toString()</code>方法</strong>，该方法不会影响原值，会将转换后的结果返回。<strong><code>null</code>与<code>undefined</code>无<code>toString()</code>方法。</strong></li>
<li><strong>调用<code>String()</code>函数</strong>，并将被转换的变量作为参数传入，<strong>使用<code>String()</code>函数转换时，<code>null</code>→”null”,<code>undefined</code>→”undefined”。</strong></li>
</ol>
<h3 id="转Number"><a href="#转Number" class="headerlink" title="转Number:"></a>转<code>Number</code>:</h3><ol>
<li>使用<code>Number()</code>函数</li>
</ol>
<p>？→数值</p>
<p>转换结果</p>
<p>字符串</p>
<p>非纯数字转换为<code>NaN</code>，空值/空格转换为0</p>
<p>布尔</p>
<p>true→1，false→0</p>
<p>null</p>
<p>0</p>
<p>undefined</p>
<p><code>NaN</code></p>
<p>2.使用<code>parseInt()</code>/<code>parseFloat()</code>将字符串转换为整型/浮点型 <strong>该方法可去除字符串中非数字部分</strong> <strong>原理：读到第一个非数字位，往后都忽略</strong></p>
<blockquote>
<p>“123px”→123 “123px456”→123”123.5”→123</p>
</blockquote>
<p><strong>如果对非String使用<code>parseInt()</code>/<code>parseFloat()</code>，会先转为<code>String</code>，再转为<code>Number</code>，如</strong></p>
<blockquote>
<p>true→”true”→NaN 123.5→”123.5”→123 所以<code>parseInt()</code>也有取整的作用</p>
</blockquote>
<p>3.其他进制数字</p>
<p>进制</p>
<p>命名规定</p>
<p>Hex</p>
<p>0x??</p>
<p>Oct</p>
<p>0??</p>
<p>Bin</p>
<p>0B??</p>
<p>像“070”这种字符串有的浏览器会当成八进制解析</p>
<blockquote>
<p>明确制定进制：parseInt(a,10)可向<code>parseInt()</code>传两个参数，第二个参数表示进制。</p>
</blockquote>
<h3 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean:"></a>转<code>Boolean</code>:</h3><p>使用<code>Boolean()</code>参数：</p>
<p>？→Boolean</p>
<p>转换结果</p>
<p>数字</p>
<p>除了0和<code>NaN</code>，其他都是true</p>
<p>字符串</p>
<p>除了空串，其他都是true</p>
<p>对象</p>
<p>true</p>
<p>null/undefined</p>
<p>false</p>
<h3 id="unicode转换："><a href="#unicode转换：" class="headerlink" title="unicode转换："></a>unicode转换：</h3><ol>
<li>JS：<strong>\\u+unicode(四位16进制编码)</strong></li>
<li>HTML：<strong>&amp;#+unicode(十进制编码)</strong></li>
</ol>
<h2 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8.运算符"></a>8.运算符</h2><p>运算符</p>
<p>运算法则</p>
<p>隐式转换</p>
<p>+</p>
<p>①NaN与任何数运算都得NaN②亦可字符串合并③任何值与字符串相加都转为字符串合并</p>
<p>是</p>
<p>-、*、/……</p>
<p>任何值都转换为Number参与运算</p>
<p>是</p>
<p>+(正)、-(负)</p>
<p>非Number值先转为Number，再求正/反</p>
<p>是</p>
<p>!、||、&amp;&amp;</p>
<p>先转为布尔值，再进行逻辑运算，且返回原值，而不是bool变量</p>
<p>是</p>
<p>-</p>
<p>与：第一个为true，则必然返回第二个；第一个为false，则必然返回第一个（找false）</p>
<p>-</p>
<p>或：第一个为true，则必然返回第一个，第一个为false，则必然返回第二个（找true）</p>
<p>>/\\&lt;</p>
<p>①非数值比较时将其转换为数值②任何值与NaN比较都是false③如果富豪两侧都是字符串，则不会转成数字而是转成相应的字符，使用unicode编码（一位一位比，两位一样就比下一位，直至比出结果）→比较字符串时一定要转型</p>
<p>是</p>
<p>\==/!=</p>
<p>①undefined衍生自null，所以相等②NaN不与任何值相等，包括它本身③判断是否为NaN：<code>isNaN()</code>函数</p>
<p>是</p>
<p>\===</p>
<p>全等→不做类型转换，类型不同的直接返回false</p>
<p>否</p>
<p>!==</p>
<p>不全等→不做类型转换，类型相同直接返回false</p>
<p>否</p>
<h2 id="9-语句"><a href="#9-语句" class="headerlink" title="9.语句"></a>9.语句</h2><p>自上向下执行，可用{}对其分组。 同一个{}称一组语句，要么都执行要么都不执行，一个{}称代码块，{}只有分组作用，不能隔离语句</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>语句</p>
<p>语法</p>
<p>注释</p>
<p>条件</p>
<p>if(?){A}else{B}</p>
<p>-</p>
<p>条件分支</p>
<p>switch(?){case 表达式：语句 break;……..default:语句}</p>
<p>case后是<strong>全等判断</strong></p>
<p>循环</p>
<p>while(条件表达式){语句}/for(初始化表达式;条件表达式;更新表达式){}</p>
<p>每次循环前先对条件表达式进行判断，<strong>若为true</strong>则进入循环体</p>
<h2 id="10-对象"><a href="#10-对象" class="headerlink" title="10.对象"></a>10.对象</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>内建对象：<strong>由ES标准中定义的对象</strong>，在任何ES实现中都可使用（Math、String等）</li>
<li>宿主对象：<strong>由JS运行环境提供的对象</strong>，目前来讲指浏览器提供的对象，如BOM、DOM</li>
<li>自定义对象：<strong>开发者自己创建的对象</strong></li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="方法一：声明后设置属性"><a href="#方法一：声明后设置属性" class="headerlink" title="方法一：声明后设置属性"></a>方法一：声明后设置属性</h4><p>step1.实例化对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>step2.在对象中添加属性&amp;方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">obj.gender=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">obj.age=<span class="number">18</span>;</span><br><span class="line">obj.fun=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>step3.读取属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br></pre></td></tr></table></figure>
<p><strong>如果读取对象中未定义的属性，不会报错，返回undefined</strong></p>
<h4 id="方法二：声明时设置属性"><a href="#方法二：声明时设置属性" class="headerlink" title="方法二：声明时设置属性"></a>方法二：声明时设置属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    gender:<span class="string">&quot;男&quot;</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    fun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用该方法声明对象时<strong>属性名</strong>的引号可加可不加，但使用特殊名时必须加。 属性与值之间使用“:”链接，各属性用“,”连接，结尾属性不加“,”。</p>
<h3 id="属性名-值"><a href="#属性名-值" class="headerlink" title="属性名/值"></a>属性名/值</h3><p>属性名：对象的属性名不强制使用命名规范，但若使用不符合命名规范的名称，调用属性时应使用<code>对象[属性名]</code>的方法，此处obj[name]=obj.name,但特殊命名无法使用点调用。<strong>中括号里也可以传入变量</strong> 属性值:可以是任意值，包括对象。</p>
<h3 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h3><p>检查一个对象中有无规定属性，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="string">&quot;test&quot;</span> <span class="keyword">in</span> obj)</span><br></pre></td></tr></table></figure>
<p>→检查obj对象中有无“test”属性</p>
<h2 id="11-函数"><a href="#11-函数" class="headerlink" title="11.函数"></a>11.函数</h2><blockquote>
<p>函数也是一个对象</p>
</blockquote>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="方法一：声明函数对象（不常用）"><a href="#方法一：声明函数对象（不常用）" class="headerlink" title="方法一：声明函数对象（不常用）"></a>方法一：声明函数对象（不常用）</h4><p>step1.创建一个函数对象，可以将要封装的代码以字符串的形式传递给构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;console.log(&#x27;Hello&#x27;);&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>step2.调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fun();</span><br></pre></td></tr></table></figure>
<h4 id="方法二：使用函数声明创建函数"><a href="#方法二：使用函数声明创建函数" class="headerlink" title="方法二：使用函数声明创建函数"></a>方法二：使用函数声明创建函数</h4><blockquote>
<p>function 函数名([形参1,形参2….]) { 语句… }</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法三：使用函数表达式创建函数"><a href="#方法三：使用函数表达式创建函数" class="headerlink" title="方法三：使用函数表达式创建函数"></a>方法三：使用函数表达式创建函数</h4><blockquote>
<p>var 函数名=function([形参1,形参2….]) { 语句… }</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>函数不会检查参数的数量，<strong>未赋值的形参将初始化为undefined</strong></p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>使用<code>return</code>设置返回值，return后的语句不会执行。 <strong><code>return</code>后不接任何值，或者没有<code>return</code>语句函数将返回undefined</strong></p>
<h3 id="执行匿名函数（立即执行）"><a href="#执行匿名函数（立即执行）" class="headerlink" title="执行匿名函数（立即执行）"></a>执行匿名函数（立即执行）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;我是匿名函数&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>第一个括号代表函数是一整个对象，后面括号将其执行→<strong>对象()</strong></p>
<h3 id="for…in语句"><a href="#for…in语句" class="headerlink" title="for…in语句"></a>for…in语句</h3><p>与for联用，与C#相似。 打印obj对象中所有的属性名与属性值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printObject</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> n <span class="keyword">in</span> obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n+<span class="string">&quot;:&quot;</span>+obj[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-作用域"><a href="#12-作用域" class="headerlink" title="12.作用域"></a>12.作用域</h2><blockquote>
<p>指一个变量的作用范围</p>
</blockquote>
<p>在JS中，有两种作用域：<strong>①全局作用域②函数作用域</strong></p>
<h3 id="①全局作用域"><a href="#①全局作用域" class="headerlink" title="①全局作用域"></a>①全局作用域</h3><p>创建方法：<strong>直接写在<code>script</code>标签下</strong> 生命周期：在页面打开时创建，页面关闭时销毁 调用方法：全局作用域中有个全局对象<code>window</code>可使用，其由浏览器创建。在全局作用域中创建的变量都会作为<code>window</code>的属性保存，创建的函数都会作为<code>window</code>的方法保存。</p>
<h4 id="变量的声明提前："><a href="#变量的声明提前：" class="headerlink" title="变量的声明提前："></a>变量的声明提前：</h4><p><code>var</code>声明的变量会在所有代码执行之前被声明，<strong>但不会被赋值</strong></p>
<h4 id="函数的声明提前："><a href="#函数的声明提前：" class="headerlink" title="函数的声明提前："></a>函数的声明提前：</h4><ul>
<li>使用函数声明形式创建的函数（<code>function 函数() &#123;&#125;</code>）<strong>会在所有代码执行之前就被创建，所以我们可以在创建声明前来调用</strong></li>
<li>使用函数表达式（<code>var fun=function()&#123;&#125;</code>）创建的函数不会被提前创建，<strong>不能提前调用</strong></li>
</ul>
<h3 id="②函数作用域"><a href="#②函数作用域" class="headerlink" title="②函数作用域"></a>②函数作用域</h3><p>生命周期：调用函数时创建函数作用域，函数执行完毕后作用域销毁 <strong>多函数作用域相互独立，函数作用域可访问全局作用域</strong> 函数操作变量时，先在自己作用域中找，找不到再去上一级作用域中找。<strong>若要直接使用全局作用域可以通过window对象的属性调用</strong></p>
]]></content>
      <categories>
        <category>web</category>
        <category>JavaScript</category>
        <category>Web</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】js学习小笔记 4#</title>
    <url>/2019/05/08/%E3%80%90js%E3%80%91js%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%AC%94%E8%AE%B0-4/</url>
    <content><![CDATA[<p>你捡起了道具：<strong>遗失的纸片4#</strong> 一张普通的纸片，隐隐约约能够看到目录：“<strong>DOM、DOM练习、使用DOM操作CSS</strong>”。边角还有被撕扯的痕迹，它们应该属于一个笔记本，但不知为什么被主人撕下来丢掉了。 提示：集齐所有纸片应该可以得到一本技能书。 👇点击下方按钮调查<br><a id="more"></a></p>
<h2 id="26-DOM"><a href="#26-DOM" class="headerlink" title="26.DOM"></a>26.DOM</h2><ol>
<li>Dom→Document Object Model文档对象模型</li>
<li>Js中通过Dom来对HTML文档进行操作，只要理解了Dom就可以随心所欲的操作Web页面 <strong>名词注解：</strong><ol>
<li>文档：整个HTML网页文档</li>
<li>对象:将王爷的每个部分都转换为了一个对象</li>
<li>模型：使用模型表示对象间的关系，这样方便我们获取对象</li>
</ol>
</li>
</ol>
<h3 id="①节点"><a href="#①节点" class="headerlink" title="①节点"></a>①节点</h3><h4 id="㈠Node"><a href="#㈠Node" class="headerlink" title="㈠Node"></a>㈠Node</h4><ol>
<li>构成网页的最基本组成部分，网页中的每个部分都可以成为一个节点(标题、超链接、属性、注释等)</li>
<li>虽然都是节点，但实际上他们的具体类型是不同的，如标签称为标签节点、属性称为属性节点、文本称为文本节点、文档成为文档节点 节点的类型不同，属性和方法也不尽相同</li>
</ol>
<h4 id="㈡常用节点及其属性"><a href="#㈡常用节点及其属性" class="headerlink" title="㈡常用节点及其属性"></a>㈡常用节点及其属性</h4><p>节点名称</p>
<p>nodeName</p>
<p>nodeType</p>
<p>nodeValue</p>
<p>含义</p>
<p>文档节点</p>
<h1 id="ducument"><a href="#ducument" class="headerlink" title="ducument"></a>ducument</h1><p>9</p>
<p>null</p>
<p>整个HTML文档</p>
<p>元素节点</p>
<p>标签名</p>
<p>1</p>
<p>null</p>
<p>文档中的HTML标签</p>
<p>属性节点</p>
<p>属性名</p>
<p>2</p>
<p>属性值</p>
<p>元素的属性</p>
<p>文本节点</p>
<h1 id="text"><a href="#text" class="headerlink" title="text"></a>text</h1><p>3</p>
<p>文本内容</p>
<p>HTML标签中的内容</p>
<h4 id="㈢入口"><a href="#㈢入口" class="headerlink" title="㈢入口"></a>㈢入口</h4><p>浏览器已经为我们提供文档节点对象，这个对象是window的属性，可以在页面中直接使用，文档节点代表的是整个网页→<strong>document</strong>对象</p>
<h4 id="㈣获取任意对象"><a href="#㈣获取任意对象" class="headerlink" title="㈣获取任意对象"></a>㈣获取任意对象</h4><p>获取对象： <code>documnet.getElementById()</code>→由id获取元素 获取节点内容： <code>innerHTML</code>属性可获得/修改某节点中的HTML代码</p>
<h3 id="②事件"><a href="#②事件" class="headerlink" title="②事件"></a>②事件</h3><ol>
<li>文档或浏览器发生的一些特定的交互瞬间</li>
<li>Js与HTML之间的交互是通过事件实现的</li>
<li>在时间对应的属性中设置一些Js代码，这样当事件被触发时，这些代码将会被执行</li>
<li>可为按钮的对应事件绑定处理函数的形式来相应事件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//响应函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="③文档的加载"><a href="#③文档的加载" class="headerlink" title="③文档的加载"></a>③文档的加载</h3><p>浏览器在加载一个页面时是自上而下加载的，读取一行就运行一行，若将script标签写到页面上边，在代码执行时页面还未加载，DOM对象未就绪 将script标签卸载页面下边就是为了在页面加载完毕后再执行Js代码</p>
<h4 id="必须写在前面？"><a href="#必须写在前面？" class="headerlink" title="必须写在前面？"></a>必须写在前面？</h4><p>window由onload事件，值页面执行完毕后出发，可将代码写在其中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*Js代码*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="④DOM查询"><a href="#④DOM查询" class="headerlink" title="④DOM查询"></a>④DOM查询</h3><h4 id="通过document对象调用："><a href="#通过document对象调用：" class="headerlink" title="通过document对象调用："></a>通过document对象调用：</h4><ol>
<li><code>getElementById()</code> 通过ID属性获取一个元素节点对象</li>
<li><code>getElementsByTagName()</code> 通过标签名获取<strong>一组</strong>元素节点对象</li>
<li><code>getElementsByName()</code> 通过name属性获取<strong>一组</strong>元素节点对象</li>
</ol>
<p><strong>读取元素节点属性：直接使用元素.属性名</strong> class不可用这种方式，读类名时使用<strong>元素.className</strong></p>
<h4 id="通过具体的元素节点调用："><a href="#通过具体的元素节点调用：" class="headerlink" title="通过具体的元素节点调用："></a>通过具体的元素节点调用：</h4><ol>
<li><code>getElementsByTagName()</code> 返回当前节点的指定标签名后代节点</li>
<li><code>childNodes</code> 属性，表示当前节点的所有子节点（包括文档节点）</li>
<li><code>firstChild</code> 属性，表示当前节点的第一个子节点</li>
<li><code>lastChild</code> 属性，表示当前节点的最后一个字节点 根据DOM标准，标签间的换行、空格也会被当作文本标签（<strong>IE8及以下浏览器未实现该标准</strong>）</li>
<li><code>children</code> 属性，可获取节点中的所有子元素（不包括文本节点）</li>
<li><code>parentNode</code> 属性，可获取当前节点的父节点</li>
<li><code>firstElementChild</code> 属性，获取第一个子元素（IE9+）</li>
<li><code>previousSilbling</code> 属性，获取当前节点的前一个兄弟节点</li>
<li><code>nextSilbling</code> 属性，获取当前节点的后一个兄弟节点 这两个属性也可能得到空白文本，可使用<code>previousElementSibling</code>和<code>nextElementSibling</code>解决（IE8+）</li>
<li><code>InnerHTML</code> 节点的内容 <code>innerText</code> 只获取元素内部的文本内容</li>
</ol>
<h3 id="⑤DOM查询的其他方法"><a href="#⑤DOM查询的其他方法" class="headerlink" title="⑤DOM查询的其他方法"></a>⑤DOM查询的其他方法</h3><ol>
<li>在document中有一个属性body，它保存的是body的引用</li>
<li><code>document.document</code> 保存的是HTML根标签</li>
<li><code>document.all</code> 代表所有元素，是个元素数组</li>
<li><code>document.getElementsByClass()</code> 根据class查询一组元素对象(IE9+) IE9及以下可用<code>querySelector()</code></li>
<li><code>document.querySelector()</code> 需要一个CSS选择器的字符串作为参数，可根据CSS选择器来查询一个元素对象，但使用该方法只会返回一个元素（第一个）（IE8+）</li>
<li><code>document.querySelectorAll()</code> 该方法和querySelector()用法类似，不同的是它将发符合条件的元素封装到一个数组中返回</li>
</ol>
<h3 id="⑥增删改DOM"><a href="#⑥增删改DOM" class="headerlink" title="⑥增删改DOM"></a>⑥增删改DOM</h3><h4 id="㈠添加节点"><a href="#㈠添加节点" class="headerlink" title="㈠添加节点"></a>㈠添加节点</h4><h5 id="创建元素节点"><a href="#创建元素节点" class="headerlink" title="创建元素节点"></a>创建元素节点</h5><p><code>document.createElement()</code> 可用于创建一个元素节点对象 它需要一个标签名作为参数，将会根据该标签名来创建元素节点对象并将创建好的对象作为返回值返回</p>
<h5 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h5><p><code>document.createTextNode()</code> 可以用来创建一个文本节点对象 需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新节点返回</p>
<h5 id="设置节点关系"><a href="#设置节点关系" class="headerlink" title="设置节点关系"></a>设置节点关系</h5><p><code>appendchild()</code> 像父节点中添加一个新的子节点 语法：<strong>父节点.appendChild(子节点);</strong></p>
<h4 id="㈡在指定的子节点前面插入新的子节点"><a href="#㈡在指定的子节点前面插入新的子节点" class="headerlink" title="㈡在指定的子节点前面插入新的子节点"></a>㈡在指定的子节点前面插入新的子节点</h4><p><strong>父节点.insertBefore(新节点,参照节点)；</strong></p>
<h4 id="㈢替换节点"><a href="#㈢替换节点" class="headerlink" title="㈢替换节点"></a>㈢替换节点</h4><p><strong>父节点.repaceChild(新节点,旧节点);</strong></p>
<h4 id="㈣删除节点"><a href="#㈣删除节点" class="headerlink" title="㈣删除节点"></a>㈣删除节点</h4><p>父节点.removeChild(子节点); <strong>子节点.parentNode.removeChild(子节点)</strong></p>
<h4 id="㈤使用innerHTML也可对DOM进行增删改"><a href="#㈤使用innerHTML也可对DOM进行增删改" class="headerlink" title="㈤使用innerHTML也可对DOM进行增删改"></a>㈤使用innerHTML也可对DOM进行增删改</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> li=<span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">li.innerHTML=<span class="string">&quot;广州&quot;</span>;</span><br><span class="line">city.appendChild(li);</span><br></pre></td></tr></table></figure>
<p>推荐如上的结合使用</p>
<h2 id="27-DOM练习"><a href="#27-DOM练习" class="headerlink" title="27.DOM练习"></a>27.DOM练习</h2><p>1.点击超链接以后，超链接会跳转页面，这个是超链接的默认行为，如果不希望出现默认行为可以通过在相应蛤属的最后<strong>return false</strong>来取消默认行为 以上是取消默认行为的通用方法，对于超链接还可以在为href添加属性值：<code>href=&quot;javascript:;&quot;</code>来取消默认行文，下文代码就是使用的这种方法 1. <code>confirm()</code>用于弹出一个<strong>带有确认和取消按钮</strong>的提示框，需要一个字符串作为参数，该字符创会作为提示文字显示出来，若用户点击确认，则返回true，否则返回false 1. 获取文本框的内容可用<code>文本框对象.value</code> 1. 为元素添加属性：<code>元素.属性=&quot;属性内容&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #emptable tr th, #emptable tr td &#123; border:1px solid black; &#125;</span><br><span class="line">        #emptable&#123;</span><br><span class="line">            border-collapse:collapse;</span><br><span class="line">        &#125;</span><br><span class="line">        #addtable&#123;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">        &#125;</span><br><span class="line">        div&#123;</span><br><span class="line">            margin: 50px;</span><br><span class="line">        &#125;</span><br><span class="line">        h3&#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;Script Here 代码见下框</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;empdiv&quot;&gt;</span><br><span class="line">    &lt;table id&#x3D;&quot;emptable&quot;&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;姓名&lt;&#x2F;th&gt;</span><br><span class="line">            &lt;th&gt;职位&lt;&#x2F;th&gt;</span><br><span class="line">            &lt;th&gt;月薪&lt;&#x2F;th&gt;</span><br><span class="line">            &lt;th&gt;&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;&#x2F;thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;潘总&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;首席执行官&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;50000&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href&#x3D;&quot;javascript:;&quot; id&#x3D;&quot;pan&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;张小鸟&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;职工&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;3500&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href&#x3D;&quot;javascript:;&quot; id&#x3D;&quot;zhang&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;&#x2F;tbody&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;adddiv&quot;&gt;</span><br><span class="line">    &lt;table id&#x3D;&quot;addtable&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;3&quot;&gt;&lt;h3&gt;添加新员工&lt;&#x2F;h3&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;姓名：&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;2&quot;&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;ename&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;职位：&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;2&quot;&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;ejob&quot;&gt;&lt;&#x2F;td&gt;                                                                                                                                                                              d&#x3D;&quot;ejob&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;月薪：&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;2&quot;&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;esal&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;button&gt;提交&lt;&#x2F;button&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;center&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//使用XPath获取超链接标签</span></span><br><span class="line">    <span class="comment">//var anodes=document.evaluate(&quot;//a&quot;, document, nullXPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);</span></span><br><span class="line">    <span class="comment">//for(i=0;i&lt;anodes.snapshotLength;i+anodes.snapshotItem(i).onclick=delEmp;</span></span><br><span class="line">    <span class="comment">//使用getElementsByTagName()获取超链接标签</span></span><br><span class="line">    <span class="keyword">var</span> nodes=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nodes.length;i++)nodes[i].onclick=delEmp;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">delEmp</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> empinfo=<span class="built_in">this</span>.parentNode.parentNode;</span><br><span class="line">        <span class="keyword">var</span> isDel=<span class="built_in">window</span>.confirm(<span class="string">&quot;你确定要删除职工+empinfo.children[0].innerHTML+&quot;</span>】吗？<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        if(isDel)</span></span><br><span class="line"><span class="string">            if(empinfo.children[0].innerHTML==&quot;</span>潘总<span class="string">&quot;)alert不成，潘总不能删！&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> empinfo.parentNode.removeChild(empinfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> button=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    button.onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name=<span class="built_in">document</span>.getElementById(<span class="string">&quot;ename&quot;</span>).value;</span><br><span class="line">        <span class="keyword">var</span> job=<span class="built_in">document</span>.getElementById(<span class="string">&quot;ejob&quot;</span>).value;</span><br><span class="line">        <span class="keyword">var</span> sal=<span class="built_in">document</span>.getElementById(<span class="string">&quot;esal&quot;</span>).value;</span><br><span class="line">        <span class="keyword">var</span> tr=<span class="built_in">document</span>.createElement(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">        tr.innerHTML=<span class="string">&quot;&lt;td&gt;&quot;</span>+name+<span class="string">&quot;&lt;/td&gt;&quot;</span>+</span><br><span class="line">                                    <span class="string">&quot;&lt;td&gt;&quot;</span>+job+<span class="string">&quot;&lt;/td&gt;&quot;</span>+</span><br><span class="line">                                    <span class="string">&quot;&lt;td&gt;&quot;</span>+sal+<span class="string">&quot;&lt;/td&gt;&quot;</span>+</span><br><span class="line">                                    <span class="string">&quot;&lt;td&gt;&lt;href=&#x27;javascript:;&#x27;&gt;&lt;/a&gt;&lt;/td&gt;&quot;</span></span><br><span class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;tbody&quot;</span>)[.appendChild(tr);</span><br><span class="line">        tr.getElementsByTagName(<span class="string">&quot;a&quot;</span>)[<span class="number">0</span>].onclick=delEmp;</span><br><span class="line">        <span class="built_in">document</span>.evaluate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>运行效果： <img src="https://www.z4a.net/images/2019/05/08/chrome_2019-05-08_10-59-26.png" alt=""> <img src="https://www.z4a.net/images/2019/05/08/2019-05-07_20-13-46.gif" alt=""></p>
<h2 id="28-使用DOM操作css"><a href="#28-使用DOM操作css" class="headerlink" title="28.使用DOM操作css"></a>28.使用DOM操作css</h2><h3 id="①设置样式"><a href="#①设置样式" class="headerlink" title="①设置样式"></a>①设置样式</h3><p><strong>元素.Style.样式名=样式值</strong> 注意，若CSS样式名中含有减号“-”，在Js中视为不合法，须将这种样式名修改为Camel命名法 1. 通过Style属性设置的样式是<strong>内联样式</strong>，其具有较高的优先级，往往立即显示 1. 如果样式中写了<code>!important</code>，则此时样式会有最高优先级，即使通过Js也不能覆盖该样式，此时将会导致Js修改样式失效，所以尽量不要为样式添加<code>!important</code></p>
<h3 id="②读取样式"><a href="#②读取样式" class="headerlink" title="②读取样式"></a>②读取样式</h3><h4 id="㈠元素-Style-样式名"><a href="#㈠元素-Style-样式名" class="headerlink" title="㈠元素.Style.样式名"></a>㈠元素.Style.样式名</h4><p>通过Style<strong>读取和设置</strong>的都是<strong>内联样式</strong>，无法读取样式表中的样式</p>
<h4 id="㈡元素-currentStyle-样式名（仅IE）"><a href="#㈡元素-currentStyle-样式名（仅IE）" class="headerlink" title="㈡元素.currentStyle.样式名（仅IE）"></a>㈡元素.currentStyle.样式名（仅IE）</h4><p><strong>以下方法都只读，不能改</strong> 它可以用来读取当前元素<strong>正显示</strong>的样式 若当前元素未设置样式，则获得<strong>默认样式</strong></p>
<h4 id="㈢getComputedSytle-（IE9-）"><a href="#㈢getComputedSytle-（IE9-）" class="headerlink" title="㈢getComputedSytle()（IE9+）"></a>㈢getComputedSytle()（IE9+）</h4><ol>
<li>window的方法，可直接使用</li>
<li>需要两个参数：<ol>
<li>要获取样式的元素</li>
<li>可传递一个伪元素 该方法会返回一个对象，其中封装了当前元素对应的样式，<strong>可通过“对象.样式名”来读取样式</strong></li>
</ol>
</li>
<li>如果获取的样式没有设置，则会获取到真实的值，而不是默认值。 如：未设置width，currentStyle返回auto，而getComputedStyle()返回实际对应长度</li>
</ol>
<h4 id="㈣自己定义一个全兼容的方法"><a href="#㈣自己定义一个全兼容的方法" class="headerlink" title="㈣自己定义一个全兼容的方法"></a>㈣自己定义一个全兼容的方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">obj,name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.getComputedStyle)<span class="keyword">return</span> getComputedStyle(obj,<span class="literal">null</span>)[name];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> obj.currentStyle[name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>参数：<ol>
<li>obj→元素对象</li>
<li>name→样式名</li>
</ol>
</li>
<li>判断语句if中判断式必须为<code>window.getComputedStyle</code>，不能只写getComputedStyle，否则若浏览器不支持getComputedStyle方法Js将会把JsgetComputedStyle是为变量，结果是抛出异常，程序不能正常运行</li>
<li>使用方括号传递样式名name，否则使用点将在返回值中寻找样式名为name的样式，进而无法返回正确值</li>
</ol>
<h3 id="③其他样式相关属性（均只读）"><a href="#③其他样式相关属性（均只读）" class="headerlink" title="③其他样式相关属性（均只读）"></a>③其他样式相关属性（均只读）</h3><h4 id="㈠元素-clientWindth-clientHeight"><a href="#㈠元素-clientWindth-clientHeight" class="headerlink" title="㈠元素.clientWindth/clientHeight"></a>㈠元素.clientWindth/clientHeight</h4><ol>
<li>这两个属性可以获取元素的可见宽度与高度</li>
<li>这两个属性都是不带px的，返回的都是一个数字，可以直接进行计算</li>
<li>获取元素的宽高，<strong>包括内容区和内边距</strong></li>
</ol>
<h4 id="㈡元素-offsetWidth-offsetHeight"><a href="#㈡元素-offsetWidth-offsetHeight" class="headerlink" title="㈡元素.offsetWidth/offsetHeight"></a>㈡元素.offsetWidth/offsetHeight</h4><p>获取元素的整个宽高，<strong>包括内容区、内边距、边框</strong></p>
<h4 id="㈢元素-offsetParet"><a href="#㈢元素-offsetParet" class="headerlink" title="㈢元素.offsetParet"></a>㈢元素.offsetParet</h4><ol>
<li>可获取当前元素的定位父元素</li>
<li>它会获取到距离当前元素最近的<strong>开启了定位的祖先元素</strong></li>
<li>若所有祖先元素均为开启定位，则返回body</li>
</ol>
<h4 id="㈣元素-offsetLeft-offsetTop"><a href="#㈣元素-offsetLeft-offsetTop" class="headerlink" title="㈣元素.offsetLeft/offsetTop"></a>㈣元素.offsetLeft/offsetTop</h4><p>当前元素相对于其定位父元素的水平/垂直偏移量</p>
<h4 id="㈤元素-scroolLeft-scrollTop"><a href="#㈤元素-scroolLeft-scrollTop" class="headerlink" title="㈤元素.scroolLeft/scrollTop"></a>㈤元素.scroolLeft/scrollTop</h4><p>当前元素的水平/垂直滚动条<strong>滚动的距离</strong></p>
<h4 id="㈥元素-scrollWidth-scrollHeight"><a href="#㈥元素-scrollWidth-scrollHeight" class="headerlink" title="㈥元素.scrollWidth/scrollHeight"></a>㈥元素.scrollWidth/scrollHeight</h4><p>可获取元素整个<strong>滚动区域的宽/高</strong></p>
<blockquote>
<p>当满足scrollHeight-scrollTop==clientHeight时，代表垂直滚动条滚动到底 同理,水平滚动条移动到最右端为scrollWidth-scrollLeft==clientWidth</p>
</blockquote>
]]></content>
      <categories>
        <category>web</category>
        <category>JavaScript</category>
        <category>Web</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【Part.2】IntelliJ IDEA小教程：代码操作篇</title>
    <url>/2018/10/01/%E3%80%90part-2%E3%80%91intellij-idea%E5%B0%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C%E7%AF%87/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="①列操作"><a href="#①列操作" class="headerlink" title="①列操作"></a>①列操作</h1><p>假如我们想要将左图修改为右图的枚举形式，该如何快速操作呢？ <a href="http://upane.cn/archives/744/idea64_2018-10-01_16-34-32"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_16-34-32.png" alt=""></a><a href="http://upane.cn/archives/744/idea64_2018-10-01_16-49-47"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_16-49-47.png" alt=""></a> 首先，说明一下<strong>选中文本</strong>的规则： 我们都知道当按下←/→时可以移动光标，如果我们想在移动时<strong>选中</strong>多个文本，就可以按下<strong>Shift+←</strong>或<strong>Shift+→</strong>，这样编译器就会选择光标移动范围的文本。 如果我们想将光标移动<strong>跳过一个词</strong>（单词、中文词等）时，可以按下<strong>Ctrl+←</strong>或<strong>Ctrl+→</strong>。另外，如果我们想让光标跳至行首，可以按下<strong>HOME</strong>键，如果我们想让光标跳至行尾，可以按下<strong>END</strong>键。 综上所述，我们可以拓展一下思维，如果我们想选中一个词，光标又在该词之前，我们就可以按下<strong>Ctrl+Shift+→</strong>来选中该词，如果我们想选中一行，光标又在一行的行尾，我们就可以按下Shift+HOME来选中这一行。 注意，这个规则是<strong>普适于所有文本编辑工具的</strong>，不仅限于IntelliJ IDEA。 那么我们继续IntelliJ IDEA教程： 通过对比两图我们不难发现前后的变化为： ①单词全部大写了，并且移动到了数字之前 ②数字添加了括号，除了最后一行结尾为分号外，每行结尾为逗号 ③文本被预格式化了，排版更加整洁 然后我们一一解决上面的问题： 首先我们将单词选中（Ctrl+Shift+→） <a href="http://upane.cn/archives/744/idea64_2018-10-01_17-10-37"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_17-10-37.png" alt=""></a> 然后使用使用Toggle case<strong>大小写转换（Ctrl+Shift+U）</strong> <a href="http://upane.cn/archives/744/idea64_2018-10-01_17-10-37-2"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_17-10-37-1.png" alt=""></a>，其对应Edit选项卡中的Toggle case： <a href="http://upane.cn/archives/744/2018-10-01_17-11-40"><img src="http://47.94.231.166/wp-content/uploads/2018/10/2018-10-01_17-11-40-300x195.png" alt=""></a> 然后将其剪切（Ctrl+X），将光标移到行首（HOME），粘贴到行首（Ctrl+V），并手动为数字添加括号，注意数字也可以看为一个单词，所以按下Ctrl+→即可跳过一个数字 <a href="http://upane.cn/archives/744/idea64_2018-10-01_17-18-48"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_17-18-48.png" alt=""></a> 之后将光标跳到最后（END）删除多余的部分，添加逗号，这样一行就编辑完了。 <a href="http://upane.cn/archives/744/idea64_2018-10-01_17-20-02"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_17-20-02.png" alt=""></a> 然后我们介绍一下<strong>多列批量操作</strong>： 我们发现需要操作的每行都有个冒号作为分割点，这是个很好的提示信息，代表了我们需要更改文本的特性，可以与<strong>下面其他代码</strong>相分别的地方。将其选中。 <a href="http://upane.cn/archives/744/idea64_2018-10-01_17-22-56"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_17-22-56.png" alt=""></a> 然后按下<strong>Ctrl+Alt+Shift+J</strong>，即可选中所有冒号，这是我们惊喜地发现：光标分身了！ <a href="http://upane.cn/archives/744/idea64_2018-10-01_17-27-51"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_17-27-51.png" alt=""></a> 这样，我们就可以做到列批量操作了，再重复上面的工作即可。 这个功能在Edit&gt;Find&gt;Select All Occurrence： <a href="http://upane.cn/archives/744/idea64_2018-10-01_17-22-26"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_17-22-26-298x300.png" alt=""></a> 如果我们需要批量更改的文本下面还有带冒号的代码怎么办？使用Ctrl+Alt+Shift+J不就一次都选中了？面对这种情况我们可以使用<strong>Alt+J</strong>，这样光标可以一次只“分身”一个，不会一次全部选中。</p>
<h1 id="②Live-Templates"><a href="#②Live-Templates" class="headerlink" title="②Live Templates"></a>②Live Templates</h1><p>Live Templates是一个<strong>模板定义工具</strong>，利用它定义模板即可快速输入代码，大大增加开发效率。 下面演示添加一个Main方法的模板： 按下Ctrl+Shift+A打开搜索工具，搜索Live Templates，打开即可得到以下窗口 <a href="http://upane.cn/archives/744/idea64_2018-10-01_17-49-48"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_17-49-48-300x209.png" alt=""></a> 点击右侧的“+”，选择<strong>“Template Group”</strong>，为我们的模板新定义一个分组存储 <a href="http://upane.cn/archives/744/chrome_2018-10-01_17-50-30"><img src="http://47.94.231.166/wp-content/uploads/2018/10/chrome_2018-10-01_17-50-30.png" alt=""></a> 这里我们定义一个名为“常用方法”的分组： <a href="http://upane.cn/archives/744/idea64_2018-10-01_17-51-38"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_17-51-38-300x118.png" alt=""></a> 再点击右侧的“+”，这次选择<strong>“Live Template”</strong>为分组添加一个模板 <a href="http://upane.cn/archives/744/idea64_2018-10-01_17-54-54"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_17-54-54-300x160.png" alt=""></a> 在Abbreviation（缩写）中填入将模板唤起的文本，这里我们写入“main”，在Description（描述）中输入模板的描述，这是在我们输入缩写文字时提示的内容，这里我们写入“public static void main(String[] args)” <a href="http://upane.cn/archives/744/idea64_2018-10-01_18-00-39"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_18-00-39-300x81.png" alt=""></a> 然后直接在Template text内输入函数体即可，注意这里有几种表达式(大小写随意，记得加美元$符号框起来就行）： ①<strong>\$VARx\$</strong>：x代表一个大于零的整数，<strong>表示这里将会有一个值</strong>，生成模板后会自动<strong>把光标移到这里</strong>，开发人员输入一个值后按下<strong>Enter</strong>即可跳到下一个值 ②<strong>\$END\$</strong>：表示这里将会有一个代码块，如函数体，生成模板后会自动<strong>把光标移到这里（如果有$VARx$先移动到$VARx$）</strong>，开发人员在这里可以自由换行，按下Enter也不会有跳转，所以如果后面有<strong>$VARx$</strong>编译器也不会引导开发人员，可以认为<strong>模板引导止步于此</strong> 跟据我们的需要，我们在这里填入</p>
<p>public static void main(String[] args)<br>{<br>  $END$<br>}</p>
<p>最后，在输入框下单击Define，为该模板定义一种适用类型，这里我们选择JAVA： <a href="http://upane.cn/archives/744/idea64_2018-10-01_18-15-09"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_18-15-09-247x300.png" alt=""></a> 至此模板已经定义完成，回到代码页面输入“main”就出现了我们定义的内容： <a href="http://upane.cn/archives/744/%e5%b0%8f%e6%97%b6%e9%92%9f_2018-10-01_18-15-34"><img src="http://47.94.231.166/wp-content/uploads/2018/10/小时钟_2018-10-01_18-15-34-300x40.png" alt=""></a> 再按下<strong>Enter</strong>即可调用模板： <a href="http://upane.cn/archives/744/%e5%b0%8f%e6%97%b6%e9%92%9f_2018-10-01_18-15-52"><img src="http://47.94.231.166/wp-content/uploads/2018/10/小时钟_2018-10-01_18-15-52.png" alt=""></a></p>
<h1 id="④postfix"><a href="#④postfix" class="headerlink" title="④postfix"></a>④postfix</h1><p>postfix也是一种Live Templates模板，不过这种模板由编译器设定，是归类了几种最常用的操作的模板集合。它比自定义的Live Templates更灵活方便。</p>
<h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><p>postfix默认状态下是开启的，如果不下心关闭，我们可以手动打开：按下Ctrl+Shift+A打开搜索器，输入postfix，打开相关设置界面，勾选“Enable postfix Conpletion”。 <a href="http://upane.cn/archives/744/idea64_2018-10-01_19-21-45"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_19-21-45-300x183.png" alt=""></a></p>
<h2 id="常用模板"><a href="#常用模板" class="headerlink" title="常用模板"></a>常用模板</h2><h3 id="①fori"><a href="#①fori" class="headerlink" title="①fori"></a>①fori</h3><p><a href="http://upane.cn/archives/744/idea64_2018-10-01_19-32-14"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_19-32-14-300x234.png" alt=""></a></p>
<h3 id="②return"><a href="#②return" class="headerlink" title="②return"></a>②return</h3><p><a href="http://upane.cn/archives/744/idea64_2018-10-01_19-31-59"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_19-31-59-300x235.png" alt=""></a></p>
<h3 id="③field"><a href="#③field" class="headerlink" title="③field"></a>③field</h3><p><a href="http://upane.cn/archives/744/idea64_2018-10-01_19-30-06"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_19-30-06-300x237.png" alt=""></a></p>
<h3 id="④sout"><a href="#④sout" class="headerlink" title="④sout"></a>④sout</h3><p><a href="http://upane.cn/archives/744/idea64_2018-10-01_19-29-45"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_19-29-45-300x237.png" alt=""></a></p>
<h3 id="⑤nn"><a href="#⑤nn" class="headerlink" title="⑤nn"></a>⑤nn</h3><p><a href="http://upane.cn/archives/744/idea64_2018-10-01_19-29-04"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_19-29-04-300x235.png" alt=""></a> 除了这些还有很多模板，可以自己学习一下找到最适合自己的。</p>
<h1 id="⑤Alt-Enter"><a href="#⑤Alt-Enter" class="headerlink" title="⑤Alt + Enter"></a>⑤Alt + Enter</h1><p>Alt+Enter快捷键实际上对应的是一个叫“Show Intent”的工具，类似于IntelliJ IDEA的一个小助手，它可以完成很多实用小功能。</p>
<h2 id="1-自动创建函数"><a href="#1-自动创建函数" class="headerlink" title="1.自动创建函数"></a>1.自动创建函数</h2><p>如果我们调用了一个赞为创建的方法，如下图的uuu()，编译器当然会报错，但是如果我们按下Alt+Enter，就会提示创建一个名为uuu的函数： <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-24-35"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-24-35-300x133.png" alt=""></a> 再次按下Enter即可创建该函数： <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-25-57"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-25-57.png" alt=""></a> 另外，如果在暂未定义的函数中传入变量，该工具还可以为新创建的函数填写形参，参数名即为传入的参数名。</p>
<h2 id="2-优化函数"><a href="#2-优化函数" class="headerlink" title="2.优化函数"></a>2.优化函数</h2><p>当使用for循环与使用foreach等效时，可使用Alt+Enter进行优化替换，与此相同的还有for、while互换等。 <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-35-20"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-35-20-300x179.png" alt=""></a></p>
<h2 id="3-字符串format"><a href="#3-字符串format" class="headerlink" title="3.字符串format"></a>3.字符串format</h2><p>将断开的字符串写法改成整体的字符串写法： <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-39-46"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-39-46-300x81.png" alt=""></a> 效果： <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-39-59"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-39-59-300x43.png" alt=""></a> 这种方式更方便我们的读写。</p>
<h2 id="4-实现接口"><a href="#4-实现接口" class="headerlink" title="4.实现接口"></a>4.实现接口</h2><p>我们定义接口后可以使用Alt+Enter自动创建一个承接该接口的类文件： 比如我们创建了test接口，里面有个test函数，我们对接口名使用Alt+Enter，选择”Implement interface” <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-47-22"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-47-22-300x132.png" alt=""></a> 选择创建的类名以及所在的包（package）： <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-47-35"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-47-35-300x100.png" alt=""></a> 确认重写的函数： <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-47-41"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-47-41-195x300.png" alt=""></a> 然后就完成了： <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-47-57"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-47-57-300x114.png" alt=""></a></p>
<h2 id="5-英语纠错"><a href="#5-英语纠错" class="headerlink" title="5.英语纠错"></a>5.英语纠错</h2><p>当我们的拼写出错时，编译器会在出错的词下添加绿色波浪线，在这上面使用Alt+Enter，选择”Typo：Change to…” <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-55-19"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-55-19-300x62.png" alt=""></a> 即可出现建议的词语列表： <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-55-28"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-55-28.png" alt=""></a> 选择正确的词语即可。</p>
<h2 id="6-导包"><a href="#6-导包" class="headerlink" title="6.导包"></a>6.导包</h2><p>当我们使用了未导入的库的函数、类时，编译器就会报错。如图中的List： <a href="http://upane.cn/archives/744/idea64_2018-10-01_20-58-20"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_20-58-20.png" alt=""></a> 这时我们按下Alt+Enter，IntelliJ IDEA就可以自动导入库： <a href="http://upane.cn/archives/744/idea64_2018-10-01_21-01-09"><img src="http://47.94.231.166/wp-content/uploads/2018/10/idea64_2018-10-01_21-01-09.png" alt=""></a> 综上所述，当我们在编程时遇到问题就可以尽情使用Alt+Enter的提示去修复了。</p>
]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】Dict与Set</title>
    <url>/2018/09/22/%E3%80%90python%E3%80%91dict%E4%B8%8Eset/</url>
    <content><![CDATA[<p>Dict、Set、List都可以分组存放数据，但是Dict、Set与List不同的是，它们的数据是<strong>无序存放</strong>的，也就是说，对他们遍历打印，每次将得到顺序不同的结果。<br><a id="more"></a></p>
<h1 id="①Dict"><a href="#①Dict" class="headerlink" title="①Dict"></a>①Dict</h1><p>dict=dictionary，其实就是C#的Dictionary啦，只是python的dict不需要实例化（因为都不需要定义数据类型），直接用就可以。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    <span class="string">&#x27;Adam&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">    <span class="string">&#x27;Lisa&#x27;</span>: <span class="number">85</span>,</span><br><span class="line">    <span class="string">&#x27;Bart&#x27;</span>: <span class="number">59</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，按照<strong>key:value</strong>的格式录入数据就可以。<img src="http://47.94.231.166/wp-content/uploads/2018/04/34.png" alt=""> 这里介绍一个函数<strong>len()</strong>,它可以计算任意集合的大小 如，对上面的d使用的效果如图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(d)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>嗯，对Set、List也可以用的。</p>
<h2 id="使用-查找"><a href="#使用-查找" class="headerlink" title="使用/查找"></a>使用/查找</h2><p>像List一样用中括号就可以，只不过中括号里面的是key而不是索引 如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    <span class="string">&#x27;Adam&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">    <span class="string">&#x27;Lisa&#x27;</span>: <span class="number">85</span>,</span><br><span class="line">    <span class="string">&#x27;Bart&#x27;</span>: <span class="number">59</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d[<span class="string">&#x27;Adam&#x27;</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure>
<p>如果键值key不存在那么程序就会报错，要避免出错可以在调用前检查一下key是否存在，这样又有两种方法： 1.<strong>先判断一下 key 是否存在，用 in 操作符：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Paul&#x27;</span> <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span> d[<span class="string">&#x27;Paul&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>注意这个if里面也可用in，好奇葩。。哦不，好人性化的写法啊<img src="http://47.94.231.166/wp-content/uploads/2018/04/57.png" alt="">计算机语言写多了都看不懂人话了。。。。 2.<strong>是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d.get(<span class="string">&#x27;Bart&#x27;</span>)</span><br><span class="line"><span class="number">59</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> d.get(<span class="string">&#x27;Paul&#x27;</span>)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="更新dict"><a href="#更新dict" class="headerlink" title="更新dict"></a>更新dict</h2><p>要把’Paul‘的成绩72加进去，可以直接使用赋值语句加进去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Paul&#x27;</span>] = <span class="number">72</span></span><br></pre></td></tr></table></figure>
<p>如果Paul的成绩已经存在，那么之前的成绩将被替换为72</p>
<h2 id="dict遍历"><a href="#dict遍历" class="headerlink" title="dict遍历"></a>dict遍历</h2><p>这没什么好讲的，简单暴力</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:<span class="built_in">print</span> key,d[key]</span><br></pre></td></tr></table></figure>
<p>注意python里连接各数据并完成字符串转换的是逗号“，”而不是C#的“+”</p>
<h2 id="dict的特点"><a href="#dict的特点" class="headerlink" title="dict的特点"></a>dict的特点</h2><p><strong>1.高速查找，但是占内存</strong> <strong>2.无序性</strong> <strong>3.key不可变</strong></p>
<h1 id="②set"><a href="#②set" class="headerlink" title="②set"></a>②set</h1><p>有时我们并不怎么重点需要一个集合中的几个数据，比如我们在定义集合后只是想知道之后的数据是否在该集合内又对应（就像C#的枚举）这时我们就可以使用set来定义集合了。</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>这里可以看出，set的定义方法有些奇怪，因为目前为止接触的定义方法里很少有直接把定义的名字直接写在前面的，但是在python里有很多，熟悉就好。 <strong>定义名 = set(一个List或者tuple链表）</strong> 可以查看 set 的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> s</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><strong>请注意</strong>，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是<strong>无序</strong>的。 因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;C&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> s</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。</p>
<h2 id="访问set"><a href="#访问set" class="headerlink" title="访问set"></a>访问set</h2><p>例如，存储了班里同学名字的set：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Paul&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>我们可以用 in 操作符判断： Bart是该班的同学吗？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Bart&#x27;</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>注意，这里是区分大小写的</p>
<h2 id="set的特点"><a href="#set的特点" class="headerlink" title="set的特点"></a>set的特点</h2><p><strong>set的内部结构和dict很像，唯一区别是不存储value</strong>，因此，判断一个元素是否在set中速度很快。 <strong>set存储的元素和dict的key类似，必须是不变对象</strong>，因此，任何可变对象是不能放入set中的。</p>
<h2 id="遍历set"><a href="#遍历set" class="headerlink" title="遍历set"></a>遍历set</h2><p>虽然不能获取某个值，但是set还是可以遍历来获得所有值的。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> name</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Lisa</span><br><span class="line">Adam</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>
<h2 id="更新set"><a href="#更新set" class="headerlink" title="更新set"></a>更新set</h2><p>由于<strong>set存储的是一组不重复的无序元素</strong>，因此，更新set主要做两件事： <strong>一是把新的元素添加到set中，二是把已有元素从set中删除。</strong> 添加元素时，用set的add()方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> s</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> s</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>删除set中的元素时，用set的remove()方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> s</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>如果删除的元素不存在set中，remove()会报错，所以用add()可以直接添加，而remove()前需要判断。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】List列表</title>
    <url>/2018/09/20/%E3%80%90python%E3%80%91list%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>Python内置的一种数据类型是列表：<strong>list</strong>。list是一种有序的集合，可以随时添加和删除其中的元素。<br><a id="more"></a></p>
<h1 id="①创建List列表"><a href="#①创建List列表" class="headerlink" title="①创建List列表"></a>①创建List列表</h1><p>就我而言更喜欢将其与数组相类比 比如Python的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L=[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> L</span><br></pre></td></tr></table></figure>
<p>（结果为[‘Michael’, ‘Bob’, ‘Tracy’]） 就相当于C#中的</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] L=<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>]&#123;<span class="string">&quot;Michael&quot;</span>,<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Tracy&quot;</span>&#125;;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;/&quot;</span>&#123;<span class="number">0</span>&#125;/<span class="string">&quot;,/&quot;</span>&#123;<span class="number">1</span>&#125;/<span class="string">&quot;,/&quot;</span>&#123;<span class="number">2</span>&#125;/<span class="string">&quot;&quot;</span>,L[<span class="number">0</span>],L[<span class="number">1</span>],L[<span class="number">2</span>]&#125;;</span><br></pre></td></tr></table></figure>
<p>（结果为{“Michael”,”Bob”,”Tracy”}） 但是不同之处在于，Python的List列表不限于一种类型，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L=[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">12</span>, <span class="literal">True</span>]</span><br><span class="line"><span class="built_in">print</span> L</span><br></pre></td></tr></table></figure>
<p>也可以编译通过<img src="http://47.94.231.166/wp-content/uploads/2018/04/88.png" alt=""> （结果为[‘Michael’, 12, True]） 另外空表也是允许的。</p>
<h1 id="②打印列表数据"><a href="#②打印列表数据" class="headerlink" title="②打印列表数据"></a>②打印列表数据</h1><p>调用单个元素时，也可以像数组那样使用索引，并且索引也是从零开始。如上面的例子中L[0]的值为Michael。 你以为这么简单就完了？那肯定不成！<img src="http://47.94.231.166/wp-content/uploads/2018/04/23.png" alt=""> 在Python中，也可以使用负数索引表示倒序！ 如上例中，L[-1]=Tracy=L[2],L[-2]=Bob=L[1],L[-3]=Micheal=L[0]<img src="http://47.94.231.166/wp-content/uploads/2018/04/28.png" alt=""></p>
<h1 id="③List列表的扩展与缩减"><a href="#③List列表的扩展与缩减" class="headerlink" title="③List列表的扩展与缩减"></a>③List列表的扩展与缩减</h1><p>在C语言中，已经声明的数组还可以用relloc扩充，但是C#的数组一旦被实例化就固定不动了，Python可否更改已经声明了的List呢？ 当然可以！<img src="http://47.94.231.166/wp-content/uploads/2018/04/43.png" alt=""> 第一个办法是用 list 的<strong>append()</strong>方法，把新数据追加到 list 的<strong>末尾</strong>：</p>
<p>>&gt;&gt; L = [‘Adam’, ‘Lisa’, ‘Bart’]</p>
<blockquote>
<blockquote>
<blockquote>
<p>L.append(‘Paul’)<br>print L<br>[‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’</p>
</blockquote>
</blockquote>
</blockquote>
<p>第二个方法是用list的<strong>insert()</strong>方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素：</p>
<p>>&gt;&gt; L = [‘Adam’, ‘Lisa’, ‘Bart’]</p>
<blockquote>
<blockquote>
<blockquote>
<p>L.insert(0, ‘Paul’)<br>print L<br>[‘Paul’, ‘Adam’, ‘Lisa’, ‘Bart’]</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>L.insert(0, ‘Paul’)</strong> 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam，以及后面的所有数据，都自动向后移动一位。 那么如何删除数据呢？ 我们可以用list的<strong>pop()</strong>方法删除：</p>
<p>>&gt;&gt; L = [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’]</p>
<blockquote>
<blockquote>
<blockquote>
<p>L.pop()<br>‘Paul’<br>print L<br>[‘Adam’, ‘Lisa’, ‘Bart’]</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>pop()</strong>方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。 然而如果对于这种情况</p>
<p>>&gt;&gt; L = [‘Adam’, ‘Lisa’, ‘Paul’, ‘Bart’]</p>
<p>要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用<strong>pop(2)</strong>把Paul删掉：</p>
<p>>&gt;&gt; L.pop(2)<br>‘Paul’</p>
<blockquote>
<blockquote>
<blockquote>
<p>print L<br>[‘Adam’, ‘Lisa’, ‘Bart’]</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="④替换元素"><a href="#④替换元素" class="headerlink" title="④替换元素"></a>④替换元素</h1><p>比如在以下列表</p>
<p>>&gt;&gt; L = [‘Adam’, ‘Lisa’, ‘Bart’]</p>
<p>中，使用Paul替换掉Bart，可以<strong>直接赋值替换</strong></p>
<p>>&gt;&gt; L[2] = ‘Paul’</p>
<blockquote>
<blockquote>
<blockquote>
<p>print L<br>L = [‘Adam’, ‘Lisa’, ‘Paul’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>当然你也可以这样秀操作：</p>
<p>>&gt;&gt; L[-1] = ‘Paul’</p>
<h1 id="⑤创建tuple列表"><a href="#⑤创建tuple列表" class="headerlink" title="⑤创建tuple列表"></a>⑤创建tuple列表</h1><p>那么如果想创建不能被修改的列表该怎么办呢？ 很简单之前不是用[]声明的吗？这次用（）声明即可，用()声明的列表就是tuple列表 如</p>
<p>>&gt;&gt; t = (‘Adam’, ‘Lisa’, ‘Bart’)</p>
<p>这样，这个列表t就既不能增减，也不能改变。 那么，这里就有了一个问题，即</p>
<p>t = (1)</p>
<p>这到底是个什么东西<img src="http://47.94.231.166/wp-content/uploads/2018/04/82.png" alt=""> 是tuple列表，还是1加了括号？ 答案是<strong>1加了括号</strong></p>
<p>>&gt;&gt; t = (1)</p>
<blockquote>
<blockquote>
<blockquote>
<p>print t<br>1</p>
</blockquote>
</blockquote>
</blockquote>
<p>那要是想表示tuple列表里只有一个元素该怎么办？ 好说，<strong>加个逗号</strong>即可</p>
<p>>&gt;&gt; t = (1,)</p>
<blockquote>
<blockquote>
<blockquote>
<p>print t<br>(1,)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="⑥“二维列表”嵌套列表"><a href="#⑥“二维列表”嵌套列表" class="headerlink" title="⑥“二维列表”嵌套列表"></a>⑥“二维列表”嵌套列表</h1><p>注意看这个东西：</p>
<p>>&gt;&gt; t = (‘a’, ‘b’, [‘A’, ‘B’])</p>
<p><img src="http://47.94.231.166/wp-content/uploads/2018/04/78.png" alt=""> 其实，这只是一个列表嵌套了一个列表而已，如果我想改变里面那个列表该怎么办呢？ 把它“<strong>拽</strong>”出来</p>
<p>>&gt;&gt; t = (‘a’, ‘b’, [‘A’, ‘B’])</p>
<blockquote>
<blockquote>
<blockquote>
<p>L = t[2]<br>L[0] = ‘X’<br>L[1] = ‘Y’<br>print t<br>(‘a’, ‘b’, [‘X’, ‘Y’])</p>
</blockquote>
</blockquote>
</blockquote>
<p>“<strong>拽</strong>”出来后只要是List列表，要增加减少还是替换就看我们怎样操作了。 <strong>将列表转换为字符串：join()方法</strong> 使用方法：<strong>分割字符.join(链表)</strong>,如</p>
<p>L = [‘Adam’, ‘Lisa’, ‘Bart’]<br>print ‘\\n’.join(L)<br>Adam<br>Lisa<br>Bart</p>
<p>有些同学会问了，后面这几个案例怎么都没有C#对照呢？因为C#的数组它都不能这么玩啊<img src="http://47.94.231.166/wp-content/uploads/2018/04/36.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】变量和数据类型</title>
    <url>/2018/09/18/%E3%80%90python%E3%80%91python%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Python作为一门脚本语言与C#相比具有十分简易的语法，从数据类型这里就可见一斑:<br><a id="more"></a></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>C#:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="built_in">float</span> b=<span class="number">3.2</span>;</span><br><span class="line"><span class="built_in">string</span> c=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">bool</span> d=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(d)Console.WriteLine(Convert.ToString(a+b));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!d&amp;&amp;b&gt;a)Console.WriteLine(c);</span><br></pre></td></tr></table></figure>
<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">5</span></span><br><span class="line">b=<span class="number">3.2</span></span><br><span class="line">c=<span class="string">&quot;Hello&quot;</span></span><br><span class="line">d=<span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> d:print(a+b)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">not</span> d <span class="keyword">and</span> (b&gt;a):<span class="built_in">print</span> c</span><br></pre></td></tr></table></figure>
<p>通过对比可以看出Python<strong>声明变量时不需要声明变量类型，直接赋值即可,语句结尾甚至不用添加分号。<img src="http://47.94.231.166/wp-content/uploads/2018/04/36.png" alt=""></strong> 并且可以<strong>直接输入“0x…”代表16进制数</strong>，如0x0a28d。<strong>科学记数法可写为xey的形式</strong>，如1.6e3=1.6*10^3。 <strong>直接将变量输入False或者True即可将变量初始化为布尔类型</strong>。逻辑运算符为and(&amp;&amp;),or(),not(!)括号内代表C#的逻辑运算符。 <strong>空值用None表示。</strong></p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(a+b)</span><br><span class="line"><span class="built_in">print</span> c</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;11+5=&quot;</span>,c</span><br></pre></td></tr></table></figure>
<p>没错，有时连括号都可以省略。 <strong>用逗号连接各字符串</strong>，相当于C#的”+”，但是连接处会有一个空格 Python中的“+”连接虽无空格但<strong>只用于连接字符串</strong> <strong>另外，Python不支持自加运算符++或—，若要使用请改为x+=1</strong></p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(a+b) <span class="comment">#打印a+b的值</span></span><br></pre></td></tr></table></figure>
<p><strong>井号注释掉一行</strong>，相当于C#的双斜线</p>
<h1 id="变量的声名"><a href="#变量的声名" class="headerlink" title="变量的声名"></a>变量的声名</h1><p>特别注意的是，Python声明的变量是动态的，也就是说变量并不固定于某一个类型，这点与C系列语言均不同，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">5</span></span><br><span class="line">a=<span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>这是可以编译通过的，其中需要注意的是： 1.字符串初始化用双引号“”或单引号’’均可 2.变量名规则，这点倒是与C系列相同</p>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>既然双引号用作字符串的声明，那么字符串里要用双引号怎么办？ 学过C#的同学都只知道，用反斜线呗（\\），对了，<strong>这里python也可以这么用</strong>。但是，在python里你也可以用单引号声明字符串，这样字符串里就可以有双引号了！惊不惊喜?意不意外？<img src="http://47.94.231.166/wp-content/uploads/2018/04/28.png" alt=""> 但是，要是我一行代码里反斜线、单引号、双引号都有怎么办？角度刁钻，但是python也可以解决，<strong>那就是用r加一对单引号</strong>：</p>
<h4 id="r’…’"><a href="#r’…’" class="headerlink" title="r’…’"></a>r’…’</h4><p>这里r代表raw，单反发烧友都知道，原始数据。 那我要是还想换行怎么办？你这一原始我\\n也不能用了啊？别急，这还有：r加三对单引号，<strong>里面你可以任意换行</strong>！</p>
<h4 id="r’’’…’’’"><a href="#r’’’…’’’" class="headerlink" title="r’’’…’’’"></a>r’’’…’’’</h4><p>C、C++、C#、Java跪<img src="http://47.94.231.166/wp-content/uploads/2018/04/58.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hello!\nPython is so great!&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">r&#x27;&#x27;&#x27;Hello!</span></span><br><span class="line"><span class="string">Python is so great!&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面这俩输出结果相同。 由于某些Python版本差异，个别输出中文、日文等非英语字符时无法正常显示，这时就要在字符串前加u，代表其中是Unicode码。 那么，如果像C#这样：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> time=<span class="string">&quot;10:00&quot;</span>,nexttime=<span class="string">&quot;11:00&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Now time is &#123;0&#125;,Next time is &#123;1&#125;&quot;</span>,time,nexttime);</span><br></pre></td></tr></table></figure>
<p>该如何实现呢？可以这样： time=10:00 nexttime=11:00 printf ‘Now time is %s,Next time is %s’ %(time,nexttime) 与C语言一样，%s代表string数据类型。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】使用列表生成式生成List列表</title>
    <url>/2018/09/23/%E3%80%90python%E3%80%91%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90list%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>若要生成list[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]有几种方法呢？ 常见的方法有： 1.直接赋值</p>
<p>>&gt;&gt; list=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<p>2.使用函数</p>
<p>>&gt;&gt; list=range(1, 11)</p>
<p>3.使用列表生成式</p>
<p>>&gt;&gt; [x for x in range(1, 11)]<br><a id="more"></a><br>好像没太方便呵，但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？</p>
<p>>&gt;&gt; [x * x for x in range(1, 11)]<br>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</p>
<p>这就看出列表生成式的方便了。 具体用法是 <strong>[ 生成列表内的值（由迭代值进行某种变换得到的值） for  迭代值 in 内涵迭代值的列表 ]</strong> 另有 <strong>1.带条件过滤</strong>的列表生成式，如</p>
<p>>&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]<br>[4, 16, 36, 64, 100]</p>
<p>（只输出1~10偶数的平方） <strong>2.多层表达式</strong></p>
<p>>&gt;&gt; [m + n for m in ‘ABC’ for n in ‘123’]<br>[‘A1’, ‘A2’, ‘A3’, ‘B1’, ‘B2’, ‘B3’, ‘C1’, ‘C2’, ‘C3’]</p>
<p>翻译过来就是这样👇</p>
<p>L = []<br>for m in ‘ABC’:<br>    for n in ‘123’:<br>        L.append(m + n)</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】函数入门</title>
    <url>/2018/09/23/%E3%80%90python%E3%80%91%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>函数，对应C#中的方法，是在日常编程工作中最广泛使用的工具，如何巧妙地分割问题形成函数是一个程序员必不可少的素质，今天来学习Python的函数构成，了解其与C#等语言的差异，可为日后编程工作带来极大方便。<br><a id="more"></a></p>
<h1 id="①内建函数"><a href="#①内建函数" class="headerlink" title="①内建函数"></a>①内建函数</h1><p>内建函数是Python中自带的函数，使用时需要引入（import）函数库。 当我们知道只函数名而不知其功能时，可以在交互式命令行使用<strong>help(函数名)</strong>查看帮助信息。 更多的情况下，当我们想要寻找满足需求的函数时，可以访问网站： <a href="https://docs.python.org/2/library/">https://docs.python.org/2/library/</a> 查阅相关功能。 这里小提一下<strong>类型转换函数（int()、str()等等）</strong>，它们可以转换字符类型，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="number">12.34</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">123</span>)</span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">1.23</span>)</span><br><span class="line"><span class="string">&#x27;1.23&#x27;</span></span><br></pre></td></tr></table></figure>
<p>与比较函数<strong>cmp(x,y),如果 x<y，返回 -1，如果 x==y，返回 0，如果 x>y，返回 1：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>更多的函数还需要在后期开发中不断学习。  </p>
<h1 id="②自建函数"><a href="#②自建函数" class="headerlink" title="②自建函数"></a>②自建函数</h1><p>在Python中，定义一个函数要使用 <strong>def</strong> 语句，依次写出<strong>函数名、括号、</strong>括号中的<strong>参数</strong>和<strong>冒号:</strong>，然后，在缩进块中编写函数体，函数的返回值用 <strong>return</strong> 语句返回。 我们以自定义一个求绝对值的 my_abs 函数为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。 <strong>return None可以简写为return。</strong></p>
<h2 id="返回多值"><a href="#返回多值" class="headerlink" title="返回多值"></a>返回多值</h2><p>Python的函数支持返回多值，只需在return后将值用逗号隔开即可。这样函数将<strong>返回一个Tuple链表包含多值</strong> 如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">x, y, step, angle</span>):</span><span class="comment">#定义函数</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)<span class="comment">#调用函数得到x，y&lt;/strong&gt;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> x, y  <span class="comment">#打印函数返回的值&lt;/strong&gt;</span></span><br><span class="line"><span class="number">151.961524227</span> <span class="number">70.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)<span class="comment">#调用函数得到链表r</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> r  <span class="comment">#打印函数返回的链表</span></span><br><span class="line">(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="定义默认函数"><a href="#定义默认函数" class="headerlink" title="定义默认函数"></a>定义默认函数</h2><p>python对默认函数的定义很像C#中<strong>函数的重构</strong>，即，一个函数传入值的多少可变 具体实现方法是<strong>给可不赋值的变量赋初始值</strong>，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span>(<span class="params">x, n=<span class="number">2</span></span>):</span> <span class="comment">#定义函数</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&gt;&gt;&gt; power(5) &lt;/strong&gt;#调用函数</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
<h2 id="定义可变函数"><a href="#定义可变函数" class="headerlink" title="定义可变函数"></a>定义可变函数</h2><p>如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="built_in">print</span> args</span><br></pre></td></tr></table></figure>
<p>可变参数的名字前面有个 <strong>*</strong> 号，我们可以传入0个、1个或多个参数给可变参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn()</span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】切片</title>
    <url>/2018/09/23/%E3%80%90python%E3%80%91%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<p>Python中提供强大的数据处理功能，其中常用的就有切片。它可以对List、字符串进行切割来得到希望获取的结果。<br><a id="more"></a></p>
<h1 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h1><p><strong>list[起始索引:结束索引]</strong> 该操作将会返回<strong>包括起始索引</strong>但<strong>不包括结束索引</strong>的结果 如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Paul&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>如果第一个索引是0，还可以省略：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>只用一个 <strong>:</strong> ，表示从头到尾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:]</span><br><span class="line">[<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Paul&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h1 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h1><p><strong>list[起始索引:结束索引:跳选个数]</strong> 跳选个数表示每隔这个数就选一个比如1…..10，跳选个数为3，那么输出结果为1,4,7,10 <img src="http://47.94.231.166/wp-content/uploads/2018/09/WINWORD_2018-09-23_16-16-43.jpg" alt=""> 代码表示则为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L=<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p><strong>range(x,y) 返回从x（包括）到y（不包括）的List链表</strong></p>
<h1 id="倒序切片"><a href="#倒序切片" class="headerlink" title="倒序切片"></a>倒序切片</h1><p>对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Paul&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:]</span><br><span class="line">[<span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Paul&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">-2</span>]</span><br><span class="line">[<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-3</span>:<span class="number">-1</span>]</span><br><span class="line">[<span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-4</span>:<span class="number">-1</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。</p>
<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><p>字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABCDEFG&#x27;</span>[:<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABCDEFG&#x27;</span>[<span class="number">-3</span>:]</span><br><span class="line"><span class="string">&#x27;EFG&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABCDEFG&#x27;</span>[::<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;ACEG&#x27;</span></span><br></pre></td></tr></table></figure>
<p>x.upper() 将字符串/字符链表x中的所有小写字母转换为大写字母</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】详谈迭代</title>
    <url>/2018/09/23/%E3%80%90python%E3%80%91%E8%AF%A6%E8%B0%88%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<p>Python迭代方法for可以说是与C#的foreach惊人的相似，在这一章无疑对C#程序员更容易理解，但是这里还是小谈几点<br><a id="more"></a></p>
<h1 id="①应用范围："><a href="#①应用范围：" class="headerlink" title="①应用范围："></a>①应用范围：</h1><p>理论上，使用for迭代可适用于各种集合，包括但不限于我们之前学习的：</p>
<p>1. <strong>有序集合</strong>：list，tuple，str和unicode；</p>
<ol>
<li><strong>无序集合</strong>：set</li>
<li><strong>无序集合并且具有 key-value 对</strong>：dict</li>
</ol>
<h1 id="②List索引迭代"><a href="#②List索引迭代" class="headerlink" title="②List索引迭代"></a>②List索引迭代</h1><p>Python中，<strong>迭代永远是取出元素本身，而非元素的索引。</strong>若想提取出元素索引，可以使用<strong>enumerate() 函数</strong>：</p>
<p>>&gt;&gt; L = [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’]</p>
<blockquote>
<blockquote>
<blockquote>
<p>for index, name in enumerate(L):<br>…     print index, ‘-‘, name<br>…<br>0 - Adam<br>1 - Lisa<br>2 - Bart<br>3 - Paul</p>
</blockquote>
</blockquote>
</blockquote>
<p>其实，enumerate() 函数是将链表的索引与元素捆绑形成一个个Tuple链表，提取时是提取Tuple列表的值而已：</p>
<p><strong>[‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’]</strong></p>
<p>👇</p>
<p><strong>[(0, ‘Adam’), (1, ‘Lisa’), (2, ‘Bart’), (3, ‘Paul’)]</strong></p>
<p>因此，迭代的每一个元素实际上是一个tuple：</p>
<p>for t in enumerate(L):<br>    index = t[0]<br>    name = t[1]<br>    print index, ‘-‘, name</p>
<p>如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：</p>
<p>for index, name in enumerate(L):<br>    print index, ‘-‘, name</p>
<p>这样不但代码更简单，而且还少了两条赋值语句。</p>
<h1 id="③dict中value的迭代"><a href="#③dict中value的迭代" class="headerlink" title="③dict中value的迭代"></a>③dict中value的迭代</h1><p>我们已经了解了<strong>dict对象</strong>本身就是可<strong>迭代对象</strong>，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。 如果我们希望迭代 dict 对象的value，应该怎么做？ <strong>方法一：直接迭代出key，再通过key得到value，然后打印出value</strong> <strong>方法二：</strong> dict 对象有一个 <strong>values() 方法</strong>，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：</p>
<p>d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59 }<br>print d.values()</p>
<h1 id="85-95-59"><a href="#85-95-59" class="headerlink" title="[85, 95, 59]"></a>[85, 95, 59]</h1><p>for v in d.values():<br>    print v</p>
<h1 id="85"><a href="#85" class="headerlink" title="85"></a>85</h1><h1 id="95"><a href="#95" class="headerlink" title="95"></a>95</h1><h1 id="59"><a href="#59" class="headerlink" title="59"></a>59</h1><p>如果仔细阅读Python的文档，还可以发现，dict除了<strong>values()</strong>方法外，还有一个 <strong>itervalues()</strong> 方法，用 <strong>itervalues()</strong> 方法替代 <strong>values()</strong> 方法，迭代效果完全一样：</p>
<p>d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59 }<br>print d.itervalues()</p>
<h1 id=""><a href="#" class="headerlink" title=""></a><dictionary-valueiterator object at 0x106adbb50></h1><p>for v in d.itervalues():<br>    print v</p>
<h1 id="85-1"><a href="#85-1" class="headerlink" title="85"></a>85</h1><h1 id="95-1"><a href="#95-1" class="headerlink" title="95"></a>95</h1><h1 id="59-1"><a href="#59-1" class="headerlink" title="59"></a>59</h1><p><strong>那这两个方法有何不同之处呢？</strong> 1. <strong>values()</strong> 方法实际上把一个 dict 转换成了包含 value 的list。 2. 但是 <strong>itervalues()</strong> 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 3. 打印 itervalues() 发现它返回一个 <dictionary-valueiterator> 对象，这说明在Python中，<strong>for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等</strong>，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。 <strong>如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。</strong></p>
<h1 id="④dict同时迭代key和value"><a href="#④dict同时迭代key和value" class="headerlink" title="④dict同时迭代key和value"></a>④dict同时迭代key和value</h1><p><strong>方法一：直接迭代出key，再通过key得到value，然后一起打印</strong> <strong>方法二：使用items()方法</strong> 首先，我们看看 dict 对象的 <strong>items()</strong> 方法返回的值：</p>
<p>>&gt;&gt; d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59 }</p>
<blockquote>
<blockquote>
<blockquote>
<p>print d.items()<br>[(‘Lisa’, 85), (‘Adam’, 95), (‘Bart’, 59)]</p>
</blockquote>
</blockquote>
</blockquote>
<p>可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：</p>
<p>>&gt;&gt; for key, value in d.items():<br>…     print key, ‘:’, value<br>…<br>Lisa : 85<br>Adam : 95<br>Bart : 59</p>
<p>和 values() 有一个 itervalues() 类似， <strong>items()</strong> 也有一个对应的 <strong>iteritems()</strong>，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】逻辑语句</title>
    <url>/2018/09/22/%E3%80%90python%E3%80%91%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="①if选择语句"><a href="#①if选择语句" class="headerlink" title="①if选择语句"></a>①if选择语句</h1><p>选择语句在C#使用以下格式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> age=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span>(age&gt;=<span class="number">18</span>)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Your age is &quot;</span>+age);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;adult&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;End&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>而在Python中，if语句如此实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;your age is&#x27;</span>, age</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;adult&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;child&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;END&#x27;</span></span><br></pre></td></tr></table></figure>
<p>通过以上对比可以看出， 1.相比C#的大括号{}，Python<strong>使用缩进来分辨代码块</strong>。 2.相比C#的括号()，Python<strong>使用：区分辨条件与代码块</strong>。 另外需要注意的是，Python使用<strong>4个空格</strong>来缩进代码块。 如果在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;your age is&#x27;</span>, age</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">&#x27;adult&#x27;</span></span><br><span class="line">...</span><br><span class="line">your age <span class="keyword">is</span> <span class="number">20</span></span><br><span class="line">adult</span><br></pre></td></tr></table></figure>
<p>那么现在又有了一个问题，就是如果出现嵌套选择语句，即else if语句，靠缩进区分代码块的Python的代码就会看起来很冗余，但是Python就是为了简单而特化的语言，肯定不会允许这种事情发生，所以else if可以并起来写成<strong>elif</strong>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;adult&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;teenager&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;kid&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;baby&#x27;</span></span><br></pre></td></tr></table></figure>
<p>switch呢？没了！<img src="http://47.94.231.166/wp-content/uploads/2018/04/36.png" alt=""></p>
<h1 id="②循环语句"><a href="#②循环语句" class="headerlink" title="②循环语句"></a>②循环语句</h1><p>C#中的for、while、do…while三大循环语句在Python中会以怎样的形式出现呢？</p>
<h2 id="1-for"><a href="#1-for" class="headerlink" title="1.for"></a>1.for</h2><p>for语句在Python中<strong>相当于C#的foreach</strong>而不是for，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Bart&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> L:</span><br><span class="line">    <span class="built_in">print</span> name</span><br></pre></td></tr></table></figure>
<h2 id="2-while"><a href="#2-while" class="headerlink" title="2.while"></a>2.while</h2><p>while语句倒还是老样子，当条件式<strong>满足</strong>时就进行循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">10</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt; N:</span><br><span class="line">    <span class="built_in">print</span> x</span><br><span class="line">    x = x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>do…while呢？没了！<img src="http://47.94.231.166/wp-content/uploads/2018/04/36.png" alt=""> break、continue还是老样子，这个就不多讲了，循环语句多重嵌套注意缩进。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>从零开始的代码学习计划</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【QSNetBoot】少林寺章丘分寺网络启动工具</title>
    <url>/2019/06/02/%E3%80%90qsnetboot%E3%80%91%E5%B0%91%E6%9E%97%E5%AF%BA%E7%AB%A0%E4%B8%98%E5%88%86%E5%AF%BA%E7%BD%91%E7%BB%9C%E5%90%AF%E5%8A%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><img src="http://upane.cn/wp-content/uploads/2018/04/78.png" alt=""><br><a id="more"></a></p>
<blockquote>
<p><strong>feature：</strong> 1. 开机自动连接校园网 2.没了</p>
</blockquote>
<h2 id="①可视化界面："><a href="#①可视化界面：" class="headerlink" title="①可视化界面："></a>①可视化界面：</h2><p>启动之后可见如下界面： <img src="https://www.z4a.net/images/2019/06/02/QSNetBoot_2019-06-02_15-16-22.png" alt=""> 注意启动设置第二个那个选项，勾选后将不会在连接网络后自动唤起浏览器，防止自动连接后也会弹出浏览器的尴尬情况，默认是不勾选的。如果勾选的话连接其他wifi时（比如肯德基等等需要认证的wifi）也不会自动唤起浏览器了。此时需要手动打开浏览器然后随便打开一个网页，不出意外的话对方路由器将挟持该链接到登陆页面。 登陆成功会有提示： <img src="https://www.z4a.net/images/2019/06/02/2019-06-02_15-17-53.png" alt=""> 失败也会有提示： <img src="https://www.z4a.net/images/2019/06/02/2019-06-02_15-18-33.png" alt=""> 如果啥提示都没有就是程序崩了(应该不会崩溃，如果真崩了可以与我联系)</p>
<h2 id="②直接连接"><a href="#②直接连接" class="headerlink" title="②直接连接"></a>②直接连接</h2><p>如果需要制作直接连接脚本，可以在本程序运行时添加“-c”的参数，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QSNetBoot.exe -c</span><br></pre></td></tr></table></figure>
<p>这样以来程序将直接运行连接逻辑，跳过可视化界面。</p>
<h3 id="目前迭代版本"><a href="#目前迭代版本" class="headerlink" title="目前迭代版本"></a>目前迭代版本</h3><p>Ver 0.9Beta 2019/6/2</p>
<h3 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h3><p><a href="http://upane.cn/wp-content/uploads/2019/06/Setup.zip">setup.zip</a> github项目页：<a href="https://github.com/yimig/QSNetBoot">https://github.com/yimig/QSNetBoot</a> (旧版本还没更新，目前还在摸索github中)</p>
<h2 id="不多说了，下周二还要武术考试"><a href="#不多说了，下周二还要武术考试" class="headerlink" title="不多说了，下周二还要武术考试"></a>不多说了，下周二还要武术考试</h2><p><img src="http://upane.cn/wp-content/uploads/2018/04/36.png" alt=""></p>
]]></content>
      <categories>
        <category>Project.IDEA</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>QSNetBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>【Regex】正则表达式语法</title>
    <url>/2019/04/27/%E3%80%90regex%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>正则表达式是我们处理文本最常用的手段，它有自己的语法，入门容易但是精通很难，下面就结合例子简单谈一下其语法，帮助大家轻松入门。<br><a id="more"></a><br><strong>语法规范：</strong></p>
<ol>
<li>严格区分大小写</li>
<li>寻找满足表达式的字符串，找到就返回true，否则返回false</li>
</ol>
<p>示例</p>
<p>含义</p>
<p>涉及语法</p>
<p>含义</p>
<p>a</p>
<p>找a</p>
<p>直接写</p>
<p>存在性检查</p>
<p>a|b</p>
<p>a或b</p>
<p>|</p>
<p>或</p>
<p>[ab]</p>
<p>a或b</p>
<p>[]</p>
<p>中括号内也是或关系</p>
<p>[a-z]</p>
<p>a到z（任意小写字母）</p>
<p>-</p>
<p>区间</p>
<p>[A-z]</p>
<p>任意字母</p>
<p>a[bde]c</p>
<p>以a开头，以c结尾，中间可以是c、d、e</p>
<p>[^ab]</p>
<p>除了a、b之外的字符</p>
<p>^</p>
<p>除了（非）</p>
<p>[^0-9]</p>
<p>除了数字</p>
<p>a{3}</p>
<p>a连续出现3次</p>
<p>{n}</p>
<p>量词，正好出现n次</p>
<p>(ab){3}</p>
<p>ab组合连续3次</p>
<p>()</p>
<p>括号内视作整体</p>
<p>b{1,3}</p>
<p>b连续出现1次或2次或3次</p>
<p>{m,n}/{m,}</p>
<p>出现m到n次/出现m次以上</p>
<p>b+</p>
<p>至少一个b</p>
<p>+</p>
<p>至少出现一次，相当于{1,}</p>
<p>b*</p>
<p>0个或多个</p>
<p>*</p>
<p>相当于{0,}</p>
<p>b?</p>
<p>0个或1个</p>
<p>?</p>
<p>要么没有，要么只出现一次，相当于{0,1}</p>
<p>^a</p>
<p>以a开头</p>
<p>^_</p>
<p>以_开头</p>
<p>a$</p>
<p>结尾为a</p>
<p>_$</p>
<p>结尾为_</p>
<p>^a$</p>
<p>完全匹配a</p>
<p>^_$</p>
<p>完全匹配字符串_</p>
<p>.</p>
<p>任意字符</p>
<p>\\</p>
<p>转义字符</p>
<p>\\w</p>
<p>任意字母、数字、下划线，相当于[A-z0-9_]</p>
<p>\\W</p>
<p>除了字母、数字、下划线，相当于[^A-z0-9_]</p>
<p>\\d</p>
<p>任意数字，相当于[0-9]</p>
<p>\\D</p>
<p>除了数字，相当于[^0-9]</p>
<p>\\s</p>
<p>空格</p>
<p>\\S</p>
<p>除了空格</p>
<p>\\b</p>
<p>单词边界，应用后，在”hello kids”中查找”i”将返回false，因只会匹配整个单词</p>
<p>\\B</p>
<p>除了单词边界</p>
]]></content>
      <categories>
        <category>Web</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>WEB</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>【WPF】得到ListViewItem</title>
    <url>/2018/12/01/%E3%80%90wpf%E3%80%91%E5%BE%97%E5%88%B0listviewitem/</url>
    <content><![CDATA[<p>由于绑定了数据的原因，得到数据当然方便了许多，直接遍历就可以了，但是要是对其中一项的外观进行改变就麻烦了，找了很长时间依旧无果。后来偶然找到了一种方法就是使用<code>ItemContainerGenerator</code>得到ListViewItem，但是又一直返回空值，又翻了翻，终于找到了解决方法：就是使用<code>UpdateLayout()</code>和<code>ScrollIntoView(data)</code>定位数据！<br><a id="more"></a><br><strong>这个方法好像对ListBox无效，因为其没有ScrollIntoView()方法，Ummm，一概使用ListView替代吧。</strong></p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>ListView的<code>ItemContainerGenerator.ContainerFromItem()</code>方法无法直接获得ListViewItem，它需要定位数据的位置。<strong>如果需要获得的项目在当前页面，也就是在不需要滚动就能找到的位置，那么需要在之前使用ListView的<code>UpdateLayout()</code>方法刷新当前页面，如果需要获得的项目不在当前页面，也就是在需要滚动才能找到的位置，那么需要使用ListView的<code>ScrollIntoView(data)</code>方法滚动到那里</strong>。 综合来说，如果是需要查询数据的位置，即不知道数据出现在哪，就先刷新当前页面看看项目是不是在当前页面，如果依然返回null，就滚动到那里获得。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p><strong>下面是对于任意类型（用泛型TData代替）数据从ListView中提取出ListViewItem的方法</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListViewItem <span class="title">GetItem</span>&lt;<span class="title">TData</span>&gt;(<span class="params">ListView lv,TData data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lv.UpdateLayout();</span><br><span class="line">    ListViewItem item = lv.ItemContainerGenerator.ContainerFromItem(data) <span class="keyword">as</span> ListViewItem;</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="literal">null</span>）</span><br><span class="line">    &#123;</span><br><span class="line">        lv.ScrollIntoView(data);</span><br><span class="line">        item = lv.ItemContainerGenerator.ContainerFromItem(data) <span class="keyword">as</span> ListViewItem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Aha，这样就可以跳过数据了！ CSDN的各路大神说了半天都没说到点上，导致无端耗费了很多时间。</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>从零开始的代码学习计划</category>
      </categories>
      <tags>
        <tag>C#学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【XPath】浅谈XPath</title>
    <url>/2019/05/08/%E3%80%90xpath%E3%80%91%E6%B5%85%E8%B0%88xpath/</url>
    <content><![CDATA[<p>XPath是我们解析与操作网页数据非常好用的一种工具，它也是也是一个独立的语言，类似正则表达式，下面就让我们一起简单学习一下它的语法与应用场景吧。<br><a id="more"></a></p>
<h2 id="①XPath？"><a href="#①XPath？" class="headerlink" title="①XPath？"></a>①XPath？</h2><ol>
<li><strong>解析xml的一种语言（HTML是XML的子集)，广泛用于解析HTML数据</strong></li>
<li>几乎所有语言都能使用XPath，如Java和C语言</li>
<li>除了XPath还有其他手段用于xml解析，如beautifulSoup、lxmal、Dom、SAX、Dom4J、minixml等</li>
</ol>
<h2 id="②语法"><a href="#②语法" class="headerlink" title="②语法"></a>②语法</h2><ol>
<li><strong>层级：/ 直接子级，// 跳子级</strong></li>
<li><strong>属性：@ 属性访问</strong></li>
<li><strong>函数：contains()、text()等</strong></li>
</ol>
<h2 id="③使用XPath"><a href="#③使用XPath" class="headerlink" title="③使用XPath"></a>③使用XPath</h2><h3 id="Ⅰ-在浏览器中使用XPath："><a href="#Ⅰ-在浏览器中使用XPath：" class="headerlink" title="Ⅰ.在浏览器中使用XPath："></a>Ⅰ.在浏览器中使用XPath：</h3><p>打开任意网页→按下F12进入开发者模式→按下Ctrl+F弹出搜索框→输入XPath语法进行搜索 <img src="https://www.z4a.net/images/2019/05/08/chrome_2019-05-08_07-45-32.png" alt=""> <strong>例子：</strong></p>
<p>XPath代码</p>
<p>含义</p>
<p>//div</p>
<p>查找所有的div</p>
<p>//div[@class=”A”]</p>
<p>查找类名为A的div</p>
<p>//div[@class=”A”]//div[contains(@class,”B”)]</p>
<p>查找类名为A的div中类命包含字符B的div</p>
<p>//div[@class=”A”]//div[contains(@class,”B”)]/a/text()</p>
<p>查找类名为A的div中类命包含字符B的div中a标签包含的文字</p>
<h3 id="Ⅱ-在JS中使用XPath查找标签"><a href="#Ⅱ-在JS中使用XPath查找标签" class="headerlink" title="Ⅱ.在JS中使用XPath查找标签"></a>Ⅱ.在JS中使用XPath查找标签</h3><h4 id="㈠使用documnet-evaluate-方法"><a href="#㈠使用documnet-evaluate-方法" class="headerlink" title="㈠使用documnet.evaluate()方法"></a>㈠使用documnet.evaluate()方法</h4><p><strong>注意！该方法不可在IE中使用！</strong> 参考：<a href="http://www.w3school.com.cn/xmldom/met_document_evaluate.asp">W3C</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/evaluate">MDN</a> 形式一：搜索多个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anodes=<span class="built_in">document</span>.evaluate(<span class="string">&quot;这里放置XPath代码&quot;</span>, <span class="built_in">document</span>, <span class="literal">null</span>,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//遍历搜索结果：</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;anodes.snapshotLength;i++)alert(anodes.snapshotItem(i));</span><br></pre></td></tr></table></figure>
<p>形式二：搜索一个元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anodes=<span class="built_in">document</span>.evaluate(<span class="string">&quot;这里放置XPath代码&quot;</span>, <span class="built_in">document</span>, <span class="literal">null</span>,XPathResult.ANY_TYPE, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//遍历搜索结果：</span></span><br><span class="line">anodes.iterateNext();<span class="comment">//搜索到的第一个元素</span></span><br><span class="line"><span class="comment">//再次使用anodes.iterateNext();可得到搜索到的第二个元素</span></span><br></pre></td></tr></table></figure>
<h3 id="㈡使用selectNodes-方法"><a href="#㈡使用selectNodes-方法" class="headerlink" title="㈡使用selectNodes()方法"></a>㈡使用selectNodes()方法</h3><p><strong>注意！该方法仅可在IE中使用</strong> 搜索多个元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nodeObject.selectNodes(<span class="string">&quot;这里放置XPath代码&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>参考：<a href="http://www.w3school.com.cn/xmldom/met_node_selectnodes.asp">W3C</a> 搜索一个元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nodeObject.selectSingleNode(<span class="string">&quot;这里放置XPath代码&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>参考：<a href="http://www.w3school.com.cn/xmldom/met_node_selectsinglenode.asp">W3C</a></p>
]]></content>
      <categories>
        <category>Web</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>XPath</tag>
      </tags>
  </entry>
  <entry>
    <title>【Batch】一键设置Java环境</title>
    <url>/2018/11/17/%E3%80%90%E6%89%B9%E5%A4%84%E7%90%86%E3%80%91%E4%B8%80%E9%94%AE%E8%AE%BE%E7%BD%AEjava%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">net session &gt;nul 2&gt;&amp;1</span><br><span class="line">if not &quot;%errorLevel%&quot; &#x3D;&#x3D; &quot;0&quot; (</span><br><span class="line">  echo Set UAC &#x3D; CreateObject^(&quot;Shell.Application&quot;^) &gt; &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">  echo UAC.ShellExecute &quot;%~s0&quot;, &quot;%*&quot;, &quot;&quot;, &quot;runas&quot;, 1 &gt;&gt; &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">  &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">  exit &#x2F;b 2</span><br><span class="line">)</span><br><span class="line">rem 提升权限为管理员</span><br><span class="line"></span><br><span class="line">echo 您确定要修复环境变量吗？重复修复可能导致错误！</span><br><span class="line">echo 任意键继续，若需退出，请直接关闭窗口。  </span><br><span class="line">pause&gt;nul</span><br><span class="line">for &#x2F;f &quot;tokens&#x3D;2*&quot; %%a in (&#39;reg query &quot;HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\JDK&quot; &#x2F;v CurrentVersion 2^&gt;nul&#39;) do set &quot;a&#x3D;%%b&quot;</span><br><span class="line">for &#x2F;f &quot;tokens&#x3D;2*&quot; %%a in (&#39;reg query &quot;HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\JDK\%a%&quot; &#x2F;v JavaHome 2^&gt;nul&#39;) do set &quot;javapath&#x3D;%%b&quot; </span><br><span class="line"></span><br><span class="line">echo 读取到的java环境地址为：%javapath%</span><br><span class="line"></span><br><span class="line">set path_&#x3D;%path%</span><br><span class="line"></span><br><span class="line">echo 备份注册表中...</span><br><span class="line">echo WindowsRegistryEditorVer-sion5.00&gt;backup.reg</span><br><span class="line">echo [HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Control\Session Manager\Environment]&gt;&gt;backup.reg</span><br><span class="line">echo &quot;Path&quot;&#x3D;dword:%path%&gt;&gt;backup.reg</span><br><span class="line"></span><br><span class="line">echo 正在修改环境变量...</span><br><span class="line">echo 写入环境变量&quot;JAVA_HOME&quot;...</span><br><span class="line">setx &#x2F;m &quot;JAVA_HOME&quot; &quot;%javapath%</span><br><span class="line">echo 写入环境变量&quot;CLASSPATH&quot;...</span><br><span class="line">setx &#x2F;m &quot;CLASSPATH&quot; &quot;.;%%JAVA_HOME%%\lib\dt\jar;%%JAVA_HOME%%\lib.tools.jar&quot;</span><br><span class="line">echo 写入环境变量&quot;Path&quot;...</span><br><span class="line">setx &#x2F;m &quot;Path&quot; &quot;%_path%;%%JAVA_HOME%%\bin&quot;</span><br><span class="line"></span><br><span class="line">echo 程序结束！</span><br><span class="line">pause&gt;nul</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Batch</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】VS中的快速操作</title>
    <url>/2018/09/20/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91vs%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="①快捷键篇："><a href="#①快捷键篇：" class="headerlink" title="①快捷键篇："></a>①快捷键篇：</h1><p>预格式化：<strong>按住Ctrl，再依次按K和F</strong> 收起所有方法：<strong>Ctrl+M+O</strong> 分步运行：<strong>F11</strong> 快速查找/替换窗口：<strong>Ctrl+F</strong>    </p>
<h1 id="②功能篇"><a href="#②功能篇" class="headerlink" title="②功能篇"></a>②功能篇</h1><p>重构：<strong>对变量名/方法名/对象名/类名右键&gt;重命名</strong>   [不断更新]</p>
]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】Walkman Playlist Tools使用教程</title>
    <url>/2018/09/10/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91walkman-playlis-tools%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>该教程已经过期：最新版请见：<a href="http://upane.cn/archives/1140">【教程】Walkman Playlist Tools使用教程（第二版）</a> Hi~ o(_￣▽￣_)ブ大家好，这次带来了新的应用Walkman Playlist Tools，希望大家能够喜欢。那么为什么要做这个应用呢？其实一切的起源都在这里：<a href="http://tieba.baidu.com/p/5555729272">【求助】zx300怎样同步播放列表？</a> 其实吧，那篇帖子根本没更完，因为后面说的那个用批处理生成的播放列表它 <strong>根本不能用</strong> ……因为zx300这个播放器需要的播放列表文件里有音乐长度的信息，可是批处理只能得到文件名、路径等很基础的信息，所以我等只好作罢。很巧的是前几天刚刚接触了Bass音频库，然后立刻就想到了这个项目或许能成！于是连续伏案几天（很羞耻的拟声词）地就做出来了。 废话说多了，那么我们开始教程吧。<br><a id="more"></a></p>
<h1 id="①基础功能"><a href="#①基础功能" class="headerlink" title="①基础功能"></a>①基础功能</h1><p><a href="http://upane.cn/archives/509">在这里</a>下载压缩包后，把解压后的文件一起放到一个合适的地方，<strong>它们可不能分开放哦！</strong>然后在桌面创建一个快捷方式。首次启动后，程序将要求选择Walkman所在的盘符，（如下图）这时候把Walkman<strong>连接电脑</strong>，从我的电脑里找到其盘符输入即可，如果有SD卡的话也可以勾选使用SD卡并选择SD卡所在的盘符。最后那个缓存是为了加快启动速度的（不能每次启动都扫描音乐吧），具体大小取决于音乐的多少，一般不会大于1M。 <a href="http://47.94.231.166/wp-content/uploads/2018/09/explorer_2018-09-10_21-43-44.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/explorer_2018-09-10_21-43-44.png" alt=""></a> 一切准备妥当后，直接点击右上角关闭即可。这时就会弹出主窗口了。如果这时出现一大堆的库加载错误的问题可能是下载错了哦（比如64位下载了32位的）。然后点击左半边表单下方的“<strong>刷新默认地址</strong>”即可向列表中加载音乐信息了，<strong>扫描可能需要较长时间，并且可能占用大量内存</strong>（比如很多dsd歌曲），这也是本软件下一步需要优化的地方，不过好在有缓存文件，在下一次打开程序后就不会占用很多内存了。 <a href="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-44-38.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-44-38.png" alt=""></a> 扫描信息会在左下的状态栏实时更新（上图）。 扫描完成后即出现下面结果。 <a href="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-46-00-1.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-46-00-1.png" alt=""></a> 勾选左侧列表要添加入播放列表的音乐，然后<strong>点击中间的“→”按钮</strong>即可移到播放列表中。（如下图） <a href="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-46-40.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-46-40.png" alt=""></a> <strong>双击右侧列表名</strong>（图中时“New List 1”），即可对播放列表命名（如下图） <a href="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-47-30.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-47-30.png" alt=""></a> 这里我们命名为“英语” <a href="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-47-44-1.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-47-44-1.png" alt=""></a> 点击右侧表单下方的“<strong>保存</strong>”，即可将播放列表存储如Walkman，注意，保存前要确认电脑与Walkman通信良好。保存效果如下： <img src="http://47.94.231.166/wp-content/uploads/2018/09/screenshot_20180910_213205960.png" alt=""> 对了，创建SD卡播放列表和上面顺序一样，只不过左右列表都要保持在“SD卡”的标签页上。<strong>Walkman不允许一个播放列表混合本机内存的音乐和SD卡内存的音乐哦。</strong></p>
<h1 id="②批量保存"><a href="#②批量保存" class="headerlink" title="②批量保存"></a>②批量保存</h1><p>刚刚我们学习了保存一个播放列表的方法，如果我们想同时管理多个播放列表呢？当然可以！点击右侧列表下方的<strong>“载入播放列表”</strong>即可将Walkman或者SD卡的播放列表载入程序，进行操作（如下图） <a href="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-48-53.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-48-53.png" alt=""></a> 点击最右边的的长条按钮“+”，即可创建一个新的播放列表，点击“-”，即可从程序中删除一个播放列表，<strong>注意这里的删除并没有删除文件</strong>，只是从本程序里找不到了，若想删除文件可以进入相应设备的Music文件夹内进行手动删除。 编辑完成后，点击<strong>“全部保存”</strong>即可一次性保存目前所有播放列表。</p>
<h1 id="③编辑列表"><a href="#③编辑列表" class="headerlink" title="③编辑列表"></a>③编辑列表</h1><p>这个板块介绍的内容对<strong>左右列表都适用</strong>。 <strong>快速多选</strong>：选择一条信息，按住Shift在选择另一条信息即可选定多个内容，然后对其中任何一个打勾都可以框选这其中的所有内容。 <strong>“删除”按钮</strong>：删除打勾的信息 <strong>“清空”按钮</strong>：清空整个列表 <strong>“清空勾选”按钮</strong>：清空所有勾选，将所有勾选改回未勾选，信息本身不做处理</p>
<h1 id="④向设备导入音乐"><a href="#④向设备导入音乐" class="headerlink" title="④向设备导入音乐"></a>④向设备导入音乐</h1><p>选择标题栏的<strong>“文件”&gt;“打开(…)并复制入设备”&gt;“打开音乐文件”</strong> 选择音乐文件后将会把该音乐复制入设备（机身内存或者SD卡，具体看当时左边列表目前状态是在“Walkman”还是“SD卡”），然后在左侧列表添加该音乐的信息，可以对其进行归类操作。打开文件夹同理。 <a href="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-49-20.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-49-20.png" alt=""></a></p>
<h1 id="⑤自动归类"><a href="#⑤自动归类" class="headerlink" title="⑤自动归类"></a>⑤自动归类</h1><p>选择标题栏的“<strong>自动生成</strong>”即可按照列表提示自动生成播放列表。 目前可以按<strong>“文件夹名”、“音乐格式”、“标题语言”、“艺术家”</strong>进行自动排序 这里，<strong>文件夹名</strong>代表包含音乐文件的<strong>最底层文件夹</strong>，如“I:\\Music\\Text1\\Text2\\testmusic.mp3”，文件夹名指的是“Text2”。 <strong>音乐格式</strong>指的是音乐的<strong>拓展名</strong> 标题语言目前默认支持10国11种语言（中文简/繁体），分别是 <strong>泰语 芬兰语 法语 意大利语 俄语 西班牙语 日语 英语 韩语 中文（简） 中文（繁）</strong>，还可以另外下载语言拓展包拓展至52国语言，但是因为样本比较少（一国样本包20~80KB），识别效果堪忧，不要过度依赖，毕竟维基百科那种真正的检测样本包一个都几个G，目前的效果已经不错了。 下图为按格式分类和按标题语言分类的示例，可以选择只保存一个播放列表或者全部保存，保存时保存到主页面，<strong>并不是保存到设备里了</strong>，在主页面保存才会保存到设备里！ <a href="http://47.94.231.166/wp-content/uploads/2018/09/explorer_2018-09-10_21-50-07.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/explorer_2018-09-10_21-50-07.png" alt=""></a><a href="http://47.94.231.166/wp-content/uploads/2018/09/explorer_2018-09-10_21-50-32.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/explorer_2018-09-10_21-50-32.png" alt=""></a> 另外，可以在<strong>“设置”&gt;“通用”&gt;“规则”</strong>中对自动生成的歌曲数量进行筛选，如下图<a href="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-52-16.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-52-16.png" alt=""></a> 如果在使用按照语言进行自动分类时出现以下提示，系检测库原因，<strong>关掉后再次打开即可</strong>（如果有未保存的播放列表可以点击“<strong>继续</strong>”，来返回主页面继续保存操作） <a href="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-51-39.png"><img src="http://47.94.231.166/wp-content/uploads/2018/09/Walkman-Playlist-Tools_2018-09-10_21-51-39.png" alt=""></a>  </p>
<h1 id="⑥生成通用型播放列表"><a href="#⑥生成通用型播放列表" class="headerlink" title="⑥生成通用型播放列表"></a>⑥生成通用型播放列表</h1><p>通用型播放列表是给<strong>电脑</strong>上的播放器使用的，它带有完整的路径，所以Walkman并不能读取它，生成该文件后即可在电脑播放器使用Walkman上的播放列表。 生成方法在标题栏<strong>“文件”&gt;“生成通用型播放列表”&gt;选择保存</strong>即可。  </p>
<h1 id="⑦其他"><a href="#⑦其他" class="headerlink" title="⑦其他"></a>⑦其他</h1><p>1.为了节约内存，默认情况下MP3、FLAC格式的音乐信息是从Windows详细信息数据库里获得的。其他格式都是通过Bass音乐库得到的，目前由于插件Tags不明原因地无法使用，故需将音乐载入内存，如果又是遇到文件体积本身就比较大的格式（如DSD、WAV）在检测信息时就会消耗大量内存。<strong>但是，由于系统不同，Windows详细信息数据库可检测的内容也有差别，所以有的用户可能出现默认情况下无法检测音乐信息的情况，特别是FLAC格式，如果出现这种情况，您可以前往“设置”&gt;“修复”&gt;勾选“全部使用Bass库或的歌曲信息”。与之相同的，由于不管是MP3还是其他格式的音乐都被载入内存，您的内存可能会出现特别恐怖的占用量，甚至导致内存溢出，程序被迫退出。请酌情使用！</strong> 2.如果不小心清空了左边的音乐库列表，重新刷新列表又太慢，可以选择点击<strong>“文件”&gt;“重载数据库（恢复清空）”</strong>，这样程序将会加载上一次的缓存，节省了刷新时间。    </p>
<h2 id="以上就是所有教程了，如果还有不懂的地方欢迎在下方留言！"><a href="#以上就是所有教程了，如果还有不懂的地方欢迎在下方留言！" class="headerlink" title="以上就是所有教程了，如果还有不懂的地方欢迎在下方留言！"></a>以上就是所有教程了，如果还有不懂的地方欢迎在下方留言！</h2>]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Walkman Playlist Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】Walkman Playlist Tools使用教程（第二版）</title>
    <url>/2019/02/10/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91walkman-playlist-tools%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p><strong>软件下载页面请点击这里→<a href="http://upane.cn/archives/509">【C#】Walkman Playlist Tools</a></strong> 因为这个版本与之前的版本相比改动较大，所以在这里重新开一个教程。 那么我们直接进入正题吧。<br><a id="more"></a></p>
<hr>
<h2 id="①准备工作"><a href="#①准备工作" class="headerlink" title="①准备工作"></a>①准备工作</h2><p>软件安装完毕后打开，您应该看到的是如下界面： <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_15-40-56.png" alt=""> 它可以分为两个区域： 左边的<strong>工作区</strong>区域和右边的<strong>播放列表</strong>区域。它们都可以存储音乐信息，但是只有播放列表能保存，工作区的内容除了第一个子区域<strong>音乐库</strong>外每次程序关闭都会被清除。音乐库中的信息就是您的Walkman中存储的所有音乐，播放列表和其他工作区的信息都是从音乐库中复制出来的。 下面我们准备向音乐库中添加音乐信息： <strong>Step 1：将您的Walkman连接上电脑，并且打开文件传输功能</strong> <strong>Step 2：选择导航栏中的”设置”选项，修改音乐的默认存放路径</strong> <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_16-03-01.png" alt=""> <strong>Step 3：关闭设置界面，点击程序左上角的”扫描默认地址”按钮</strong> <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_16-06-53.png" alt=""> <strong>Step 4：等待扫描完毕，音乐库中就会出现您设备中的音乐</strong> <strong>注意：如果您还想扫描SD卡的音乐，请将工作区或者播放列表的选项卡选择到”SDcard”位置，然后再点击一次扫描按钮。</strong></p>
<h2 id="②制作播放列表"><a href="#②制作播放列表" class="headerlink" title="②制作播放列表"></a>②制作播放列表</h2><p>做完准备工作后就可以着手制作播放列表了，<strong>首先点击播放列表区域上方的第一个按钮”新建播放列表”按钮建立一个播放列表</strong> <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_16-18-06.png" alt=""> <strong>然后在工作区中勾选需要转移到播放列表的音乐，点击刚刚建立的播放列表将其选中，然后点击中间的”&gt;”按钮即可将音乐信息从工作区复制到播放列表。要删除音乐信息，请将其勾选并点击工具栏中的灰色小叉号将其移除</strong> <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_16-24-01.png" alt=""> <strong>此时还可以拖动播放列表中的音乐信息来改变其顺序。若要修改播放列表的标题，请点击播放列表上方工具栏中的小笔按钮”重命名该播放列表”。在弹出的对话框中输入新标题，按下回车或者对号按钮即可完成修改</strong> <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_16-29-48.png" alt=""> <strong>若要删除播放列表，请点击播放列表上方工具栏中的小垃圾桶按钮”删除播放列表”，若要保存该播放列表，请点击工具栏的小内存卡按钮”保存目前的播放列表”</strong> <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_16-38-05.png" alt=""> <strong>当编辑了多个播放列表后，可以选择刚刚说的保存按钮旁边的小设备按钮来保存所有播放列表，另外若要载入设备中的播放列表，可以选择小垃圾桶按钮右边的同步按钮来载入播放列表，当播放列表较多时可能需要一些时间载入，请耐心等待。</strong> <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_16-45-49.png" alt=""> <strong>注意：载入的播放列表信息实际上是从音乐库中复制出来的，匹配规则是文件名。所以如果音乐库中没有找到播放列表的某些音乐那么它们将不会添加到播放列表，故请保持音乐库信息为最新信息。同理，音乐库中也不要添加相同的文件名的音乐，否则会匹配失败</strong> <strong>若要使音乐信息在播放列表间移动，请勾选要复制的音乐信息，点击工具栏最后的添加按钮，选择要添加到的播放列表即可。</strong> <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_17-11-55.png" alt=""></p>
<h2 id="③工作区操作"><a href="#③工作区操作" class="headerlink" title="③工作区操作"></a>③工作区操作</h2><p>工作区的目的是给用户一个自由操作的场地，您可以自由创建、删除、修改除音乐库的其他工作区，因为它们都不会被保存。另外工作区也是某些工具的“操作区”。 <strong>点击工作区上方工具栏中的加号按钮即可创建一个工作区，与创建播放列表相同，工作区也支持删除、重命名、移动等等操作，且按钮图标相同，这里不再赘述</strong> <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_17-00-53.png" alt=""> <strong>工作区支持试听操作，选中音乐后（不需要勾选即可），点击上方工具栏中的播放按钮即可试听，在弹出的对话框中可以暂停/继续音乐、跳转到音乐的1/4位置和快进/快退5秒。目前还不能使用拖动进度条来快进</strong> <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_17-04-46.png" alt=""></p>
<h2 id="④批量操作"><a href="#④批量操作" class="headerlink" title="④批量操作"></a>④批量操作</h2><p>该类操作在本软件的各个列表中均适用。</p>
<h4 id="1-全选按钮："><a href="#1-全选按钮：" class="headerlink" title="1.全选按钮："></a>1.全选按钮：</h4><p><img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_17-19-18.png" alt=""> 勾选目前列表中的所有数据</p>
<h4 id="2-取消全选按钮："><a href="#2-取消全选按钮：" class="headerlink" title="2.取消全选按钮："></a>2.取消全选按钮：</h4><p><img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_17-21-14.png" alt=""> 清除本列表的所有勾选状态</p>
<h4 id="3-选择反选按钮："><a href="#3-选择反选按钮：" class="headerlink" title="3.选择反选按钮："></a>3.选择反选按钮：</h4><p><img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_17-22-30.png" alt=""> 将本列表中所有的勾选状态改为不勾选，不勾选改为勾选</p>
<h4 id="4-反转选中状态按钮："><a href="#4-反转选中状态按钮：" class="headerlink" title="4.反转选中状态按钮："></a>4.反转选中状态按钮：</h4><p><img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_17-26-12.png" alt=""> 将选中的数据进行反选，利用此按钮可以将选中的项目勾选，效果见动图： <img src="http://upane.cn/wp-content/uploads/2019/02/2019-02-09_17-28-53.gif" alt=""> 这里再说两个快速选中的方法： 1.按住Ctrl可以连续选择多条数据 2.选择一条数据，然后按下Shift再选择另一条数据即可快速选择这两条数据之间的所有数据 配合该按钮使用可增加您的整理效率</p>
<h4 id="5-清空按钮"><a href="#5-清空按钮" class="headerlink" title="5.清空按钮"></a>5.清空按钮</h4><p><img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_17-34-58.png" alt=""> 清空该列表，即删除列表中的所有数据。如果不小心清空了音乐库，可以点击”文件”&gt;”重载数据库”来载入上一次关闭程序时保存的缓存数据</p>
<h4 id="6-箭头按钮"><a href="#6-箭头按钮" class="headerlink" title="6.箭头按钮"></a>6.箭头按钮</h4><p><img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-09_17-38-54.png" alt=""> 将整个工作区保存为一个播放列表，或反之</p>
<h2 id="⑤搜索音乐"><a href="#⑤搜索音乐" class="headerlink" title="⑤搜索音乐"></a>⑤搜索音乐</h2><p>工作区与播放列表上方各有一个搜索栏，它们的功能是一样的，都是为本区域<strong>目前的</strong>列表提供搜索功能。目前暂不支持全局搜索。输入搜索内容后按下回车或者放大镜按钮即可跳转并选中到相关数据，若要查看下一条数据请再次按下回车或者放大镜按钮。 <strong>注意：搜索内容仅包含歌曲标题、艺术家名称和专辑名称，搜索更多请使用“根据自定义规则生成播放列表”功能。</strong></p>
<h2 id="⑥文件操作"><a href="#⑥文件操作" class="headerlink" title="⑥文件操作"></a>⑥文件操作</h2><p>本节教程主要针对导航栏中的“文件”菜单，如果没有特殊声明，以下功能应都在其菜单中。</p>
<h4 id="1-打开-…"><a href="#1-打开-…" class="headerlink" title="1.打开(…)"></a>1.打开(…)</h4><p>打开音乐文件或者包含音乐的文件夹。<strong>特别注意，这个功能主要是为了让用户选择刚刚导入设备的音乐，节省全部刷新的时间，而不是导入电脑内的音乐，如果导入其他设备的音乐请选择打开并复制，否则将无法正确创建音乐列表。</strong></p>
<h4 id="2-打开并复制-…"><a href="#2-打开并复制-…" class="headerlink" title="2.打开并复制(…)"></a>2.打开并复制(…)</h4><p>打开音乐文件或者包含音乐的文件夹，然后复制入设备的Music文件夹内。其复制规则可在设置中选择。</p>
<h4 id="3-导入"><a href="#3-导入" class="headerlink" title="3.导入"></a>3.导入</h4><p>导入播放列表，可以导入本地播放列表和在线播放列表，其原理也是匹配音乐库中的文件，不管哪种导入方法只要音乐库中找不到对应数据都无法完整的建立列表。</p>
<h5 id="Ⅰ-导入本地播放列表"><a href="#Ⅰ-导入本地播放列表" class="headerlink" title="Ⅰ.导入本地播放列表"></a>Ⅰ.导入本地播放列表</h5><p>将本地播放列表的路径与音乐库中的数据相对比，只有路径相同才会将项目添加到列表。</p>
<h5 id="Ⅱ-导入在线播放列表"><a href="#Ⅱ-导入在线播放列表" class="headerlink" title="Ⅱ.导入在线播放列表"></a>Ⅱ.导入在线播放列表</h5><p>得到在线播放列表的标题，将其与音乐库中的数据相对比，只有标题相同才将项目添加到列表。 目前仅支持网易云歌单，URL格式如下：</p>
<ul>
<li><a href="https://music.163.com/#/playlist?id=????&amp;userid=????">https://music.163.com/#/playlist?id=????&amp;userid=????</a> （标准网页版歌单）</li>
<li><a href="https://music.163.com/m/playlist?id=????&amp;userid=????">https://music.163.com/m/playlist?id=????&amp;userid=????</a> （手机版歌单）</li>
<li><a href="http://music.163.com/playlist/????/????/?userid=????">http://music.163.com/playlist/????/????/?userid=????</a> （手机app分享歌单）</li>
<li><a href="https://music.163.com/playlist?id=????&amp;userid=????">https://music.163.com/playlist?id=????&amp;userid=????</a> （电脑客户端分享歌单）</li>
</ul>
<h4 id="4-导出"><a href="#4-导出" class="headerlink" title="4.导出"></a>4.导出</h4><p>导出播放列表，包括Walkman播放列表（内含音乐地址为相对地址）和通用播放列表（内涵音乐地址为绝对地址，包含设置的盘符）</p>
<h4 id="5-重载数据库"><a href="#5-重载数据库" class="headerlink" title="5.重载数据库"></a>5.重载数据库</h4><p>重新载入音乐库缓存，可以撤销某些对音乐库的不当操作，音乐库缓存只有在关闭程序时才会刷新</p>
<h2 id="⑦自动分类"><a href="#⑦自动分类" class="headerlink" title="⑦自动分类"></a>⑦自动分类</h2><p>自动分类界面与主界面的播放列表区域相仿，但是额外提供选择分类结果的功能，您只需勾选要保存的分类结果，然后选择右下角的保存即可。 <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-10_09-31-55.png" alt=""> 自动分类支持这几种规则：</p>
<ul>
<li>按存放文件夹名：检测文件路径的最后一个文件夹名称，并将其作为分类规则。</li>
<li>按导入时间：按音乐文件在设备中的创立时间分类，格式如：19年2月10日。</li>
<li>按音乐格式：检测音乐的拓展名并进行分类</li>
<li>按标题语言：利用J#包装的java项目<a href="https://github.com/shuyo/language-detection">language-detection</a>。该项目可以对较多样本的环境下提供可靠的结果，但是由于只检测音乐标题，样本量较少，故识别效果较差。所以软件同时提供检测歌词的选项（如果本地有歌词的话），但是如果您的歌词中存在翻译反而会降低其精确度。该选项默认是开启的，这种情况下您可以在设置中将其关闭。</li>
<li>按艺术家：按艺术家名称分类，功能与walkman本身的艺术家列表相仿，但是您可以在设置中添加歌曲数量限制以筛选常听的艺术家。</li>
<li>按年代：识别歌曲的发行时间，每十年进行一次分类，如：90后。近十年分类为近年。</li>
</ul>
<h2 id="⑧更多工具"><a href="#⑧更多工具" class="headerlink" title="⑧更多工具"></a>⑧更多工具</h2><h3 id="Ⅰ-管理播放列表"><a href="#Ⅰ-管理播放列表" class="headerlink" title="Ⅰ.管理播放列表"></a>Ⅰ.管理播放列表</h3><p>提供一个批量管理播放列表的窗口，可以对播放列表批量删除、移除，以及集合操作（连续取并集、交集） <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-10_09-56-33.png" alt=""></p>
<h3 id="Ⅱ-自动下载歌词"><a href="#Ⅱ-自动下载歌词" class="headerlink" title="Ⅱ.自动下载歌词"></a>Ⅱ.自动下载歌词</h3><p>对目前选中工作区的曲目自动补充歌词,其界面如下： <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-10_09-59-41.png" alt=""> 左边区域为待下载歌词的曲目队列，绿色曲目代表歌词自动匹配并下载成功。红色曲目代表自动匹配失败的曲目，您需要手动选择歌词下载。蓝色条目代表目前正在操作的曲目。 中间区域上方列表代表根据歌曲标题在线获取到的搜索结果，软件会根据下方提供的规则对艺术家名称进行匹配，一般无需操作，但如果匹配失败，您可以手动点击搜索结果曲目，然后再右侧歌词预览的下方点击保存按钮下载歌词。中间区域的下方有一个进度条，它是一个3秒到4秒之间的随机倒计时，在倒计时中您可以操作目前的搜索结果，当然也可以之后在左侧本地音乐队列中选择音乐再手动选取。 右侧区域提供歌词预览，该区域在在暂停时出现保存按钮，单击即可保存该歌词文件。 在程序进行中时，单击本地文件队列、在线搜索结果以及“暂停”按钮都可以暂停程序的运行状态，再次点击暂停按钮（此时应为继续按钮）即可继续自动下载歌词。 暂停后的状态如下： <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-10_10-00-00.png" alt=""></p>
<h3 id="Ⅲ-批量转换歌词格式"><a href="#Ⅲ-批量转换歌词格式" class="headerlink" title="Ⅲ.批量转换歌词格式"></a>Ⅲ.批量转换歌词格式</h3><p>在最新版walkman固件中添加了建立播放列表的功能，并且可以为其命名。但是此举还统一了Walkman的内部文本编码，导致非UTF8格式编码的歌词会出现乱码。使用此工具后软件将自动搜索目前选中设备目录中的所有歌词，并将所有非UTF8格式的歌词转换为UTF8格式，借此消除乱码状态。</p>
<h3 id="Ⅳ-根据自定义规则生成播放列表"><a href="#Ⅳ-根据自定义规则生成播放列表" class="headerlink" title="Ⅳ.根据自定义规则生成播放列表"></a>Ⅳ.根据自定义规则生成播放列表</h3><p>该工具的初识窗口可以根据您制定的规则对音乐标题进行分类，并自动生成播放列表。您可以使用分号包含多个关键字，或者使用正则表达式制定规则，如正则表达式：“^[\\u4e00-\\u9fa5]{0,}$”代表规则：只包含汉字。您可以搜索更多表达式以制定更加个性化的规则。 <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-10_10-19-47.png" alt=""> 单击“更多选项”即可对所有数据项目制定规则，开启多个规则时将得出它们的交集。 <img src="http://upane.cn/wp-content/uploads/2019/02/Walkman_Playlist_Tools_2019-02-10_10-26-25.png" alt=""></p>
<h2 id="⑨其他小提示"><a href="#⑨其他小提示" class="headerlink" title="⑨其他小提示"></a>⑨其他小提示</h2><h4 id="Ⅰ-界面缩放"><a href="#Ⅰ-界面缩放" class="headerlink" title="Ⅰ.界面缩放"></a>Ⅰ.界面缩放</h4><p>比起之前版本，目前版本由于使用了新的用户界面框架,支持了缩放操作，窗口最大化后可以得到更大的操作区域。</p>
<h4 id="Ⅱ-转移音乐的小窍门"><a href="#Ⅱ-转移音乐的小窍门" class="headerlink" title="Ⅱ.转移音乐的小窍门"></a>Ⅱ.转移音乐的小窍门</h4><p>由于所有播放列表的数据都是从音乐库中复制出来的，所以只要保证音乐库的数据最新，音乐列表的数据也是最新的，<strong>所以如果您对设备中的音乐进行了删除操作或者移动操作，只需刷新音乐库，再重新载入播放列表，所有播放列表的音乐地址就是最新的音乐地址，您直接保存即可</strong>。不需要对播放列表中的音乐路径在进行操作。</p>
]]></content>
      <categories>
        <category>Project.IDEA</category>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Walkman Playlist Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】WordPress主题、Elementor模板无法预览的解决方案</title>
    <url>/2018/11/29/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91wordpress%E4%B8%BB%E9%A2%98%E3%80%81elementor%E6%A8%A1%E6%9D%BF%E6%97%A0%E6%B3%95%E9%A2%84%E8%A7%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>前几天安装了Elementor插件，但是不知为何总是无法预览，再加上主题也一直无法预览，就抽空研究了一下，以下是解决方案：<br><a id="more"></a></p>
<h2 id="WordPress主题预览失败："><a href="#WordPress主题预览失败：" class="headerlink" title="WordPress主题预览失败："></a>WordPress主题预览失败：</h2><p>我的是一预览就这样： <a href="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-36-32.png"><img src="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-36-32-1024x517.png" alt=""></a> 去百度了很长时间也试了很多方法，甚至最后把页脚备案信息和百度统计的脚本也删了，又重置了一遍还是没用，最后翻到一个帖子说是设置里面的WordPress地址没加“WWW”,然后就看了看那个设置,原来之前我都是直接填ip，这次<strong>换成把URL填上</strong>了（没加WWW），再试试就可以了。 如图： 在“Setting→常规”中，改动之前是这样： <a href="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-36-55.png"><img src="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-36-55.png" alt=""></a> 然后我<strong>把ip换成了URL</strong>： <a href="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-37-30.png"><img src="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-37-30.png" alt=""></a> 这样再预览就没事了 <a href="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-38-34.png"><img src="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-38-34-1024x517.png" alt=""></a> 至于有没有必要加“WWW”，这里看来是没必要的。但是如果你试过之后仍然无法预览可以把“WWW”加上试试。</p>
<h2 id="Elementor模板无法预览"><a href="#Elementor模板无法预览" class="headerlink" title="Elementor模板无法预览"></a>Elementor模板无法预览</h2><p>我的是这种情况: <a href="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_17-00-15.png"><img src="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_17-00-15-1024x517.png" alt=""></a> 就一直卡在这里或者连这个界面也没有，直接添加模板会报“服务器没有响应”的错误。 查了一下问题应该是<strong>给PHP分配的内存不够</strong>导致的 可以看“Elementor→系统信息”这里确认一下： <a href="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-39-36.png"><img src="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-39-36-1024x344.png" alt=""></a> <strong>根据提示给出的网站，可以找到增加内存分配的方法：</strong> <a href="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-41-18.png"><img src="http://upane.cn/wp-content/uploads/2018/11/chrome_2018-11-29_16-41-18.png" alt=""></a> <strong>翻译过来就是找到WordPress的安装地址（我这边是Linux，在“/home/www/htdocs/”这里），找到”wp-config.php”,打开文件并在最后为其添加这一条语句：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">define(<span class="string">&#x27;WP_MEMORY_LIMIT&#x27;</span>,<span class="string">&#x27;64M&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>然后保存即可。</strong> 没这条语句的话默认应该是8M，这个是根据32M的基础上向上追加的内存，所以之前的系统信息界面上显示一共分配了40M。上面的语句就是追加64M内存，也就是说一共分配了32+64=96M内存。 Windows Service用户请注意这个网站说不要使用Windows自带的记事本等文本编辑工具进行编辑，具体原因我也不知道，估计是会改变编码格式吧。 还有一点就是我改完之后系统信息还是显示40M，不知是bug还是怎样，不过模板可以使用了。</p>
]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title>#教程#  将PS 2015的工作区转移至PS 2018</title>
    <url>/2018/07/17/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91%E5%B0%86ps-2015%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8C%BA%E8%BD%AC%E7%A7%BB%E8%87%B3ps-2018/</url>
    <content><![CDATA[<p>今天下载了PS 2018，但是发现并没有替换掉原来的PS 2015而且数据也没有同步，对于我来说PS里倒是没有什么重要的数据，但是对于之前熟悉了的工作区发生的改变感到不太适应，搜索了一下怎样备份工作区，但是网络上的教程都是针对CS2版本的，新版本早已不适用，无奈之下只好自己动手，祭出神器Everything完成了工作区的替换。这样就可以毫无遗憾地卸载PS 2015了。<br><a id="more"></a><br>1.首先找到PS 2015的工作区存放路径，这里一般是C:\\Users\\你的用户名\\AppData\\Roaming\\Adobe\\Adobe Photoshop CC 2015.5\\Adobe Photoshop CC 2015.5 Settings\\WorkSpaces (Modified)\\ 如图，我的用户名是z8442，工作区直接以明文命名，复制需要备份的工作区即可。<img src="http://47.94.231.166/wp-content/uploads/2018/07/2018-07-17_12-04-00.png" alt=""> 2.复制到PS2018的工作区路径内，一般是C:\\Users\\你的用户名\\AppData\\Roaming\\Adobe\\Adobe Photoshop CC 2018\\Adobe Photoshop CC 2018 Settings\\WorkSpaces\\ <img src="http://47.94.231.166/wp-content/uploads/2018/07/2018-07-17_12-04-41.png" alt=""> 3.这时转移已经完成，进入PS 2018启用工作区即可。<img src="http://47.94.231.166/wp-content/uploads/2018/07/Photoshop_2018-07-17_12-05-20.png" alt=""></p>
]]></content>
      <categories>
        <category>茶余杂谈</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>【Part.1】IntelliJ IDEA小教程：代码定位篇</title>
    <url>/2018/09/28/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5%EF%BC%9Aintellij-idea%E5%B0%8F%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>IntelliJ IDEA是JetBrains公司出品的Java IDE，其优秀的扩展性和联想功能可以大幅度提升开发者的效率，是开发JAVA应用的理想选择。下面将会介绍IntelliJ IDEA的常用功能，希望能与大家共同分享。 Form&gt;<a href="https://www.imooc.com/learn/924">慕课网笔记</a><br><a id="more"></a></p>
<h1 id="首先贴出下载地址：https-www-jetbrains-com-idea"><a href="#首先贴出下载地址：https-www-jetbrains-com-idea" class="headerlink" title="首先贴出下载地址：https://www.jetbrains.com/idea/"></a>首先贴出下载地址：<a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a></h1><p>推荐下载Ultimate版本，教程就是依据其写成的，如果下载Community版可能会缺失很多功能。虽然每年500刀的售价令人望而却步。但是也有以下妥协版本： ①<strong>使用学生账户</strong>，学生期间免费使用。推荐先申请GitHub的学生开发者工具包，学信网截个图往上一po就搞定，这样不仅可以白嫖JetBrains全家桶，还能嫖到免费的GitHub空间和其众多盟友的产品，为学习提供巨大的方便。<img src="http://47.94.231.166/wp-content/uploads/2018/04/34.png" alt="">地址：<a href="https://www.jetbrains.com/student/">https://www.jetbrains.com/student/</a> ②<strong>淘宝</strong>一个，五毛一年，26块终身，但是JetBrains全家桶都是按年卖的，终身应该指的是淘宝商家的存活时间，还是推荐按年买，毕竟存活52年的淘宝商家不多见，能干52年的程序员更不多见<img src="http://47.94.231.166/wp-content/uploads/2018/04/36.png" alt="">   安装完成后，IntelliJ的项目界面如下： <a href="http://upane.cn/?attachment_id=680"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_20-07-06-300x159.png" alt=""></a> 一般情况下，如果我们想查找某个功能，或者得到某个功能的快捷键，可以键入<strong>Ctrl+Shift+A</strong>打开功能查找窗口。界面如下 <a href="http://upane.cn/?attachment_id=683"><img src="http://47.94.231.166/wp-content/uploads/2018/09/2018-09-28_20-53-38-300x44.png" alt=""></a></p>
<h1 id="①标签页快捷操作"><a href="#①标签页快捷操作" class="headerlink" title="①标签页快捷操作"></a>①标签页快捷操作</h1><p>可以看出窗口左侧和下方的标签页都带有数字： <a href="http://upane.cn/?attachment_id=681"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_20-36-35-77x150.png" alt=""></a> 这代表按下<strong>Alt+数字</strong>即可打开相应的标签页 当焦点在标签页上时，按下<strong>Esc</strong>键即可退回编程窗口。</p>
<h1 id="②跳转"><a href="#②跳转" class="headerlink" title="②跳转"></a>②跳转</h1><h2 id="1-项目之间的跳转"><a href="#1-项目之间的跳转" class="headerlink" title="1.项目之间的跳转"></a>1.项目之间的跳转</h2><p>在打开多个项目后，我们可以使用快捷键<strong>Ctrl+Shift+]</strong>切换到下一个窗口，使用<strong>Ctrl+Shift+[</strong>切换到上一个窗口，对应功能在window选项卡下：可以查找到相对应的功能。 <a href="http://upane.cn/?attachment_id=682"><img src="http://47.94.231.166/wp-content/uploads/2018/09/2018-09-28_20-48-57.png" alt=""></a></p>
<h2 id="2-文件之间的跳转"><a href="#2-文件之间的跳转" class="headerlink" title="2.文件之间的跳转"></a>2.文件之间的跳转</h2><p>按下<strong>Alt+E</strong>即可弹出最近<strong>打开</strong>的文件窗口，在此窗口下可以<strong>直接输入键入文件名以搜索</strong>，以再次按下组合键即可切换选项，按下<strong>Enter</strong>进入文件，按下<strong>Esc</strong>退出窗口。 <a href="http://upane.cn/?attachment_id=684"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_20-46-29-300x159.png" alt=""></a> 按下<strong>Alt+Shift+E</strong>可以弹出最近<strong>修改</strong>的文件窗口，使用方法同最近打开的文件窗口。</p>
<h2 id="3-代码之间的跳转"><a href="#3-代码之间的跳转" class="headerlink" title="3.代码之间的跳转"></a>3.代码之间的跳转</h2><p>按下<strong>Ctrl+Shift+Backspace</strong>即可快速返回上一次<strong>修改</strong>的代码位置 按下<strong>Ctrl+Alt+←</strong>即可快速返回上一次<strong>光标停留</strong>（浏览）的位置，按下<strong>Ctrl+Alt+→</strong>即可进入下一次<strong>光标停留</strong>（浏览）的位置 其功能位于Navigate选项卡下： <a href="http://upane.cn/?attachment_id=685"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_21-03-50-300x111.png" alt=""></a></p>
<h2 id="4-代码标记"><a href="#4-代码标记" class="headerlink" title="4.代码标记"></a>4.代码标记</h2><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>按下<strong>F11</strong>即可在当前光标所在代码处插入书签，插入书签后，可在Favorites标签页（Alt+4）中的Bookmark中找到： <a href="http://upane.cn/?attachment_id=687"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_21-31-05-300x234.png" alt=""></a> 如果想快速定位，可以选择使用<strong>Ctrl+F11</strong>代替之前的F11，这样在标记书签的同时还可以<strong>自定义快捷键</strong>： <a href="http://upane.cn/?attachment_id=686"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_21-30-07-300x287.png" alt=""></a> 选定按键后，按下<strong>Ctrl+选定按键</strong>即可跳转到书签位置。</p>
<h3 id="偏好列表"><a href="#偏好列表" class="headerlink" title="偏好列表"></a>偏好列表</h3><p>按下<strong>Alt+Shift+F</strong>即可将当前行、函数（光标在函数名）、类（光标在类名）等等保存到偏好列表。 可以建立多个偏好列表，以此对标记代码进行分类。 <a href="http://upane.cn/?attachment_id=688"><img src="http://47.94.231.166/wp-content/uploads/2018/09/2018-09-28_21-40-49.png" alt=""></a></p>
<h3 id="插件：emacsIDEAs"><a href="#插件：emacsIDEAs" class="headerlink" title="插件：emacsIDEAs"></a>插件：emacsIDEAs</h3><p>安装教程见→<a href="http://upane.cn/archives/723">emacsIDEAs安装教程</a> 安装该插件后，对于该代码： <a href="http://upane.cn/?attachment_id=689"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_22-06-40-300x116.png" alt=""></a> 如果想要将光标跳转到Main类修饰符public的位置，按下定义好的快捷键，再按下p（因为public以p开头，其余同理Main类修饰符public的位置），即可出现以下界面·： <a href="http://upane.cn/?attachment_id=690"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_22-07-12-300x108.png" alt=""></a> 然后按下d，即可跳转到Main类修饰符public的位置。 <a href="http://upane.cn/?attachment_id=691"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_22-07-29-300x114.png" alt=""></a>  </p>
<h1 id="③精准搜索"><a href="#③精准搜索" class="headerlink" title="③精准搜索"></a>③精准搜索</h1><p>在Navigate选项卡下有很多我们常用的搜索工具，下面将逐一介绍： <a href="http://upane.cn/archives/679/2018-09-28_22-42-07"><img src="http://47.94.231.166/wp-content/uploads/2018/09/2018-09-28_22-42-07.png" alt=""></a></p>
<h2 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h2><p>按下<strong>Ctrl+N</strong>即可对项目内的类进行搜索，再次按下即可搜索包括jar包的所有类。</p>
<h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><p>按下<strong>Ctrl+Shift+N</strong>即可对项目内的文件进行搜索，再次按下即可搜索包括jar包的所有文件。</p>
<h2 id="搜索方法和属性（符号Symbol）"><a href="#搜索方法和属性（符号Symbol）" class="headerlink" title="搜索方法和属性（符号Symbol）"></a>搜索方法和属性（符号Symbol）</h2><p>按下<strong>Ctrl+Alt+Shift+N</strong>即可对项目内的方法和属性进行搜索，再次按下即可搜索包括jar包的所有方法和属性。</p>
<h2 id="搜索字符-字符串"><a href="#搜索字符-字符串" class="headerlink" title="搜索字符/字符串"></a>搜索字符/字符串</h2><p>这个很特殊，不再Navigate选项卡中，在Edit&gt;Find选项卡中，对应快捷键为<strong>Ctrl+F</strong>。 <a href="http://upane.cn/archives/679/idea64_2018-09-28_22-58-25"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_22-58-25-300x129.png" alt=""></a> 按下快捷键后，将弹出搜索框，如下图 <a href="http://upane.cn/archives/679/idea64_2018-09-28_23-05-39"><img src="http://47.94.231.166/wp-content/uploads/2018/09/idea64_2018-09-28_23-05-39-300x54.png" alt=""></a> 需要注意的是，<strong>搜索框只能搜索当前文档内的字符串</strong>。</p>
<blockquote>
<p>对应的三个可选框分别为： 完全匹配/匹配大小写（Match Case） 匹配单词（Words） 使用正则表达式进行搜索（Regex）</p>
</blockquote>
<p>若要在全局搜索字符串，可以键入<strong>Ctrl+Shift+F</strong>打开搜索窗口，如下图 <a href="http://upane.cn/archives/679/2018-09-28_23-11-10"><img src="http://47.94.231.166/wp-content/uploads/2018/09/2018-09-28_23-11-10-267x300.png" alt=""></a> 搜索窗口新增的可选框“File mask”可以对搜索的文件类型进行筛选。 搜索栏下方的四个按钮分别为在当前项目中搜索、在当前模块中搜索、在当前目录中搜索、在下拉框给出的自定范围中搜索。</p>
]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】二叉树的创建，遍历，求叶子数、深度。</title>
    <url>/2018/11/03/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E9%81%8D%E5%8E%86%EF%BC%8C%E6%B1%82%E5%8F%B6%E5%AD%90%E6%95%B0%E3%80%81%E6%B7%B1/</url>
    <content><![CDATA[<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================</span></span><br><span class="line"><span class="comment"> *            仅作参考，请勿照抄</span></span><br><span class="line"><span class="comment"> *==============================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建树节点</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立树函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);<span class="comment">//输入节点数据</span></span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)T = <span class="literal">NULL</span>;<span class="comment">//将#视为空标记</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));<span class="comment">//分配节点内存空间</span></span><br><span class="line">        T-&gt;data = ch;<span class="comment">//将数据输入节点</span></span><br><span class="line">        CreateBiTree(T-&gt;lchild);<span class="comment">//递归左节点</span></span><br><span class="line">        CreateBiTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PreOrderTraverse</span><span class="params">(BiTNode *T)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)<span class="comment">//若T不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);<span class="comment">//先访问节点数据</span></span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);<span class="comment">//再访问左节点</span></span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);<span class="comment">//最后访问右节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历：先访问左节点，再访问节点数据，最后访问右节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTNode *T)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历：先访问左节点，再右节点，最后访问节点数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTNode *T)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得叶子数量</span></span><br><span class="line"><span class="comment">//思路：1.找到叶子 2.计数</span></span><br><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLeavesCounts</span><span class="params">(BiTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Count = <span class="number">0</span>;<span class="comment">//建立（初始化）计数器</span></span><br><span class="line">    <span class="keyword">if</span> (!T)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//若T为空，直接终止函数，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;lchild&amp;&amp;!T-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        Count++;<span class="comment">//当某节点为叶子（左右节点皆无），则计数器加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Count += GetLeavesCounts(T-&gt;lchild);<span class="comment">//否则，当节点有左或右孩子，则向下递归，直到找到叶子。</span></span><br><span class="line">        Count += GetLeavesCounts(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Count;<span class="comment">//在计数器清空前返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="comment">/*int GetLeavesCounts(BiTNode *T)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if(!T)return 0;//若节点为空，直接返回</span></span><br><span class="line"><span class="comment">    int LeftCount=GetLeavesCounts(T-&gt;lchild);</span></span><br><span class="line"><span class="comment">    int RightCount=GetLeavesCounts(T-&gt;rchild);//分别遍历左右孩子</span></span><br><span class="line"><span class="comment">    return (LeftCount==0&amp;&amp;RightCount==0)?1:LeftCount+RightCount;</span></span><br><span class="line"><span class="comment">    //若该节点左右孩子都是空（即该节点是一个叶子），返回1（代表这个方向有一个叶子），</span></span><br><span class="line"><span class="comment">    //否则该节点不是叶子，就把它左右孩子的叶子数相加。</span></span><br><span class="line"><span class="comment">&#125;*/</span><span class="comment">//获得树深度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBiTreeDepth</span><span class="params">(BiTNode *T)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//若节点为空，直接终止函数，返回深度0</span></span><br><span class="line">    <span class="keyword">int</span> LeftDepth = GetBiTreeDepth(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">int</span> RightDepth = GetBiTreeDepth(T-&gt;rchild);<span class="comment">//遇到左右节点，进行递归，获得其下最大深度</span></span><br><span class="line">    <span class="keyword">return</span> (LeftDepth &gt; RightDepth) ? (LeftDepth + <span class="number">1</span>) : (RightDepth + <span class="number">1</span>);</span><br><span class="line">         <span class="comment">//判断左右节点谁“深”，判断更深的路径加一（当前深度）后返回</span></span><br><span class="line">    <span class="comment">//递归到最后遇到叶子的情况(0&gt;0)?(0+1):(0+1)，不用管谁+1，反正结果是1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree TreePointer;<span class="comment">//声明树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please Type the NODE of tree (type in ONE line):\n&quot;</span>);</span><br><span class="line">    CreateBiTree(TreePointer);<span class="comment">//建立树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPre-Order Traverse Result:\n&quot;</span>);</span><br><span class="line">    PreOrderTraverse(TreePointer);<span class="comment">//前序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nIn-Order Traverse Result:\n&quot;</span>);</span><br><span class="line">    InOrderTraverse(TreePointer);<span class="comment">//中序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPost-Order Traverse Result:\n&quot;</span>);</span><br><span class="line">    PostOrderTraverse(TreePointer);<span class="comment">//后序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nTree Leaves Number:%d&quot;</span>, GetLeavesCounts(TreePointer));<span class="comment">//输出叶子数量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nTree Depth:%d\n&quot;</span>, GetBiTreeDepth(TreePointer));<span class="comment">//输出深度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
  </entry>
  <entry>
    <title>【数据结构】图的创建与遍历</title>
    <url>/2018/11/27/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>仅供参考，请勿抄袭<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20  <span class="comment">//最大顶点个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*         ALGraph：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * AdjList[]</span></span><br><span class="line"><span class="comment"> *    ↓         ArcNode</span></span><br><span class="line"><span class="comment"> * ╔════╗         ↓</span></span><br><span class="line"><span class="comment"> * ║  A ║→▢→▢→▢→▢</span></span><br><span class="line"><span class="comment"> * ╠════╣</span></span><br><span class="line"><span class="comment"> * ║  B ║→▢→▢→▢</span></span><br><span class="line"><span class="comment"> * ╠════╣</span></span><br><span class="line"><span class="comment"> * ║ ...║</span></span><br><span class="line"><span class="comment"> * ╠════╣</span></span><br><span class="line"><span class="comment"> * ║  C ║→▢→▢→▢→▢→▢→▢</span></span><br><span class="line"><span class="comment"> * ╚════╝</span></span><br><span class="line"><span class="comment"> *   ↑</span></span><br><span class="line"><span class="comment"> *  VNode：AdjList[]的一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *info;</span><br><span class="line">&#125;ArcNode;<span class="comment">//邻接表的一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    ArcNode *firstarc=<span class="literal">nullptr</span>;<span class="comment">//nullptr意为空指针，注意这里一定要设初值，否则默认初始化为0xcccccccccc，这个值不是空值，不等于NULL，遍历时就无法停止。</span></span><br><span class="line">&#125;VNode,AdjList[MAX_VERTEX_NUM];<span class="comment">//邻接表数组的一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList vertices;<span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">int</span> vexnum=<span class="number">0</span>, arcnum=<span class="number">0</span>;<span class="comment">//节点数和边数</span></span><br><span class="line">    <span class="keyword">int</span> kind;<span class="comment">//图的种类（好像暂时用不着）</span></span><br><span class="line">&#125;ALGraph;<span class="comment">//用邻接表表示图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//====================下面是定义队列的代码，会的可以不看========================</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;<span class="comment">//邻接表节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;<span class="comment">//邻接表表头</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)<span class="keyword">return</span>;</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="comment">//建立队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">&#125;<span class="comment">//入队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)<span class="keyword">return</span>;</span><br><span class="line">    QueuePtr p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;<span class="comment">//出队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.front-&gt;next == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;<span class="comment">//检测队列是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===========================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//temp1与temp2为邻接表节点（边）的两端节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildNode</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> temp1,<span class="keyword">int</span> temp2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *node = (ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));<span class="comment">//申请一个ArcNode大小的连续内存</span></span><br><span class="line">    node-&gt;adjvex = temp2;<span class="comment">//把temp2的值赋给该节点的内容中</span></span><br><span class="line">    node-&gt;nextarc = G.vertices[temp1].firstarc;<span class="comment">//将该节点插入要替换的节点前</span></span><br><span class="line">    G.vertices[temp1].firstarc = node;<span class="comment">//将该节点挂载到数组上</span></span><br><span class="line">    G.arcnum++;<span class="comment">//边数加一</span></span><br><span class="line">&#125;<span class="comment">//建立邻接表节点ArcNode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//建立图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//下面建立数组：</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入节点信息：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_VERTEX_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> temp=getchar();<span class="comment">//不断地获得用户输入的值，每次一个字符，进入以下方法检验</span></span><br><span class="line">        <span class="keyword">if</span> (temp==<span class="string">&#x27;n&#x27;</span>)<span class="keyword">break</span>;<span class="comment">//如果用户按下回车，立刻停止输入</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="string">&#x27; &#x27;</span>)<span class="comment">//如果这个值不是空格，将该值输入数组中，且标记增加一个节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                G.vertices[G.vexnum].data = temp;</span><br><span class="line">                G.vexnum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面建立邻接表各个节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入边数据：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp1, temp2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;temp1, &amp;temp2);<span class="comment">//不断地获得两个值（scanf可以忽略空格）</span></span><br><span class="line">        BuildNode(G, temp1, temp2);<span class="comment">//用这两个值建立节点</span></span><br><span class="line">        <span class="keyword">if</span>(temp1!=temp2)BuildNode(G, temp2, temp1);<span class="comment">//如果这两个值不相等，则建立反向的节点（无向图）</span></span><br><span class="line">        <span class="keyword">if</span> (getchar() == <span class="string">&#x27;\n&#x27;</span>)<span class="keyword">break</span>;<span class="comment">//如果用户键入的是Enter，立刻停止输入</span></span><br><span class="line">    &#125;<span class="comment">//存储边数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是遍历体，详见课本</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//用于记录节点是否被访问的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历递归体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(ALGraph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c,&quot;</span>, G.vertices[v].data);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    p = G.vertices[v].firstarc;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[p-&gt;adjvex])DFS(G, p-&gt;adjvex);</span><br><span class="line">        p = p-&gt;nextarc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历递归体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(ALGraph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c,&quot;</span>, G.vertices[v].data);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    EnQueue(Q, v);</span><br><span class="line">    <span class="keyword">while</span> (!QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u;</span><br><span class="line">        DeQueue(Q, u);</span><br><span class="line">        ArcNode *p = G.vertices[u].firstarc;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[p-&gt;adjvex])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c,&quot;</span>, G.vertices[p-&gt;adjvex].data);</span><br><span class="line">                visited[p-&gt;adjvex] = <span class="literal">true</span>;</span><br><span class="line">                EnQueue(Q, p-&gt;adjvex);</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++)visited[v] = <span class="literal">false</span>;<span class="comment">//初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])DFS(G, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++)visited[v] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++)</span><br><span class="line">        <span class="keyword">if</span> (!visited[v])BFS(G, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画邻接矩阵</span></span><br><span class="line"><span class="comment">//邻接矩阵的横向边与纵向边都是节点数，其中交叉位置即这两个节点间的权值，</span></span><br><span class="line"><span class="comment">//在无权图中，用1表示这两点相邻接，用0表示这两点不邻接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawGraph</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//纵向边输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)<span class="comment">//横向边输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!G.vertices[i].firstarc)<span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);<span class="comment">//某个节点的数组没有邻接节点，那么它就不与任何节点都邻接，也就是整行为0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ArcNode *p=G.vertices[i].firstarc;<span class="comment">//得到数组后的一个节点地址，依次检测有没有与这个数组代表的节点邻接的节点</span></span><br><span class="line">                <span class="keyword">bool</span> setone = <span class="literal">false</span>;<span class="comment">//设置一个变量，保存这个节点与数组节点是否邻接</span></span><br><span class="line">                <span class="keyword">while</span>(p)<span class="comment">//由于邻接表没有索引，只能通过遍历得到j代表的节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;adjvex == j)<span class="comment">//找到了j代表的节点，就说明这两个节点邻接，输出1</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">                        setone = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = p-&gt;nextarc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!setone)<span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);<span class="comment">//没找到j代表的节点，说明这两个节点（i和j）不邻接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//一行输出完毕，换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGraph G;</span><br><span class="line">    CreateGraph(G);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;深度优先遍历：&quot;</span>);</span><br><span class="line">    DFSTraverse(G);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n广度优先遍历：&quot;</span>);</span><br><span class="line">    BFSTraverse(G);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n图的邻接矩阵为：\n&quot;</span>);</span><br><span class="line">    DrawGraph(G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>课堂作业</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】快速排序</title>
    <url>/2018/12/20/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>这个实验其实在课本上写得蛮详细的，稍微看看就能理解。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> r[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;<span class="comment">//定义排序列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换任意a和b的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定枢轴，并且进行以枢轴为界对列表进行分割</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.r[<span class="number">0</span>] = L.r[low];<span class="comment">//为监视哨赋值</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high&amp;&amp;L.r[high] &gt;= L.r[<span class="number">0</span>])high--;</span><br><span class="line">        Exchange(L.r[low], L.r[high]);</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high&amp;&amp;L.r[low] &lt;= L.r[<span class="number">0</span>])low++;</span><br><span class="line">        Exchange(L.r[low], L.r[high]);</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[high] = L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;<span class="comment">//返回分割点（枢轴）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归缩小列表的分割长度，直至排序完毕</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotloc = Partition(L, low, high);</span><br><span class="line">        QSort(L, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">        QSort(L, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对整个列表执行快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSort(L, <span class="number">1</span>, L.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要排序的数组长度：（1~20）\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L.length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请依次输入要排序的数组元素：（用逗号隔开）\n&quot;</span>);</span><br><span class="line">    <span class="comment">//数组的第一个元素为监视哨，应无实际值，所以这里要从1开始赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; L.length + <span class="number">1</span>; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d,&quot;</span>, &amp;L.r[i]);</span><br><span class="line">    QuickSort(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序结果：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; L.length + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, L.r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>课堂作业</tag>
      </tags>
  </entry>
  <entry>
    <title>【瞎搞】舍长神器（雾）</title>
    <url>/2018/09/20/%E3%80%90%E7%9E%8E%E6%90%9E%E3%80%91%E8%88%8D%E9%95%BF%E7%A5%9E%E5%99%A8%EF%BC%88%E9%9B%BE%EF%BC%89/</url>
    <content><![CDATA[<p>为了贯彻落实社会主义核心价值观，秉承公平民主的思想，今日特制舍长神器用于——抽签！ <img src="http://47.94.231.166/wp-content/uploads/2018/09/舍长神器_2018-09-20_12-48-41.png" alt=""><br><a id="more"></a><br>  哈哈哈哈哈哈哈哈哈 Emmmmmm…… 特性？ 1.绝对随机， 使用加密服务提供程序 (CSP) 提供的随机数进行抽取，这可不是一般的seed，综合时间、线程、各种硬件数据所做到的近乎完美的随机数，不要和Random()那种东西相提并论<img src="http://47.94.231.166/wp-content/uploads/2018/04/34.png" alt=""> 2.特别添加仪式感模式，倒数五秒给出结果<img src="http://47.94.231.166/wp-content/uploads/2018/04/78.png" alt=""> 3.可以一次性抽取多个非洲人<img src="http://47.94.231.166/wp-content/uploads/2018/04/35.png" alt=""> 哈哈哈哈哈嗝 其实只是练习随机数而已   下载：<a href="http://47.94.231.166/wp-content/uploads/2018/09/舍长神器.zip">舍长神器</a> 源码·：<a href="http://47.94.231.166/wp-content/uploads/2018/09/脸黑测试器.zip">脸黑测试器</a> （脸黑测试器是之前的名字）</p>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title>【读书笔记】代码不朽——编写可维护软件的十大要则</title>
    <url>/2019/03/09/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E4%BB%A3%E7%A0%81%E4%B8%8D%E6%9C%BD-%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8D%81%E5%A4%A7/</url>
    <content><![CDATA[<blockquote>
<p>瞎写一时爽，维护火葬场</p>
</blockquote>
<p>天天写尸堆，自己都看不下去了！什么时候开始自己的代码变得那么丑陋了呢？经过一番回想，我发现凡是没有约束的代码，变得丑陋只是时间问题。 综上所述，我拜读了Joost Visser的Building Maintainable Software这本书（中文译名为“代码不朽”），受益匪浅，在此做一下笔记以防遗忘。<br><a id="more"></a></p>
<h1 id="代码不朽"><a href="#代码不朽" class="headerlink" title="代码不朽"></a>代码不朽</h1><h2 id="——编写可维护软件的十大要则"><a href="#——编写可维护软件的十大要则" class="headerlink" title="——编写可维护软件的十大要则"></a>——编写可维护软件的十大要则</h2><hr>
<h3 id="①编写较小的代码单元"><a href="#①编写较小的代码单元" class="headerlink" title="①编写较小的代码单元"></a>①编写较小的代码单元</h3><h4 id="原则："><a href="#原则：" class="headerlink" title="原则："></a>原则：</h4><ul>
<li><strong>代码单元的长度应该限制在15行代码以内。</strong></li>
<li>为此首先<strong>不要编写超过15行代码的单元，或者将长的单元分解成多个更短的单元</strong>，直到每个单元都不超过15行代码。</li>
<li>该原则能提高可维护性的原因在于，<strong>短小的代码但愿易于理解，测试及重用。</strong></li>
</ul>
<h4 id="如何应用本原则？"><a href="#如何应用本原则？" class="headerlink" title="如何应用本原则？"></a>如何应用本原则？</h4><p><strong>——使用重构技巧来应用原则</strong></p>
<h5 id="㈠重构技巧：提取方法"><a href="#㈠重构技巧：提取方法" class="headerlink" title="㈠重构技巧：提取方法"></a>㈠重构技巧：提取方法</h5><p>将内容代码较多的单元提取为几个代码较少的单元，此时代码总量将增加，但是我们总要在代码总量与后期可维护性之间做出权衡，不止这里，后面讲的方法也或多或少地增加了代码总量，但却能大大提高后期可维护性。 <strong>Example——吃豆人游戏中的一段代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inProgress)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inProgress=<span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//如果玩家死亡则更新观察者</span></span><br><span class="line">    <span class="keyword">if</span>(!isAnyPlayerAlive())&#123;</span><br><span class="line">        <span class="keyword">for</span>(LevelOvserver o:observers)&#123;</span><br><span class="line">            o.levelLost();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果所有的豆都被吃光则更新观察者</span></span><br><span class="line">    <span class="keyword">if</span>(remainingPellets()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(LevelObserver o:observers)&#123;</span><br><span class="line">            o.levelWon();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原来有1行代码，现在我们提取方法，可将其分解成三个小方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inProgress)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inProgress=<span class="keyword">true</span>;</span><br><span class="line">    updateObservers();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    updateObserversPlayerDied();</span><br><span class="line">    updateObserversPelletsEaten();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateOberversPlayerDied</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isAnyPlayerAlive())&#123;</span><br><span class="line">        <span class="keyword">for</span>(LevelObserver o:observers)&#123;</span><br><span class="line">            o.levelLost();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateObserversPelletsEaten</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(remainingPellets()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(LevelObserver o:observers)&#123;</span><br><span class="line">            o.levelWon();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="㈡重构技巧：将方法替换为方法对象"><a href="#㈡重构技巧：将方法替换为方法对象" class="headerlink" title="㈡重构技巧：将方法替换为方法对象"></a>㈡重构技巧：将方法替换为方法对象</h5><p>在传入参数较少时使用提取方法较为方便，上面的例子就提取出了三个无参数的函数。但是若是要提取的方法调用了较多临时变量，提取方法时就要传入大量参数，造成代码冗余，对于这种情况可以尝试<strong>将方法替换为方法对象</strong> <strong>Example：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Board <span class="title">CreatBoard</span><span class="params">(Square[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> grid!=<span class="keyword">null</span>;</span><br><span class="line">    Board board=<span class="keyword">new</span> Board(grid);</span><br><span class="line">    <span class="keyword">int</span> width=board.getWidth();</span><br><span class="line">    <span class="keyword">int</span> height=board.getHeight();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;width;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;height;y++)&#123;</span><br><span class="line">            Square square=grid[x][y];</span><br><span class="line">            <span class="keyword">for</span>(Direction dir:Direction.velues())&#123;</span><br><span class="line">                <span class="keyword">int</span> dirX=(width+x+dir.getDeltaX())%width;</span><br><span class="line">                <span class="keyword">int</span> dirY=(height+y+dir.getDeltaY())%height;</span><br><span class="line">                Square neighbour=grid[dirX][dirY];</span><br><span class="line">                square.link(neighbour,dir);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>若要提取上面循环中的方法，则需要传递七个参数，分别是<code>width</code>,<code>height</code>,<code>x</code>,<code>y</code>,<code>dir</code>,<code>square</code>,<code>grid</code>。拥有很长参数的方法显得丑陋无比，下面使用方法对象来将其替换之：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoardCreator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Square[][] grid;</span><br><span class="line">    <span class="keyword">private</span> Board borad;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    BoardCreator(Square[][] grid)&#123;</span><br><span class="line">        <span class="keyword">assert</span> grid!=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.grid=grid;</span><br><span class="line">        <span class="keyword">this</span>.board=<span class="keyword">new</span> Board(grid);</span><br><span class="line">        <span class="keyword">this</span>.width=board.getWidth();</span><br><span class="line">        <span class="keyword">this</span>.height=board.getHeight();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Board <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;width;x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;height;y++)&#123;</span><br><span class="line">                Square square =grid[x][y];</span><br><span class="line">                <span class="keyword">for</span>(Direction dir:Direction.values())&#123;</span><br><span class="line">                    setLink(Square,dir,x,y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.board;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLink</span><span class="params">(Square square,Direction dir,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dirX=(width+x+dir.getDeltaX())%width;</span><br><span class="line">        <span class="keyword">int</span> dirY=(height+y+dir.getDeltaY())%height;</span><br><span class="line">        Square neighbour=grid[dirX][dirY];</span><br><span class="line">        square.link(neighbour,dir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，有了以上方法类，<code>createBoard</code>方法即可重构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Board <span class="title">createBoard</span><span class="params">(Square[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BoardCreator(grid).create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="本章警告："><a href="#本章警告：" class="headerlink" title="本章警告："></a>本章警告：</h4><blockquote>
<p>⑴不要牺牲可维护性来优化性能，除非有可靠的性能测试能够证明确实存在性能问题，并且你的性能优化措施也真的有效果。 ⑵为你的继任者（也为将来的自己）编写易于阅读和理解的代码。 ⑶当似乎可以重构但是并没有什么意义时，请重新思考系统的架构。 ⑷精挑细选可以描述功能的方法名，并将代码放在短小的代码单元中（最多15行代码）。</p>
</blockquote>
<h3 id="②编写简单的代码单元"><a href="#②编写简单的代码单元" class="headerlink" title="②编写简单的代码单元"></a>②编写简单的代码单元</h3><h4 id="原则：-1"><a href="#原则：-1" class="headerlink" title="原则："></a>原则：</h4><ul>
<li><strong>限制每个代码单元分支点的数量不超过4个。</strong></li>
<li>你应该<strong>将复杂的代码单元拆分成多个简单的单元</strong>，避免多个复杂的单元在一起。</li>
<li>该原则能提高可维护性的原因在于，分支点越少，<strong>代码单元越容易被修改和测试。</strong></li>
</ul>
<h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><ul>
<li><strong>代码单元分支点： 能够覆盖分支点所有分支的路径数量。</strong> 在Java中，这些语句均被认为是分支点：<ol>
<li>if</li>
<li>case</li>
<li>?</li>
<li>&amp;&amp;,</li>
<li>while</li>
<li>for</li>
<li>catch</li>
</ol>
</li>
<li><strong>McCabe复杂度：分支点数量加一</strong> ，又称圈复杂度或循环复杂度。因此这个原则相当于“限制McCabe复杂度不超过5”。</li>
</ul>
<h4 id="如何使用本原则？"><a href="#如何使用本原则？" class="headerlink" title="如何使用本原则？"></a>如何使用本原则？</h4><h5 id="Ⅰ-处理链式条件语句"><a href="#Ⅰ-处理链式条件语句" class="headerlink" title="Ⅰ.处理链式条件语句"></a>Ⅰ.处理链式条件语句</h5><p>以以下代码为例。对于一个国家来说，<code>getFlagColors</code>方法会返回正确的国旗颜色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Color&gt; <span class="title">getFlagColors</span><span class="params">(Nationality notionality)</span></span>&#123;</span><br><span class="line">    List&lt;Color&gt; result;</span><br><span class="line">    <span class="keyword">switch</span>(nationality)&#123;</span><br><span class="line">        <span class="keyword">case</span> DUTCH:</span><br><span class="line">            result=Arrays.asList(Color.RED,Color.WHITE,Color.BLUE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GERMAN:</span><br><span class="line">            result=Arrays.asList(Color.BLACK,Color.RED,Color.YELLOW);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BELGIAN:</span><br><span class="line">            result=Arrays.asList(Color.BLACK,Color.YELLOW,Color.RED);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FRENCH:</span><br><span class="line">            result=Arrays.asList(Color.BLUE,Color.WHITE,Color.RED);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ITALIAN:</span><br><span class="line">            result=Arrays.asList(Color.GREEN,Color.WHITE,Color.RED);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UNCLASSIFIED;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result=Arrays.asList(Color.GRAY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，该方法的复杂度达到了6+1=7，我们需要对其进行优化。 <strong>方法一：引入一个Map数据结构：</strong> 这种方法的核心观念是：<strong>创建一个字典，以便使用一值直接映射到另一个值，从而将判断语句省略。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Nationality,List&lt;Color&gt;&gt; FLAGS=<span class="keyword">new</span> HashMap&lt;Nationality,List&lt;Color&gt;&gt;();</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    Flags.put(DUTCH,Arrays.asList(Color.RED,Color.WHITE,Color.BLUE));</span><br><span class="line">    Flags.put(GERMAN,Arrays.asList(Color.BLACK,Color.RED,Color.YELLOW));</span><br><span class="line">    Flags.put(BELGIAN,Arrays.asList(Color.BLACK,Color.YELLOW,Color.RED));</span><br><span class="line">    Flags.put(FRENCH,Arrays.asList(Color.BLUE,Color.WHITE,Color.RED));</span><br><span class="line">    Flags.put(ITALIAN,Arrays.asList(Color.GREEN,Color.WHITE,Color.RED));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Color&gt; <span class="title">getFlagColors</span><span class="params">(Nationality nationality)</span></span>&#123;</span><br><span class="line">    List&lt;Color&gt; color=FLAGS.get(nationality);</span><br><span class="line">    <span class="keyword">return</span> colors!=<span class="keyword">null</span>?colors:Arrays.asList(Color.GRAY);<span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：使用多态来代替条件判断</strong> 这种方法的核心观念是：<strong>让每个国旗都拥有一个自己的类型，并实现同一个接口。Java语言的多态性会保证在运行时调用到正确的类型。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了进行这次重构，我们首先定义一个共用的Flag接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flag</span></span>&#123;</span><br><span class="line">    <span class="function">List&lt;Color&gt; <span class="title">getColors</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为不同的国家定义不同的国旗类型，例如荷兰国旗：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DutchFlag</span> <span class="keyword">implements</span> <span class="title">Flag</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Color&gt; <span class="title">getColors</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(Color.RED,Color.WHITE,Color.BLUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以及意大利国旗：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItalianFlag</span> <span class="keyword">implements</span> <span class="title">Flag</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;color&gt; <span class="title">getColors</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(Color.GREEN,Color.WHITE,Color.RED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中间的国旗类定义不予赘述</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="title">Map</span><span class="params">(Nationality nationality)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    Flags.put(DUTCH,<span class="keyword">new</span> DutchFlag());</span><br><span class="line">    Flags.put(GERMAN,<span class="keyword">new</span> GermanFlag());</span><br><span class="line">    Flags.put(BELGIAN,<span class="keyword">new</span> BelgianFlag());</span><br><span class="line">    Flags.put(FRENCH,<span class="keyword">new</span> FrenchFlag());</span><br><span class="line">    Flags.put(ITALIAN,<span class="keyword">new</span> ItalianFlag());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Color&gt; <span class="title">getFlagColors</span><span class="params">(Nationality nationality)</span></span>&#123;</span><br><span class="line">    Flag flag=FLAGS.get(nationality);</span><br><span class="line">    flag=flag!=<span class="keyword">null</span>?flag:<span class="keyword">new</span> DefaultFlag();</span><br><span class="line">    <span class="keyword">return</span> flag.getColors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种重构技巧提供了最灵活的实现方式，例如，你只需要实现新的国旗类型，就可以不断增加所支持的国旗种类，并且可以对它进行独立测试。不过这种方式的不好之处是引入了更多的类和代码。开发人员必须在可扩展性和简洁性之间做出选择。</p>
<h5 id="Ⅱ-嵌套条件语句"><a href="#Ⅱ-嵌套条件语句" class="headerlink" title="Ⅱ.嵌套条件语句"></a>Ⅱ.嵌套条件语句</h5><p>如下例所示，我们给定一个二分查找树的根节点和一个整数，<code>calculateDepth</code>方法会找出整数在树中的位置。如果找到，该方法会返回整数在树中的深度，否则抛出一个TreeException异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateDepth</span><span class="params">(BinaryTreeNode&lt;Integer&gt;t,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t.getValue()==n)&#123;</span><br><span class="line">        retrun depth;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;t.getValue())&#123;</span><br><span class="line">            BinaryTreeNode&lt;Inter&gt; left=t.getLeft();</span><br><span class="line">            <span class="keyword">if</span>(left=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TreeException(<span class="string">&quot;Value not found in tree!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+calculateDepth(Left,n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            BinaryTreeNode&lt;Inter&gt; right=t.getRight();</span><br><span class="line">            <span class="keyword">if</span>(right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TreeException(<span class="string">&quot;Value not found in tree!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+calculateDepth(right,n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了<strong>提高可读性</strong>，我们可以标识出各种独立的情况，并插入<code>return</code>语句来代替嵌套式的条件语句，这种做法在重构中被称为<strong>使用卫语句来代替嵌套的条件语句</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateDepth</span><span class="params">(BinaryTreeNode&lt;Integer&gt; t,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t.getValue()==n)<span class="keyword">return</span> depth;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;getValue()&amp;&amp;t.getLeft()!=<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">1</span>+calculateDepth(t.getLeft(),n);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;getValue()&amp;&amp;t.getRight()!=<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">1</span>+calculateDepth(t.getRight(),n);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TreeException(<span class="string">&quot;Value not found in tree!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，代码就变得更容易理解了，<strong>但是其复杂度并没有降低</strong>，为了降低复杂度，应该<strong>将嵌套的条件语句提取到其他方法中</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateDepth</span><span class="params">(BinaryTreeNode&lt;Integer&gt; t <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t.getValue()==n)<span class="keyword">return</span> depth;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> traverseByValue(t,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">traverseByValue</span><span class="params">(BinaryTreeNode&lt;Integer&gt; t,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    BinaryTreeNode&lt;Integer&gt; childNode=getChildNode(t,n);</span><br><span class="line">    <span class="keyword">if</span>(childNode==Null)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TreeException(<span class="string">&quot;Value not found in tree!&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+calculateDepth(childNode,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BinaryTreeNode&lt;Integer&gt; <span class="title">getChildNode</span><span class="params">(BinaryTreeNode&lt;Integer&gt; t,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;t.getValue())<span class="keyword">return</span> t.getLeft();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> t.getRight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;====To be continue====&gt;</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>后院</category>
        <category>笔记&amp;amp;书评</category>
        <category>茶余杂谈</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【通知】文章重构提醒</title>
    <url>/2018/11/10/%E3%80%90%E9%80%9A%E7%9F%A5%E3%80%91%E6%96%87%E7%AB%A0%E9%87%8D%E6%9E%84%E6%8F%90%E9%86%92/</url>
    <content><![CDATA[<p>今天对网站的文章进行了重构，取消使用过时的代码标签标记，今后所有文章改用<strong>MarkDown</strong>书写，所以旧文章的代码页面会失去格式。并非不想全部重写，而是使用新的代码可能会对旧文章的标签产生新释义从而导致文章不可读。为保证旧文章的可读性，如发现下面的代码： <code>[cc=&quot;csharp&quot;] ...... [/cc]</code> 则代表该段代码为C#语言，同理，如代码形式为 <code>[cc=&quot;python&quot;] ...... [/cc]</code> 则代表该段代码为Python语言。 为了今后的功能扩展，不得不放弃一些东西，望谅解。</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title>【别慌！】</title>
    <url>/2019/06/24/%E5%88%AB%E6%85%8C%EF%BC%81/</url>
    <content><![CDATA[<blockquote>
<p>写个算法冷静一下<br><a id="more"></a><br>最近过得太安逸，头发又茂盛了，刷点题遏制一下（？ 总之 开通了力扣专栏，写了题就塞进小站，顺便分析一下。 美区账户（id=yimig），顺便练英语了。 做题顺序么，目前先从简单开始，练上十来个就按算法专题顺序，然后挑战高级点的…大概 欢迎大家一起来讨论！</p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode！</category>
      </categories>
  </entry>
  <entry>
    <title>#应用推荐#  美化桌面的应用</title>
    <url>/2018/04/14/%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90-%E7%BE%8E%E5%8C%96%E6%A1%8C%E9%9D%A2%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>在电脑上我们看到的频率最多的地方当属桌面了，一个好的桌面不仅要美观，还要兼顾整洁与效率，下面介绍几款小应用帮助大家整理出最个性的桌面<br><a id="more"></a></p>
<h1 id="1-Fence"><a href="#1-Fence" class="headerlink" title="1.Fence"></a>1.Fence<a href="http://upane.cn/archives/187/2018-04-14_21-27-18"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-14_21-27-18-300x169.jpg" alt=""></a><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-14_21-28-08-300x169.jpg" alt=""></h1></blockquote>
<p>这款由Stardock工作室开发的桌面图标分类工具当属最实用的整理工具了，它不仅可以帮助整理和分类图标，还能在桌面上创建文件夹的镜像，让你不需要打开文件管理器就可以轻轻松松地在桌面上查看文件，与自带的多桌面功能一起使用大大增加了工作效率。另外这些“Fence”也可以在不用的时候自动卷起，还你一个清爽的桌面。    </p>
<h1 id="2-Wallpaper-Engine"><a href="#2-Wallpaper-Engine" class="headerlink" title="2.Wallpaper Engine"></a>2.Wallpaper Engine</h1><pre><code>  ![](http://47.94.231.166/wp-content/uploads/2018/04/ui32_2018-04-14_21-47-39-300x223.png)![](http://47.94.231.166/wp-content/uploads/2018/04/ui32_2018-04-14_21-47-48-300x223.png) 在动态桌面领域恐怕没有谁能撼动Wallpaper Engine的地位了，作为一个老牌工具，Wallpaper Engine支持视频动态桌面，HTML网页动态桌面，静态桌面，基本满足了各种对桌面的美化方式，不过某些互动型桌面比较吃CPU，虽然在桌面被其他应用覆盖后就不在运行， 还是希望电脑配置不高的朋友酌情使用。       
</code></pre><h1 id="3-SAO-Utils"><a href="#3-SAO-Utils" class="headerlink" title="3.SAO Utils"></a>3.SAO Utils</h1><p>虽然是由国内某位技术宅制作的动漫宅物，但是作为美化桌面与增加效率却也有不俗的表现。这个想法原本是由动漫《Sword Art Online》中主人公使用VR进入虚拟世界调出控制面板的动作启发的，用在电脑上也十分有效率，比如现在要打开什么应用或者执行什么命令，只需要按住鼠标左右键一起向下划就可以调出启动面板，进而启动对应程序，无需返回桌面一个一个找了，另外值得一提的是作者正在扩展这款应用的功能，<a href="http://upane.cn/archives/187/sao-utils_2018-04-14_21-54-06"><img src="http://47.94.231.166/wp-content/uploads/2018/04/SAO-Utils_2018-04-14_21-54-06-300x169.jpg" alt=""></a>目前已经支持了很多小插件，而且这款软件是完全免费的。 （初次启动时请关闭声音，因为启动后会有男主角连线时的怒吼，启动后可以从设置界面关掉） 下载/作者网站：<a href="http://www.gpbeta.com/post/develop/sao-utils/">热风CG工作室</a></p>
]]></content>
      <categories>
        <category>应用推荐</category>
      </categories>
      <tags>
        <tag>应用推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>#批处理#  PC平板触控开关</title>
    <url>/2018/03/12/%E6%89%B9%E5%A4%84%E7%90%86-pc%E5%B9%B3%E6%9D%BF%E8%A7%A6%E6%8E%A7%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<blockquote>
<p>不知道各位有没有感觉同时打开触摸屏与触控笔会干扰触控笔操作（我的电脑是N-Trig笔，理论上Wacom也可用）所以做了一个可以控制触控屏的开关脚本，这样绘制之前一按后面的笔帽就可以关闭触控屏仅使用触控笔，需要触控屏时再按一下后面的笔帽又可以打开。<br><a id="more"></a><br>说一下原理吧， 利用devcon命令禁用/启用（disable/enable）触控屏，但是这里如果需要实时显示屏幕开启状态（通过改自己的文件名）自动提权的代码就无法被执行，因为名称改变了。所以另设置一个脚本专门显示状态，双击后再引向真正起作用的（也就是调用devcon命令）的脚本。但是这里又有一个问题，就是if exist语句不能加else（也许可以，但是我试过后怎么也不行），所以无法直接调用别的文件名。所以利用devcon显示状态的命令（statue）代替，这样就麻烦了，又是裁剪又是临时文件的，但是马马虎虎做出来了，试了下，能用。 然后把显示状态的脚本挂在桌面上，把控制脚本藏起来，创建一个快捷方式（因为windows里设置触控笔按键要么打开可执行应用要么打开快捷方式，但是脚本不是可执行文件，只好又绕远路创建快捷方式），然后在触控笔设置里把按键按一下定位到那个快捷方式就可以了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">net session &gt;nul 2&gt;&amp;1</span><br><span class="line">if not &quot;%errorLevel%&quot; &#x3D;&#x3D; &quot;0&quot; (</span><br><span class="line">echo Set UAC &#x3D; CreateObject^(&quot;Shell.Application&quot;^) &gt; &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">echo UAC.ShellExecute &quot;%~s0&quot;, &quot;%*&quot;, &quot;&quot;, &quot;runas&quot;, 1 &gt;&gt; &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">&quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">exit &#x2F;b 2</span><br><span class="line">)</span><br><span class="line">cd C:\Users\z8442\</span><br><span class="line">devcon status &quot;HID_DEVICE_UP:000D_U:0004*&quot;&gt;C:\data.txt</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">for &#x2F;f &quot;delims&#x3D;&quot; %%a in (C:\data.txt) do set &#x2F;a m+&#x3D;1&amp;set &quot;_!m!&#x3D;%%a&quot;</span><br><span class="line">set &#x2F;a m&#x3D;2</span><br><span class="line">set data&#x3D;!_%m%:~24,25!</span><br><span class="line">if &quot;%data%&quot;&#x3D;&#x3D;&quot;running.&quot; (</span><br><span class="line">cd C:\Users\z8442\</span><br><span class="line">devcon disable &quot;HID_DEVICE_UP:000D_U:0004*&quot;&gt;nul</span><br><span class="line">cd C:\Users\z8442\Desktop\</span><br><span class="line">rename &quot;Touch ON.bat&quot; &quot;Touch OFF.bat&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">if &quot;%data%&quot;&#x3D;&#x3D;&quot;disabled.&quot; (</span><br><span class="line">cd C:\Users\z8442\</span><br><span class="line">devcon enable &quot;HID_DEVICE_UP:000D_U:0004*&quot;&gt;nul</span><br><span class="line">cd C:\Users\z8442\Desktop\</span><br><span class="line">rename &quot;Touch OFF.bat&quot; &quot;Touch ON.bat&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">del C:\data.txt</span><br></pre></td></tr></table></figure>
<p>注释： 以上 ”C:\\Users\\z8442\\Desktop\\“是我的桌面地址，显示状态的脚本在我的桌面上。 “C:\\Users\\z8442\\“是存放devcon.exe的地方，当然推荐存放在C:\\Windows\\System32，这样这一句就可以省去。这里唠叨一下，这个devcon可以通过命令提示符直接控制硬件驱动状态，应该每个windows 10都有，在C:\\Program Files (x86)\\Intel\\Bluetooth\\utilities\\Devcon.exe，如果没有也可以在<a href="http://47.94.231.166/archives/90/devcon">这里</a>下载 从第一个cd C:\\Users\\z8442\\语句前的那一大段是来自网络的提权命令。 <code>HID_DEVICE_UP:000D_U:0004</code>是我的触控屏硬件id，不同电脑中触控屏的硬件id不一定相同，可以在Windows自带的设备管理器中的”人体工程学设备“中找到触控屏进而找到该id。   显示状态的脚本内容上只要能打开该脚本就可以，但对名字有特殊要求，只能是Touch ON或者Touch OFF。 下面附上不需桌面显示状态的脚本直接就能使用的脚本（但是可能需要更改硬件id）&gt;<a href="http://47.94.231.166/archives/90/touch">Touch</a></p>
]]></content>
      <categories>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>批处理</tag>
        <tag>开关</tag>
      </tags>
  </entry>
  <entry>
    <title>#批处理#  又一个天坑</title>
    <url>/2018/04/14/%E6%89%B9%E5%A4%84%E7%90%86-%E5%8F%88%E4%B8%80%E4%B8%AA%E5%A4%A9%E5%9D%91/</url>
    <content><![CDATA[<p>本来想做一个walkman同步工具，可以在向设备自动复制音乐的同时根据电脑上音乐文件夹的名字新建或者更新播放列表，但是尽管脚本运行得很顺利，生成的播放列表却不能被设备识别，算是一个天坑工程了。但是这个脚本里使用了多个新颖的地址裁切方式，还是有必要留作纪念以便日后查阅。在此将源代码与注释写在下面。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set pc_playlist_root_path&#x3D;C:\Users\z8442\Desktop\test rem 设置电脑端同步地址</span><br><span class="line">setlocal EnableDelayedExpansion</span><br><span class="line">for &#x2F;f &quot;delims&#x3D;&quot; %%h in (&#39;dir &#x2F;b &#x2F;ad %pc_playlist_root_path% &#39;) do (</span><br><span class="line">set pc_playlist_floder_path_pre&#x3D;!pc_playlist_root_path!\%%h</span><br><span class="line">call :continue !pc_playlist_floder_path_pre! rem 遍历电脑端同步地址内的文件，得到完整的文件路径</span><br><span class="line">)</span><br><span class="line">goto :eof</span><br><span class="line">:continue</span><br><span class="line">set pc_playlist_floder_path&#x3D;%~f1 rem</span><br><span class="line">set device_root_path&#x3D;C:\Users\z8442\Desktop\walkman rem 设置设备根目录</span><br><span class="line"></span><br><span class="line">call :cutA %pc_playlist_floder_path% rem 将得到的完整文件路径分离为播放列表名与去引号的完整文件路径</span><br><span class="line">call :cutB %device_root_path% rem 将得到的设备根目录分解得到设备根目录盘符与去引号的设备根目录</span><br><span class="line">cd\</span><br><span class="line">%device_root_mark%</span><br><span class="line">cd %device_root_path% rem 将目前的工作环境切换到设备根目录</span><br><span class="line">if exist %playlist_name%.m3u goto :ecopy rem 检查播放列表是否存在</span><br><span class="line">echo 新播放列表！</span><br><span class="line">echo #EXTM3U&gt;%playlist_name%.m3u rem 若不存在，用分离得到的名字新建一个播放列表</span><br><span class="line">setlocal EnableDelayedExpansion</span><br><span class="line">for &#x2F;f &quot;delims&#x3D;&quot; %%a in (&#39;dir &#x2F;b&#x2F;a-d&#x2F;oN &quot;%pc_playlist_floder_path%&quot;&#39;) do (</span><br><span class="line">copy &#x2F;y &quot;%pc_playlist_floder_path_no_quotation_marks%\%%a&quot; &quot;%device_root_path%&quot;</span><br><span class="line">echo #EXTINF:0,%%~na&gt;&gt;%playlist_name%.m3u rem 逐个复制文件，每复制一个，在播放列表中写一行“#EXTINF:0,文件名”</span><br><span class="line">echo %%a&gt;&gt;%playlist_name%.m3u rem 再将无盘符的文件路径追加在下面一行</span><br><span class="line">)</span><br><span class="line">goto :eof</span><br><span class="line">:ecopy rem 若已存在，直接追加</span><br><span class="line">setlocal EnableDelayedExpansion</span><br><span class="line">for &#x2F;f &quot;delims&#x3D;&quot; %%a in (&#39;dir &#x2F;b&#x2F;a-d&#x2F;oN &quot;%pc_playlist_floder_path%&quot;&#39;) do (</span><br><span class="line">findstr &quot;%%~na&quot; &quot;%device_root_path_no_quotation_marks%\%playlist_name%.m3u&quot; rem 寻找设备中没有但电脑中有的文件，如果有，将其同步到设备上</span><br><span class="line">if !errorlevel!&#x3D;&#x3D;1 (</span><br><span class="line">copy &#x2F;y &quot;%pc_playlist_floder_path_no_quotation_marks%\%%a&quot; &quot;%device_root_path%&quot;</span><br><span class="line">echo 新文件！</span><br><span class="line">echo #EXTINF:0,%%~na&gt;&gt;%playlist_name%.m3u rem 每复制一个，在播放列表中写一行“#EXTINF:0,文件名”</span><br><span class="line">echo %%a&gt;&gt;%playlist_name%.m3u ) rem 再将无盘符的文件路径追加在下面一行</span><br><span class="line">)</span><br><span class="line">goto :eof</span><br><span class="line"></span><br><span class="line">:cutA</span><br><span class="line">set playlist_name&#x3D;%~n1 rem 切割播放列表名</span><br><span class="line">set pc_playlist_floder_path_no_quotation_marks&#x3D;%~f1 rem 去掉引号</span><br><span class="line">goto :eof</span><br><span class="line">:cutB</span><br><span class="line">set device_root_path_no_quotation_marks&#x3D;%~f1 rem 去掉引号</span><br><span class="line">set device_root_mark&#x3D;%~d1 rem 获得设备所在的盘符</span><br><span class="line">goto :eof</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>批处理</tag>
        <tag>Walkman</tag>
        <tag>天坑</tag>
      </tags>
  </entry>
  <entry>
    <title>#批处理# 注册表开关生成器</title>
    <url>/2018/03/14/%E6%89%B9%E5%A4%84%E7%90%86-%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%BC%80%E5%85%B3%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>日常是否频繁更改一些隐藏的很深的系统设置？如果是，这个小脚本就是为你设计的<br><a id="more"></a><br>近期想要练习双拼，但是因为技术还不到家所以真正打字时还得回到全拼，每次这样改来改去感觉很麻烦，所以就做了这个注册表开关生成器，只要知道控制该功能的注册表地址+键值和开关分别代表的数值就可以生成对应的开关了。 生成的开关效果如图： 隐藏文件 开 ↓ <a href="http://47.94.231.166/archives/112/2018-03-14_22-36-14"><img src="http://47.94.231.166/wp-content/uploads/2018/03/2018-03-14_22-36-14.png" alt=""></a> 隐藏文件 关 ↓ <a href="http://47.94.231.166/archives/112/2018-03-14_22-42-08"><img src="http://47.94.231.166/wp-content/uploads/2018/03/2018-03-14_22-42-08.png" alt=""></a> 该工具完全傻瓜级，可以放心使用。运行截图： <a href="http://47.94.231.166/archives/112/cmd_2018-03-14_22-44-19"><img src="http://47.94.231.166/wp-content/uploads/2018/03/cmd_2018-03-14_22-44-19-300x191.png" alt=""></a> 下载：<a href="http://47.94.231.166/archives/112/reg-action-creator-ver-1-0">Reg Action Creator Ver 1.0</a> </p>
</blockquote>
<h2 id="那么问题来了，如何得到需要控制的功能对应的注册表键值呢？"><a href="#那么问题来了，如何得到需要控制的功能对应的注册表键值呢？" class="headerlink" title="那么问题来了，如何得到需要控制的功能对应的注册表键值呢？"></a>那么问题来了，如何得到需要控制的功能对应的注册表键值呢？</h2><p>下面就要介绍一个叫RegShot的小应用，这款应用可以给注册表截图并分析，通过对开关功能的两张截图分析就可以确定期间被更改了的注册表从而筛选出所需的键值。<a href="http://47.94.231.166/archives/112/regshot_2018-03-14_22-51-15"><img src="http://47.94.231.166/wp-content/uploads/2018/03/Regshot_2018-03-14_22-51-15-300x263.png" alt=""></a> 版权原因就不放下载链接了网上各大下载站都能搞到。  附送一个清空文件夹的脚本：<a href="http://47.94.231.166/archives/112/%e6%b8%85%e7%a9%ba%e6%96%87%e4%bb%b6%e5%a4%b9%e5%bc%80%e5%85%b3">清空文件夹开关</a> 假如你想快速清空某些经常需要清空的文件夹的话（比如截图文件夹），可以试试这个。</p>
]]></content>
      <categories>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>批处理</tag>
        <tag>开关</tag>
        <tag>注册表</tag>
      </tags>
  </entry>
  <entry>
    <title>#批处理#  网络测试脚本</title>
    <url>/2018/03/11/%E6%89%B9%E5%A4%84%E7%90%86-%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>这是一个可以自动判断网络连接故障所在的脚本，通过依次测试ping localhost，自身ip，网关ip，指定广域网ip（默认百度），host文件，任意域名来确定网络故障（手动输入还可以指定局域网内的一台设备来确认局域网的工作）。<br><a id="more"></a><br>自动获取ip的提示： 首先找到ipconfig出来的文件，如果第一次运行获取的ip不正确它应该在 C:\\CIAdata\\ipconfig.$$$ 数行数，不包括空行，一直数到ip地址所在的行（包括）。 把这个数字覆盖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for &#x2F;f &quot;delims&#x3D;&quot; %%a in (C:\CIAdata\ipconfig.$$$) do set &#x2F;a m+&#x3D;1&amp;set &quot;_!m!&#x3D;%%a&quot;</span><br><span class="line">set &#x2F;a m&#x3D;8</span><br><span class="line">set ip&#x3D;!_%m%:~37,52!</span><br><span class="line">set &#x2F;a m&#x3D;10</span><br><span class="line">set dg&#x3D;!_%m%:~35,52!</span><br></pre></td></tr></table></figure>
<p>这里m=后面的数字，第二个m=之前数的行数加二。 如果嫌麻烦可以直接找到ip和网关然后重启脚本选择用手动输入，但是自动输入一旦设定完毕就可以一劳永逸了。 下载：<a href="http://47.94.231.166/archives/79/%e7%bd%91%e7%bb%9c%e6%b5%8b%e8%af%95">网络测试</a></p>
]]></content>
      <categories>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>批处理</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>#摘抄# 村上春树的世界 1</title>
    <url>/2018/05/06/%E6%91%98%E6%8A%84-%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91%E7%9A%84%E4%B8%96%E7%95%8C-1/</url>
    <content><![CDATA[<h4 id="从看过阅过村上先生的第一本书——《且听风吟》之后我就爱上了他的风格。从今天下午刚刚合上《神的孩子全跳舞》以来，不知不觉间已经读了他的11本书。读他的书感觉不像看什么世纪大作那样让你感到恢弘震撼，也不像读某些感情深刻的文章让你流泪心碎，但你可以从他的文章那里嗅到太平洋的海风带来的微微腥味，可以看到咖啡馆天花板上徐徐旋转的复古吊扇，可以寻到一个心思缜密又永远有稀奇故事可讲的挚友在等你，那是一种别样的体验。下面是我做的一些摘抄，有些纯粹是文字优雅，有些则是颇有共鸣。希望大家喜欢。"><a href="#从看过阅过村上先生的第一本书——《且听风吟》之后我就爱上了他的风格。从今天下午刚刚合上《神的孩子全跳舞》以来，不知不觉间已经读了他的11本书。读他的书感觉不像看什么世纪大作那样让你感到恢弘震撼，也不像读某些感情深刻的文章让你流泪心碎，但你可以从他的文章那里嗅到太平洋的海风带来的微微腥味，可以看到咖啡馆天花板上徐徐旋转的复古吊扇，可以寻到一个心思缜密又永远有稀奇故事可讲的挚友在等你，那是一种别样的体验。下面是我做的一些摘抄，有些纯粹是文字优雅，有些则是颇有共鸣。希望大家喜欢。" class="headerlink" title="从看过阅过村上先生的第一本书——《且听风吟》之后我就爱上了他的风格。从今天下午刚刚合上《神的孩子全跳舞》以来，不知不觉间已经读了他的11本书。读他的书感觉不像看什么世纪大作那样让你感到恢弘震撼，也不像读某些感情深刻的文章让你流泪心碎，但你可以从他的文章那里嗅到太平洋的海风带来的微微腥味，可以看到咖啡馆天花板上徐徐旋转的复古吊扇，可以寻到一个心思缜密又永远有稀奇故事可讲的挚友在等你，那是一种别样的体验。下面是我做的一些摘抄，有些纯粹是文字优雅，有些则是颇有共鸣。希望大家喜欢。"></a>从看过阅过村上先生的第一本书——《且听风吟》之后我就爱上了他的风格。从今天下午刚刚合上《神的孩子全跳舞》以来，不知不觉间已经读了他的11本书。读他的书感觉不像看什么世纪大作那样让你感到恢弘震撼，也不像读某些感情深刻的文章让你流泪心碎，但你可以从他的文章那里嗅到太平洋的海风带来的微微腥味，可以看到咖啡馆天花板上徐徐旋转的复古吊扇，可以寻到一个心思缜密又永远有稀奇故事可讲的挚友在等你，那是一种别样的体验。下面是我做的一些摘抄，有些纯粹是文字优雅，有些则是颇有共鸣。希望大家喜欢。</h4><a id="more"></a>
<h4 id="村上春树《且听风吟》"><a href="#村上春树《且听风吟》" class="headerlink" title="村上春树《且听风吟》"></a>村上春树《且听风吟》</h4><p>38  章</p>
<blockquote>
<p>一切都将一去杳然，任何人都无法将其捕获。 我们便是这样活着。  </p>
</blockquote>
<h4 id="村上春树-《萤》"><a href="#村上春树-《萤》" class="headerlink" title="村上春树 《萤》"></a>村上春树 《萤》</h4><blockquote>
<p>死非生的对立面，而作为生的一部分永存。</p>
</blockquote>
<h4 id="村上春树-《再袭面包店》"><a href="#村上春树-《再袭面包店》" class="headerlink" title="村上春树  《再袭面包店》"></a>村上春树  《再袭面包店》</h4><p>序·远游的房间</p>
<blockquote>
<p>任何人一生当中都在寻找一个宝贵的东西，但能够找到的人并不多。即使幸运地找到了，实际找到的东西也已受到致命的损毁。尽管如此，我们仍然继续寻找不止。因为若不这样做，生之意义本身便不复存在。</p>
</blockquote>
<h4 id="村上春树-《挪威的森林》"><a href="#村上春树-《挪威的森林》" class="headerlink" title="村上春树 《挪威的森林》"></a>村上春树 《挪威的森林》</h4><p>第八章</p>
<blockquote>
<p>“同他交谈起来，时常觉得我总在同一个地方来回兜圈子。他以同一程序不断勇往直前，而我总是原地徘徊，并且空虚得很。一句话，就是人生观本身不同。”</p>
</blockquote>
<p>第十章</p>
<blockquote>
<p>“不要同情自己！”他说，“同情自己是卑劣懦夫干的勾当。”</p>
</blockquote>
<h4 id="村上春树-《国境以南-太阳以西》"><a href="#村上春树-《国境以南-太阳以西》" class="headerlink" title="村上春树  《国境以南  太阳以西》"></a>村上春树  《国境以南  太阳以西》</h4><p>第七章</p>
<blockquote>
<p>“一码事，这个世界和那个世界是一码事。下雨花开，不下枯死，虫被蜥蜴吃，蜥蜴被鸟吃，但都要死去。死后变成干巴巴的空壳。这一代死了，下一代取代之，铁的定律。活法林林总总，死法种种样样，都没什么大不了的。剩下来的唯独沙漠，真正活着的只有沙漠。“</p>
</blockquote>
<p>第十二章</p>
<blockquote>
<p>“非常遗憾的是，某种事物时不能后退的。一旦推向前去，就再也后退不得，怎么努力都无济于事。假如当时出了差错——哪怕错一点点——那么也只能将错就错。”</p>
</blockquote>
<h4 id="村上春树-《神的孩子全跳舞》"><a href="#村上春树-《神的孩子全跳舞》" class="headerlink" title="村上春树  《神的孩子全跳舞》"></a>村上春树  《神的孩子全跳舞》</h4><p>序  </p>
<blockquote>
<p>广播新闻：美军有不少人战死，而越南南方民族解放阵线方面也有一百一十五人阵亡。 女：“无名这东西真是可怕。” 男：“你说什么?” 女：“光说游击队死了一百一十五人是什么都搞不清楚的。根本不知晓具体每个人的情况——有没有妻子儿女，喜欢戏剧还是更喜欢电影，全都一无所知。只知道死了一百一十五人。” ——让·吕克·戈达尔《疯狂小丑》</p>
</blockquote>
<p>  泰国之旅</p>
<blockquote>
<p>您很漂亮，大夫。聪明、刚强，但看上去心上总像有一道阴影。往后，你要准备慢慢走向死神才行。若在生的方面费力太多，就难以死得顺利。必须一点点换挡。生与死，在某种意义上是等价的。</p>
</blockquote>
<p>  神的孩子全跳舞</p>
<blockquote>
<p>他闭目合眼，肌肤感受着皎洁的月光，独自跳了起来。深吸一口气，旋即吐出。一时想不起与心情吻合的动听音乐，于是随青草的摇曳和云絮的飘逸挪动舞步。跳舞时似乎有人从哪里注视自己。善也可以真真切切的感觉出自己置身于某人的视野之内，他的身体他的肌肤他的骨骸都感受到了，但那怎么都无所谓。管他是谁，想看就看好了。神的孩子全跳舞。</p>
</blockquote>
<p>  蜂蜜饼</p>
<blockquote>
<p>要写和以往不同的小说，淳平心想。天光破晓，一片光明，在那光明中紧紧地拥抱心爱的人们——就这样写小说，写任何人都在梦中苦苦期待的小说。但此时此刻必须先在这里守护两个女性。不管对方是谁，都不能允许他把她们投入莫名其妙的箱子——哪怕天空劈头塌落，大地应声炸裂……</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记&amp;amp;书评</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>#教程# 使用Foobar 2000无损合并/转换WAV文件</title>
    <url>/2018/04/22/%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8foobar-2000%E6%97%A0%E6%8D%9F%E5%90%88%E5%B9%B6-%E8%BD%AC%E6%8D%A2wav%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>合并音频及其转换不是什么困难的任务，但是使用格式工厂等市面上现有的转换工具往往会导致音质压缩（高质量下，测试文件转换为FLAC最高达到16bit 400Kbps），下面使用Foobar2000进行转换，可达到最高质量（高质量下，测试文件转换为FLAC最高达到24bit 888Kbps）<br><a id="more"></a><br>最近在B站听桃子翻译的同人音声，有一个非常喜欢，可是没有大会员最高下载视频质量只有720p，经过压缩的视频中提取出的音频更是渣得可怜，108分钟仅仅40兆！于是一气之下就到DLsite购买了原版支持作者，只不过下载后并不是整轨文件，需要我们手动合成，这就需要神器Foobar来帮忙了。</p>
</blockquote>
<h3 id="注意：该方法只能合并同一个专辑下的音频文件，若想合并不同专辑下的音频，请删除或者统一专辑信息。"><a href="#注意：该方法只能合并同一个专辑下的音频文件，若想合并不同专辑下的音频，请删除或者统一专辑信息。" class="headerlink" title="注意：该方法只能合并同一个专辑下的音频文件，若想合并不同专辑下的音频，请删除或者统一专辑信息。"></a>注意：该方法只能合并同一个专辑下的音频文件，若想合并不同专辑下的音频，请删除或者统一专辑信息。</h3><h1 id="Part-1：合并文件"><a href="#Part-1：合并文件" class="headerlink" title="Part 1：合并文件"></a>Part 1：合并文件</h1><h4 id="首先我们把这些分散的音频文件拖入foobar-2000，这里可能有点乱码，因为源文件信息是日文编码，可是我们目前使用的是中文操作系统导致的，生成文件后可以用MP3tag等音乐标签应用更改一下音频信息即可。"><a href="#首先我们把这些分散的音频文件拖入foobar-2000，这里可能有点乱码，因为源文件信息是日文编码，可是我们目前使用的是中文操作系统导致的，生成文件后可以用MP3tag等音乐标签应用更改一下音频信息即可。" class="headerlink" title="首先我们把这些分散的音频文件拖入foobar 2000，这里可能有点乱码，因为源文件信息是日文编码，可是我们目前使用的是中文操作系统导致的，生成文件后可以用MP3tag等音乐标签应用更改一下音频信息即可。"></a>首先我们把这些分散的音频文件拖入foobar 2000，这里可能有点乱码，因为源文件信息是日文编码，可是我们目前使用的是中文操作系统导致的，生成文件后可以用MP3tag等音乐标签应用更改一下音频信息即可。</h4><h4 id=""><a href="#" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-31-06"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-31-06.png" alt=""></a></h4><h4 id="在Foobar2000中选中所有文件，右键→Convert→…"><a href="#在Foobar2000中选中所有文件，右键→Convert→…" class="headerlink" title="在Foobar2000中选中所有文件，右键→Convert→…"></a>在Foobar2000中选中所有文件，右键→Convert→…</h4><p><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-31-15.png" alt=""></p>
<h4 id="在弹出的对话框中选择Destination"><a href="#在弹出的对话框中选择Destination" class="headerlink" title="在弹出的对话框中选择Destination"></a>在弹出的对话框中选择Destination</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-31-30"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-31-30.png" alt=""></a></h4><h4 id="在对话框中选择Output-style-and-file-name-formatting中的Generate-multi-track-files然后点下面的Back返回刚才的页面"><a href="#在对话框中选择Output-style-and-file-name-formatting中的Generate-multi-track-files然后点下面的Back返回刚才的页面" class="headerlink" title="在对话框中选择Output style and file name formatting中的Generate multi-track files然后点下面的Back返回刚才的页面"></a>在对话框中选择Output style and file name formatting中的Generate multi-track files然后点下面的Back返回刚才的页面</h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-31-39"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-31-39.png" alt=""></a></h4><h4 id="确认一下Destination这一栏信息的改变"><a href="#确认一下Destination这一栏信息的改变" class="headerlink" title="确认一下Destination这一栏信息的改变"></a>确认一下Destination这一栏信息的改变</h4><h4 id="-3"><a href="#-3" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-31-45"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-31-45.png" alt=""></a></h4><h4 id="然后直接点击下方Convert生成"><a href="#然后直接点击下方Convert生成" class="headerlink" title="然后直接点击下方Convert生成"></a>然后直接点击下方Convert生成</h4><h4 id="-4"><a href="#-4" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-31-55"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-31-55.png" alt=""></a></h4><h4 id="选择生成文件的保存路径，这里还会存储CUE音频轨道信息，不需要的话可以在生成后直接删除"><a href="#选择生成文件的保存路径，这里还会存储CUE音频轨道信息，不需要的话可以在生成后直接删除" class="headerlink" title="选择生成文件的保存路径，这里还会存储CUE音频轨道信息，不需要的话可以在生成后直接删除"></a>选择生成文件的保存路径，这里还会存储CUE音频轨道信息，不需要的话可以在生成后直接删除</h4><h4 id="-5"><a href="#-5" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-32-11"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-32-11.png" alt=""></a></h4><h4 id="然后等待操作完成就可以了"><a href="#然后等待操作完成就可以了" class="headerlink" title="然后等待操作完成就可以了"></a>然后等待操作完成就可以了</h4><h4 id="-6"><a href="#-6" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-32-20"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-32-20.png" alt=""></a></h4><h4 id="这就是合并的文件了，体积基本为所有分散文件体积之和，当然信息量也不会变"><a href="#这就是合并的文件了，体积基本为所有分散文件体积之和，当然信息量也不会变" class="headerlink" title="这就是合并的文件了，体积基本为所有分散文件体积之和，当然信息量也不会变"></a>这就是合并的文件了，体积基本为所有分散文件体积之和，当然信息量也不会变</h4><h4 id="-7"><a href="#-7" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-32-55"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-32-55.png" alt=""></a></h4><h1 id="Part-2：转换wav为FLAC"><a href="#Part-2：转换wav为FLAC" class="headerlink" title="Part 2：转换wav为FLAC"></a>Part 2：转换wav为FLAC</h1><p>  _FLAC作为专门为音频制作的压缩格式可以在基本保存原有信息量的同时大量削减文件体积，而且随着各种电子设备的不断跟进也提供了良好的兼容性，是我们转换无损音频的不二之选。_  </p>
<h4 id="将合并的音频文件拖入Foobar2000，右键→Convert→Quick-Convert"><a href="#将合并的音频文件拖入Foobar2000，右键→Convert→Quick-Convert" class="headerlink" title="将合并的音频文件拖入Foobar2000，右键→Convert→Quick Convert"></a>将合并的音频文件拖入Foobar2000，右键→Convert→Quick Convert</h4><h4 id="-8"><a href="#-8" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-33-21"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-33-21.png" alt=""></a></h4><h4 id="在弹出的对话框中选择FLAC，并点击下方的Convert，这里如果是第一次转换Foobar-2000可能会弹出对话框让用户选择FLAC编码器，因为Foobar-2000是不自带FLAC编码器的。这时就需要到网上搜索这个编码器并下载，然后选中即可。"><a href="#在弹出的对话框中选择FLAC，并点击下方的Convert，这里如果是第一次转换Foobar-2000可能会弹出对话框让用户选择FLAC编码器，因为Foobar-2000是不自带FLAC编码器的。这时就需要到网上搜索这个编码器并下载，然后选中即可。" class="headerlink" title="在弹出的对话框中选择FLAC，并点击下方的Convert，这里如果是第一次转换Foobar 2000可能会弹出对话框让用户选择FLAC编码器，因为Foobar 2000是不自带FLAC编码器的。这时就需要到网上搜索这个编码器并下载，然后选中即可。"></a>在弹出的对话框中选择FLAC，并点击下方的Convert，这里如果是第一次转换Foobar 2000可能会弹出对话框让用户选择FLAC编码器，因为Foobar 2000是不自带FLAC编码器的。这时就需要到网上搜索这个编码器并下载，然后选中即可。</h4><h4 id="-9"><a href="#-9" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-33-54"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-33-54.png" alt=""></a></h4><h4 id="之后同样会弹出对话框让用户选择生成文件的保存路径，选择后点击保存即可继续，然后等待转换完毕即可。"><a href="#之后同样会弹出对话框让用户选择生成文件的保存路径，选择后点击保存即可继续，然后等待转换完毕即可。" class="headerlink" title="之后同样会弹出对话框让用户选择生成文件的保存路径，选择后点击保存即可继续，然后等待转换完毕即可。"></a>之后同样会弹出对话框让用户选择生成文件的保存路径，选择后点击保存即可继续，然后等待转换完毕即可。</h4><h4 id="-10"><a href="#-10" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-34-13"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-34-13.png" alt=""></a></h4><h4 id="这就是转换后的的音频，可以看到压缩掉了近乎63-的体积"><a href="#这就是转换后的的音频，可以看到压缩掉了近乎63-的体积" class="headerlink" title="这就是转换后的的音频，可以看到压缩掉了近乎63%的体积"></a>这就是转换后的的音频，可以看到压缩掉了近乎63%的体积</h4><h4 id="-11"><a href="#-11" class="headerlink" title=""></a><a href="http://upane.cn/archives/220/2018-04-22_09-35-26"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_09-35-26.png" alt=""></a></h4><h4 id="↓第一张是生成后的文件频谱图，第二张更改了歌曲信息后与源文件比对，可以看出信息量基本是不变的↓"><a href="#↓第一张是生成后的文件频谱图，第二张更改了歌曲信息后与源文件比对，可以看出信息量基本是不变的↓" class="headerlink" title="↓第一张是生成后的文件频谱图，第二张更改了歌曲信息后与源文件比对，可以看出信息量基本是不变的↓"></a>↓第一张是生成后的文件频谱图，第二张更改了歌曲信息后与源文件比对，可以看出信息量基本是不变的↓</h4><p><a href="http://upane.cn/archives/220/spek_2018-04-22_09-39-51"><img src="http://47.94.231.166/wp-content/uploads/2018/04/spek_2018-04-22_09-39-51.png" alt=""></a> <a href="http://upane.cn/archives/220/2018-04-22_10-54-51"><img src="http://47.94.231.166/wp-content/uploads/2018/04/2018-04-22_10-54-51.png" alt=""></a> 然后传到Walkman里就可以享受HiRes版的浅见小姐姐啦   <a href="http://upane.cn/archives/220/attachment/35"><img src="http://47.94.231.166/wp-content/uploads/2018/04/35.png" alt=""></a> 金标闪亮，脑放无敌  <a href="http://upane.cn/archives/220/attachment/43"><img src="http://47.94.231.166/wp-content/uploads/2018/04/43.png" alt=""></a> <a href="http://upane.cn/archives/220/screenshot_20180422_094331389"><img src="http://47.94.231.166/wp-content/uploads/2018/04/screenshot_20180422_094331389.png" alt=""></a> <a href="http://upane.cn/archives/220/screenshot_20180422_094429066"><img src="http://47.94.231.166/wp-content/uploads/2018/04/screenshot_20180422_094429066.png" alt=""></a></p>
<h4 id="什么？你问我Walkman怎么截的图？"><a href="#什么？你问我Walkman怎么截的图？" class="headerlink" title="什么？你问我Walkman怎么截的图？"></a>什么？你问我Walkman怎么截的图？</h4><p>下回Walkman评测时我们再谈啦  <a href="http://upane.cn/archives/220/attachment/35"><img src="http://47.94.231.166/wp-content/uploads/2018/04/35.png" alt=""></a></p>
]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>#杂谈# Sensei Pixiv临摹学习1</title>
    <url>/2018/03/18/%E6%9D%82%E8%B0%88-sensei-pixiv%E4%B8%B4%E6%91%B9%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<p>弄足了劲画了一小时，感觉比较满意<br><a id="more"></a><br><img src="http://47.94.231.166/wp-content/uploads/2018/03/pixivSketch-225x300.png" alt="">   那个男生真帅，现实生活中恐怕很少能找到这么帅的人了吧。   <a href="http://47.94.231.166/archives/149/chrome_2018-03-18_22-39-14"><img src="http://47.94.231.166/wp-content/uploads/2018/03/chrome_2018-03-18_22-39-14-300x241.png" alt=""></a> 比起来应该算是画得比较好的了<a href="http://47.94.231.166/51"><img src="http://47.94.231.166/wp-content/uploads/2018/03/51.png" alt=""></a></p>
]]></content>
      <categories>
        <category>画廊</category>
        <category>茶余杂谈</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>绘画</tag>
      </tags>
  </entry>
  <entry>
    <title>#网络# 微软重定向网页</title>
    <url>/2018/03/23/%E7%BD%91%E7%BB%9C-%E5%BE%AE%E8%BD%AF%E9%87%8D%E5%AE%9A%E5%90%91%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://www.msftconnecttest.com/redirect">http://www.msftconnecttest.com/redirect</a></p>
</blockquote>
<p>这个网址可以快速从定向到校园网等需要验证网络的登陆界面，虽然设备都会弹出提示，但是如果错过提示就会导致无法再打开登陆界面（某些比较细心的网站访问任何网页都能重定向到登陆界面，但是校园网不是 括弧笑） 该地址提取自Windows跳转页，请放心使用。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】js学习小笔记 5#</title>
    <url>/2019/05/14/%E3%80%90js%E3%80%91js%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%AC%94%E8%AE%B0-5/</url>
    <content><![CDATA[<p>你捡起了道具：<strong>遗失的纸片5#</strong> 一张普通的纸片，隐隐约约能够看到目录：<strong>“事件对象、BOM、定时器、JSON”</strong>。边角还有被撕扯的痕迹，它们应该属于一个笔记本，但不知为什么被主人撕下来丢掉了。 提示：集齐所有纸片应该可以得到一本技能书。 👇点击下方按钮调查<br><a id="more"></a></p>
<h2 id="29-事件对象"><a href="#29-事件对象" class="headerlink" title="29.事件对象"></a>29.事件对象</h2><ul>
<li>当事件的响应函数被触发时，<strong>浏览器每次都将一个事件对象作为实参传递进响应函数</strong></li>
<li>在事件对象中封装了<strong>当前事件相关的一切信息</strong>，如鼠标的坐标、按下的键、滚轮滚动的方向等</li>
</ul>
<h3 id="①mouseEvent"><a href="#①mouseEvent" class="headerlink" title="①mouseEvent"></a>①mouseEvent</h3><p>该事件将会在鼠标再元素中移动时被触发 <strong>常用属性：</strong></p>
<ul>
<li>相对于浏览器窗口：<ol>
<li>clientX→指针水平坐标</li>
<li>clientY→指针垂直坐标</li>
</ol>
</li>
<li>相对于页面（IE8+)<ol>
<li>pageX→指针水平坐标</li>
<li>pageY→指针垂直坐标</li>
</ol>
</li>
</ul>
<p>在IE8及以下版本的浏览器中，响应函数被触发时浏览器不会传递事件对象，取而代之，其会将时间作为window对象的属性保存。</p>
<blockquote>
<p>window.event</p>
</blockquote>
<p>该属性在火狐浏览器中不存在</p>
<h3 id="②全兼容方式："><a href="#②全兼容方式：" class="headerlink" title="②全兼容方式："></a>②全兼容方式：</h3><p>在响应函数中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event=eventwindow.event;</span><br></pre></td></tr></table></figure>
<h3 id="④事件的冒泡"><a href="#④事件的冒泡" class="headerlink" title="④事件的冒泡"></a>④事件的冒泡</h3><ul>
<li>所谓的冒泡指的就是<strong>事件的向上传导</strong>，当后代元素的事件被触发时，其<strong>祖先元素</strong>的<strong>相同事件</strong>也会被触发</li>
<li>在开发中大部分情况冒泡是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡：将<code>event.cancelBubble</code>设置为true即可取消冒泡</li>
</ul>
<h3 id="⑤事件的委派"><a href="#⑤事件的委派" class="headerlink" title="⑤事件的委派"></a>⑤事件的委派</h3><p>我们希望，只绑定依次事件，即可应用到若干元素上，即使元素是后添加的。</p>
<blockquote>
<p>可以尝试将其绑定给元素共同的祖先元素→<strong>原事件冒泡到祖先事件</strong></p>
</blockquote>
<p><strong>事件的委派：</strong> - 指将事件统一绑定给元素的共同祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素从而通过祖先元素的响应函数来处理事件 - 事件的委派利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能 <strong>防止祖先元素被触发：</strong>如果触发事件的对象是我们期望的元素则执行，否则不执行 使用<code>event.target</code>属性可以得到触发事件的元素</p>
<h3 id="⑥事件的绑定"><a href="#⑥事件的绑定" class="headerlink" title="⑥事件的绑定"></a>⑥事件的绑定</h3><h4 id="㈠addEventListener-（IE8-）"><a href="#㈠addEventListener-（IE8-）" class="headerlink" title="㈠addEventListener() （IE8+）"></a>㈠addEventListener() （IE8+）</h4><p>通过该方法可为元素绑定响应函数 <strong>参数：</strong> 1. 时间的字符串，<strong>不要“on”</strong> 1. 回调函数，当事件触发时该函数会被调用 1. 是否在捕获阶段触发事件，需要一个布尔值，<strong>一般都传“false”</strong> 使用addEventListener()可谓一个元素的相同事件同时绑定多个响应函数，这样当事件触发时，响应函数将会<strong>按照函数的绑定顺序执行this绑定的事件</strong></p>
<h4 id="㈡attachEvent-（IE1-10）"><a href="#㈡attachEvent-（IE1-10）" class="headerlink" title="㈡attachEvent() （IE1~10）"></a>㈡attachEvent() （IE1~10）</h4><p><strong>参数：</strong> 1. 事件字符串<strong>（要on）</strong> 1. 回调函数 该方法可同时为一个事件绑定多个处理函数 不同的是它是<strong>后绑定先执行</strong>，执行顺序与addEventListener()相反</p>
<h4 id="㈢全兼容方式："><a href="#㈢全兼容方式：" class="headerlink" title="㈢全兼容方式："></a>㈢全兼容方式：</h4><ol>
<li>obj→要绑定的对象</li>
<li>eventStr→事件的字符串 <strong>(不要on)</strong></li>
<li>callback→回调函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">obj,eventStr,callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">obj.addEventListener</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//大部分浏览器的兼容方式</span></span><br><span class="line">        obj.addEventListener(eventStr,callback,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//this是谁由调用方式决定（callback.call(obj)）</span></span><br><span class="line">        <span class="comment">//IE8及以下浏览器</span></span><br><span class="line">        objattachEvent(<span class="string">&quot;on&quot;</span>+eventStr,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="comment">//在匿名函数中调用回调函数 </span></span><br><span class="line">            callback.call(obj);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="⑦事件的传播"><a href="#⑦事件的传播" class="headerlink" title="⑦事件的传播"></a>⑦事件的传播</h3><ul>
<li>关于事件的传播网景公司与微软公司有不同的理解<ul>
<li>微软认为事件应该是由内向外传播，也就是事件触发时，应该先出发当前元素上的事件，然后再向当前元素的祖先元素外传播，也就是该事件应该在<strong>冒泡阶段</strong>进行</li>
<li>网景认为事件应该是由外向内传播的，也就是当前事件应该先出发当前元素的最外层祖先元素的事件，然后再<strong>向内传播</strong>给后代元素</li>
</ul>
</li>
<li>W3C结合了两个公司的方案，将事件传播分成了三个阶段：<ol>
<li><strong>捕获阶段</strong> 在捕获阶段时从最外层的祖先元素向目标元素进行事件的捕获，但默认此时不会触发事件</li>
<li><strong>目标阶段</strong> 事件捕获到目标元素，捕获结束开始在目标元素上触发事件</li>
<li><strong>冒泡阶段</strong> 事件从目标元素向其祖先元素传递，依次触发祖先元素上的事件</li>
</ol>
</li>
</ul>
<h3 id="⑧滚轮事件"><a href="#⑧滚轮事件" class="headerlink" title="⑧滚轮事件"></a>⑧滚轮事件</h3><h4 id="㈠onmousewheel"><a href="#㈠onmousewheel" class="headerlink" title="㈠onmousewheel"></a>㈠onmousewheel</h4><ul>
<li>鼠标滚轮滚动的事件，会在滚轮滚动时触发</li>
<li>火狐不支持该属性，其<strong>通过addEventListener()函数绑定DOMMouseScroll事件来绑定相应函数</strong> 例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addEventListener(obj,<span class="string">&quot;DOMMouseScroll&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//相应函数体</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>兼容性解决方案：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.onmousewheel=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//相应函数体</span></span><br><span class="line">&#125;;</span><br><span class="line">addEventListener(obj,<span class="string">&quot;DOMMouseScroll&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//相应函数体</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="㈡判断方向"><a href="#㈡判断方向" class="headerlink" title="㈡判断方向"></a>㈡判断方向</h4><ol>
<li><code>event.wheelDelta</code>属性可以获取鼠标滚轮的滚动方向<ul>
<li><strong>火狐不能用</strong></li>
<li><strong>向上→120；向下→120</strong></li>
<li><strong>不看大小只看正负</strong></li>
</ul>
</li>
<li><code>event.detail</code><ul>
<li><strong>只有火狐能用</strong></li>
<li><strong>向上→-3；向下→3</strong></li>
<li><strong>不看大小只看正负</strong></li>
</ul>
</li>
<li>兼容性解决方案：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(event.wheelDelta&gt;<span class="number">0</span>event.detail&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//向上滚</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//向下滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="㈢当滚轮滚动时，若浏览器有滚动条，滚动条会随之滚动"><a href="#㈢当滚轮滚动时，若浏览器有滚动条，滚动条会随之滚动" class="headerlink" title="㈢当滚轮滚动时，若浏览器有滚动条，滚动条会随之滚动"></a>㈢当滚轮滚动时，若浏览器有滚动条，滚动条会随之滚动</h4><p>这是浏览器的默认行为，若不希望其发生，可以取消默认行为</p>
<blockquote>
<p>return false;</p>
</blockquote>
<p><strong>火狐：</strong> 使用addEventListener()方法绑定的响应函数不能通过return false来取消默认行为，需要使用event来取消默认行为：</p>
<blockquote>
<p>event.preventDefault();</p>
</blockquote>
<p><strong>兼容性解决方案：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.preventDefault&amp;&amp;event.preventDefault();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="⑨键盘事件"><a href="#⑨键盘事件" class="headerlink" title="⑨键盘事件"></a>⑨键盘事件</h3><ul>
<li>键盘事件一般都会绑定给一些可以获取到焦点的对象或者document</li>
<li>常用事件<ul>
<li>onkeydown 按键被按下 若一直按某键不松手，<strong>事件会一直触发</strong>。当onkeydown连续触发时，**第一次与第二次之间间隔会稍长一些，其余会短些，这种设计是为了防止误触</li>
<li>onkeyup 按键被松开</li>
</ul>
</li>
</ul>
<h4 id="㈠获取按键"><a href="#㈠获取按键" class="headerlink" title="㈠获取按键"></a>㈠获取按键</h4><ol>
<li>可通过<code>keycode</code>属性获取某键的Unicode编码，借此可判断哪个键被按下</li>
<li>判断组合键：除了<code>keycode</code>,event还提供<code>altkey</code>/<code>ctrlkey</code>/<code>shiftkey</code>属性，这三个用来判断alt、ctrl、shift是否被按下，按下则返回true，否则返回false</li>
</ol>
<h4 id="㈡在文本框使用键盘事件"><a href="#㈡在文本框使用键盘事件" class="headerlink" title="㈡在文本框使用键盘事件"></a>㈡在文本框使用键盘事件</h4><p>在文本框中输入内容属于onkeydown的默认行为，如果在onkeydown中取消默认行为，则输入的内容不会出现在文本框中，可用此功能屏蔽某些字的输入</p>
<h3 id="⑩实验：键控div"><a href="#⑩实验：键控div" class="headerlink" title="⑩实验：键控div"></a>⑩实验：键控div</h3><ul>
<li>keycode：<ul>
<li>左：37</li>
<li>上：38</li>
<li>右：39</li>
<li>下：40</li>
<li>顺时针增加</li>
</ul>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            width:100px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.onload&#x3D;function()&#123;</span><br><span class="line">            var div&#x3D;document.getElementsByTagName(&quot;div&quot;)[0];</span><br><span class="line">            document.onkeydown&#x3D;function (event) &#123;</span><br><span class="line">                event&#x3D;eventwindow.event;</span><br><span class="line">                var speed&#x3D;10;</span><br><span class="line">                if(event.ctrlKey)speed&#x3D;100;</span><br><span class="line">                switch (event.keyCode) &#123;</span><br><span class="line">                    case 37:div.style.left&#x3D;div.offsetLeft-speed+&quot;px&quot;;break;</span><br><span class="line">                    case 38:div.style.top&#x3D;div.offsetTop-speed+&quot;px&quot;;break;</span><br><span class="line">                    case 39:div.style.left&#x3D;div.offsetLeft+speed+&quot;px&quot;;break;</span><br><span class="line">                    case 40:div.style.top&#x3D;div.offsetTop+speed+&quot;px&quot;;break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;title&gt;keydownTest&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="实验：元素跟随鼠标"><a href="#实验：元素跟随鼠标" class="headerlink" title="实验：元素跟随鼠标"></a>实验：元素跟随鼠标</h3><p>chrome认为浏览器的滚动条是body的，火狐等浏览器认为滚动条是html标签的 <strong>解决方案：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//垂直：</span></span><br><span class="line"><span class="keyword">var</span> st=<span class="built_in">document</span>.body.scrollTopdocument.documentElement.scrollTop;</span><br><span class="line"><span class="comment">//水平：</span></span><br><span class="line"><span class="keyword">var</span> sl=<span class="built_in">document</span>.body.scrollLeftdocument.documentElement.scrollLeft;</span><br></pre></td></tr></table></figure>
<p><strong>代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #movdiv&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line">        body&#123;</span><br><span class="line">            height: 12000px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.onload&#x3D;function()&#123;</span><br><span class="line">            var movdiv&#x3D;document.getElementById(&quot;movdiv&quot;);</span><br><span class="line">            document.onmousemove&#x3D;function(e)&#123;</span><br><span class="line">                var st&#x3D;document.body.scrollTopdocument.documentElement.scrollTop;</span><br><span class="line">                var sl&#x3D;document.body.scrollLeftdocument.documentElement.scrollLeft;</span><br><span class="line">                movdiv.style.top&#x3D;e.clientY+st+&quot;px&quot;;</span><br><span class="line">                movdiv.style.left&#x3D;e.clientX+sl+&quot;px&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;movdiv&quot;&gt;甩掉我啊&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="30-BOM"><a href="#30-BOM" class="headerlink" title="30.BOM"></a>30.BOM</h2><ul>
<li>浏览器对象模型</li>
<li>BOM可以使我们通过JS<strong>操作浏览器</strong></li>
<li>在BOM中为我们提供了一组对象，用来完成浏览器的操作</li>
<li>BOM对象：<ol>
<li>window 代表的是<strong>整个浏览器窗口</strong>，同时window也是网页中的全屏对象</li>
<li>navigator 代表当前<strong>浏览器的信息</strong>，通过该对象可以来识别不同的浏览器</li>
<li>location 代表当前浏览器的<strong>地址栏信息</strong>，通过location可以获取地址栏信息或操作浏览器跳转页面</li>
<li>history 代表浏览器的<strong>历史纪录</strong>，可以通过该对象来操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在档次访问时有效</li>
<li>screen 代表用户的<strong>屏幕信息</strong>，通过该对象可以获取到用户的显示器相关信息</li>
</ol>
</li>
</ul>
<p>这些BOM对象在浏览器中都是作为window对象的属性保存的，_可以通过window对象来使用，也可以直接使用_</p>
<h3 id="①navigator"><a href="#①navigator" class="headerlink" title="①navigator"></a>①navigator</h3><p>由于历史原因，navigator中的大部分属性已经不能帮助我们识别浏览器了。一般我们只会使用<code>userAgent</code>来判断浏览器信息</p>
<h4 id="㈠userAgent"><a href="#㈠userAgent" class="headerlink" title="㈠userAgent"></a>㈠userAgent</h4><p>userAgent是一个字符串，这个字符串中含有用来描述浏览器信息的内容，不同浏览器有不同的userAgent。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ua=navigator.userAgent;</span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params"><span class="regexp">/firefox/i</span>.test(ua)</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//火狐</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params"><span class="regexp">/chrome/i</span>.test(ua)</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//chrome</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params"><span class="regexp">/msie/i</span>.test(ua)</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//IE10以下的IE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;ActiveXObject&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//IE或Edge</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="㈡对于IE10-的识别，需要寻找特有对象"><a href="#㈡对于IE10-的识别，需要寻找特有对象" class="headerlink" title="㈡对于IE10+的识别，需要寻找特有对象"></a>㈡对于IE10+的识别，需要寻找特有对象</h4><p>如：ActiveXObject→IE有，其他均没有 不能直接对window.ActiveXObject进行逻辑查找，使用以下方法查找：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(<span class="params"><span class="string">&quot;ActiveXObject&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//IE</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//非IE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="②history"><a href="#②history" class="headerlink" title="②history"></a>②history</h3><ol>
<li>length 该属性可以获取到<strong>当前访问的连接数量</strong></li>
<li>back() 该方法用来<strong>退回上一个页面</strong>，与浏览器中的回退按钮作用相同</li>
<li>forward() 该方法用来<strong>跳转到下一个页面</strong>，与浏览器中的前进按钮作用相同</li>
<li>go() 该方法可以用来<strong>跳转到指定页面</strong>，它需要一个整数作为参数：<ul>
<li>正数n→向前跳转n个页面</li>
<li>负数n→向后跳转n个页面</li>
</ul>
</li>
</ol>
<h3 id="③location"><a href="#③location" class="headerlink" title="③location"></a>③location</h3><p>如果直接打印location，<strong>可获取到地址栏信息</strong>（当前页面的完整路径）。如果直接将location修改为绝对/相对路径，则页面会自动跳转到该路径，并自动生成历史纪录 1. assign() 用来跳转到其他页面，作用与直接修改location一样 1. reload() 刷新当前页面 1. reload(true) 强制清空缓存刷新页面 1. replace() 用新页面替换当前页面，不会生成历史纪录，<strong>不能回退</strong></p>
<h2 id="31-定时器"><a href="#31-定时器" class="headerlink" title="31.定时器"></a>31.定时器</h2><h3 id="①定时调用"><a href="#①定时调用" class="headerlink" title="①定时调用"></a>①定时调用</h3><p>如果希望一段程序可以<strong>每间隔一段时间执行一次</strong>可以使用定时调用</p>
<h4 id="㈠-window-setInterval"><a href="#㈠-window-setInterval" class="headerlink" title="㈠(window).setInterval()"></a>㈠(window).setInterval()</h4><p>可将一个函数每隔一段时间执行一次 <strong>参数：</strong> 1. 回调函数，该函数会每隔一段时间被调用一次 1. 每次调用间隔的时间，单位是毫秒 <strong>返回值：</strong> 返回一个Number类型的数据，这个数字用来作为定时器的唯一标识，主要用来取消定时器</p>
<h4 id="㈡clearInterval"><a href="#㈡clearInterval" class="headerlink" title="㈡clearInterval()"></a>㈡clearInterval()</h4><p>可以用来关闭一个定时器。 方法中需要一个<strong>定时器标识</strong>作为参数，这样将关闭标识对相应的定时器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timer=<span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//定时器执行代码</span></span><br><span class="line">    <span class="keyword">if</span>(定时器关闭条件)<span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;,定时时间);</span><br></pre></td></tr></table></figure>
<h3 id="②实验：切换图片"><a href="#②实验：切换图片" class="headerlink" title="②实验：切换图片"></a>②实验：切换图片</h3><p><strong>注意不要开启多个定时器→每开一个就关上一个</strong></p>
<h3 id="③实验：解决键控移动div时卡顿的问题"><a href="#③实验：解决键控移动div时卡顿的问题" class="headerlink" title="③实验：解决键控移动div时卡顿的问题"></a>③实验：解决键控移动div时卡顿的问题</h3><p><strong>分离方向与速度的控制</strong> <strong>代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            width:100px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.onload&#x3D;function()&#123;</span><br><span class="line">            var speed&#x3D;10;</span><br><span class="line">            var direction&#x3D;0;</span><br><span class="line">            var div&#x3D;document.getElementsByTagName(&quot;div&quot;)[0];</span><br><span class="line">            var timer&#x3D;setInterval(function()&#123;</span><br><span class="line">                switch (direction)</span><br><span class="line">                &#123;</span><br><span class="line">                    case 37:div.style.left&#x3D;div.offsetLeft-speed+&quot;px&quot;;break;</span><br><span class="line">                    case 38:div.style.top&#x3D;div.offsetTop-speed+&quot;px&quot;;break;</span><br><span class="line">                    case 39:div.style.left&#x3D;div.offsetLeft+speed+&quot;px&quot;;break;</span><br><span class="line">                    case 40:div.style.top&#x3D;div.offsetTop+speed+&quot;px&quot;;break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,30);</span><br><span class="line">            document.onkeydown&#x3D;function (event) &#123;</span><br><span class="line">                event&#x3D;eventwindow.event;</span><br><span class="line">                if(event.ctrlKey)speed&#x3D;100;</span><br><span class="line">                else speed&#x3D;10;</span><br><span class="line">                direction&#x3D;event.keyCode;</span><br><span class="line">                &#125;;</span><br><span class="line">            document.onkeyup&#x3D;function()&#123;</span><br><span class="line">                direction&#x3D;0;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;title&gt;keydownTest&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="④延时调用"><a href="#④延时调用" class="headerlink" title="④延时调用"></a>④延时调用</h3><p><strong>setTimeOut()</strong>：延时调用一个函数<strong>不马上执行</strong>，而是隔一段时间执行，且<strong>只执行一次</strong>，用法与setInteral()相似 <strong>clearTimeOut()</strong>:关闭一个延时调用 _延时调用和定时调用实际上是可以相互代替的_，在开发过程中可根据自己的需要去选择。</p>
<h3 id="⑤实验：定时器的应用——元素移动方法"><a href="#⑤实验：定时器的应用——元素移动方法" class="headerlink" title="⑤实验：定时器的应用——元素移动方法"></a>⑤实验：定时器的应用——元素移动方法</h3><p><strong>tools.js:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">obj,name</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//非IE8以下浏览器获取目前CSS</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.getComputedStyle)<span class="keyword">return</span> getComputedStyle(obj,<span class="literal">null</span>)[name];</span><br><span class="line">    <span class="comment">//IE8以下浏览器获取目前CSS</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> obj.currentStyle[name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*obj→控制对象</span></span><br><span class="line"><span class="comment">attr→控制属性</span></span><br><span class="line"><span class="comment">target→终点位置</span></span><br><span class="line"><span class="comment">→到达终点后的回调函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">obj,attr,speed,target,callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//防止多次点击设置多个定时器，所以每次点击移除上一个定时器</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line"></span><br><span class="line">    obj.timer=<span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> current=getStyle(obj,attr);</span><br><span class="line">        <span class="comment">//未设置属性初值时，ie将返回auto，其不可参与运算，当这种情况发生时，将其属性赋值为0</span></span><br><span class="line">        current==<span class="string">&quot;auto&quot;</span>?current=<span class="number">0</span>:current=<span class="built_in">parseInt</span>(current);</span><br><span class="line">        <span class="comment">//判断速度方向</span></span><br><span class="line">        <span class="comment">//bug：临时变量未消除？？</span></span><br><span class="line">        <span class="keyword">if</span>(current&gt;target&amp;&amp;speed&gt;<span class="number">0</span>)speed=-speed;</span><br><span class="line">        <span class="keyword">var</span> newValue=current+speed;</span><br><span class="line">        <span class="comment">//防止速度非终点位置的整数倍造成的停止位置偏移，强制将最后的位置赋值为终点位置</span></span><br><span class="line">        <span class="keyword">if</span>((speed&gt;<span class="number">0</span>&amp;&amp;newValue&gt;target)(speed&lt;<span class="number">0</span>&amp;&amp;newValue&lt;target))newValue=target;</span><br><span class="line">        <span class="comment">//改变对象属性</span></span><br><span class="line">        obj.style[attr]=newValue+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">        <span class="comment">//判断对象是否到达终点</span></span><br><span class="line">        <span class="keyword">if</span>(newValue==target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//到达终点后清除定时器，触发回调函数</span></span><br><span class="line">            <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">            callback&amp;&amp;callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;moveFunc&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body&#123;</span><br><span class="line">            margin-top: <span class="number">0</span>px;</span><br><span class="line">            margin-left: <span class="number">0</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        #box1&#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height:<span class="number">100</span>px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line">        #box2&#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height:<span class="number">100</span>px;</span><br><span class="line">            top:<span class="number">200</span>px;</span><br><span class="line">            background-color: yellow;</span><br><span class="line">            position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line">        #line&#123;</span><br><span class="line">            width: <span class="number">0</span>px;</span><br><span class="line">            height: <span class="number">1000</span>px;</span><br><span class="line">            border-right:<span class="number">1</span>px black solid;</span><br><span class="line">            left: <span class="number">1000</span>px;</span><br><span class="line">            top:<span class="number">0</span>px;</span><br><span class="line">            position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line">        #control&#123;</span><br><span class="line">            margin:<span class="number">10</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;tools.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> box1=<span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> box2=<span class="built_in">document</span>.getElementById(<span class="string">&quot;box2&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> btn1=<span class="built_in">document</span>.getElementById(<span class="string">&quot;btn1&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> btn2=<span class="built_in">document</span>.getElementById(<span class="string">&quot;btn2&quot;</span>);</span><br><span class="line">            btn1.onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">                move(box1,<span class="string">&quot;left&quot;</span>,<span class="number">10</span>,<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            btn2.onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                move(box2,<span class="string">&quot;width&quot;</span>,<span class="number">10</span>,<span class="number">500</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    move(box2,<span class="string">&quot;height&quot;</span>,<span class="number">10</span>,<span class="number">500</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                        move(box2,<span class="string">&quot;width&quot;</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                            move(box2,<span class="string">&quot;height&quot;</span>,<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">/*btn2.onclick=function () &#123;</span></span><br><span class="line"><span class="comment">                move(box2,&quot;width&quot;,10,10);</span></span><br><span class="line"><span class="comment">            &#125;;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;control&quot;</span>&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;btn1&quot;</span>&gt;box1移动&lt;/button&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;btn2&quot;</span>&gt;box2移动&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;box1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;box2&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;line&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="⑥实验——轮播页面"><a href="#⑥实验——轮播页面" class="headerlink" title="⑥实验——轮播页面"></a>⑥实验——轮播页面</h3><p><strong>代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Cycle Image Frame&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        *&#123;</span><br><span class="line">            margin:<span class="number">0</span>;</span><br><span class="line">            padding:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        #outer&#123;</span><br><span class="line">            height: <span class="number">470</span>px;</span><br><span class="line">            <span class="comment">/*宽度值为图片宽度+外边距margin10*2=610px*/</span></span><br><span class="line">            width: <span class="number">610</span>px;</span><br><span class="line">            margin:<span class="number">50</span>px auto;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">            padding:<span class="number">10</span>px <span class="number">0</span>;</span><br><span class="line">            position: relative;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        #imgList&#123;</span><br><span class="line">            list-style: none;</span><br><span class="line">            position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #imgList li&#123;</span><br><span class="line">            float:left;</span><br><span class="line">            margin: <span class="number">0</span> <span class="number">10</span>px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #nav&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            bottom:<span class="number">20</span>px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #nav a&#123;</span><br><span class="line">            float:left;</span><br><span class="line">            width: <span class="number">10</span>px;</span><br><span class="line">            height: <span class="number">10</span>px;</span><br><span class="line">            background-color: black;</span><br><span class="line">            margin: <span class="number">0</span> <span class="number">5</span>px;</span><br><span class="line">            opacity: <span class="number">0.5</span>;</span><br><span class="line">            <span class="comment">/*IE8透明*/</span></span><br><span class="line">            filter:alpha(opacity=<span class="number">50</span>);</span><br><span class="line">            border-radius: <span class="number">5</span>px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #nav a:hover&#123;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .borderbtn&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            width: <span class="number">20</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            opacity: <span class="number">0.5</span>;</span><br><span class="line">            filter:alpha(opacity=<span class="number">50</span>);</span><br><span class="line">            background-color: black;</span><br><span class="line">            color: aliceblue;</span><br><span class="line">            vertical-align: center;</span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: <span class="number">100</span>px;</span><br><span class="line">            top:<span class="number">215</span>px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .borderbtn:hover&#123;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">            color: black;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #rbtn&#123;</span><br><span class="line">            right: <span class="number">0</span>px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;tools.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> timer;</span><br><span class="line">            <span class="comment">//根据图片数量自动设置图片列的宽度</span></span><br><span class="line">            <span class="keyword">var</span> imgList=<span class="built_in">document</span>.getElementById(<span class="string">&quot;imgList&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> imgArr=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">            imgList.style.width=<span class="number">610</span>*imgArr.length+<span class="string">&quot;px&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//自动居中跳转按钮</span></span><br><span class="line">            <span class="keyword">var</span> nav=<span class="built_in">document</span>.getElementById(<span class="string">&quot;nav&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> outer=<span class="built_in">document</span>.getElementById(<span class="string">&quot;outer&quot;</span>);</span><br><span class="line">            nav.style.left=(outer.offsetWidth-nav.offsetWidth)/<span class="number">2</span>+<span class="string">&quot;px&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为目前显示的图片按钮更改颜色</span></span><br><span class="line">            <span class="keyword">var</span> allA=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> index=<span class="number">0</span>;</span><br><span class="line">            allA[index].style.backgroundColor=<span class="string">&quot;aliceblue&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> lbtn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;lbtn&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> rbtn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;rbtn&quot;</span>);</span><br><span class="line">            lbtn.onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                index==<span class="number">0</span>?index=allA.length-<span class="number">1</span>:index--;</span><br><span class="line">                changeImg();</span><br><span class="line">            &#125;</span><br><span class="line">            rbtn.onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                index==allA.length-<span class="number">1</span>?index=<span class="number">0</span>:index++;</span><br><span class="line">                changeImg();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;allA.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                allA[i].index=i;</span><br><span class="line">                allA[i].onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    index=<span class="built_in">this</span>.index;</span><br><span class="line">                    changeImg();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">changeImg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//清除自动定时器</span></span><br><span class="line">                <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">                <span class="comment">//imgList.style.left=-610*index+&quot;px&quot;</span></span><br><span class="line">                <span class="keyword">var</span> oldindex=<span class="built_in">parseInt</span>(imgList.style.left)/-<span class="number">610</span>;</span><br><span class="line">                <span class="keyword">var</span> speed=<span class="number">50</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(oldindex-index)&gt;<span class="number">1</span>)speed=<span class="number">80</span>;</span><br><span class="line">                move(imgList,<span class="string">&quot;left&quot;</span>,speed,-<span class="number">610</span>*index,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="comment">//动画执行完毕，开启自动切换</span></span><br><span class="line">                    autoChange();</span><br><span class="line">                &#125;);</span><br><span class="line">                setAColor();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            autoChange();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">setAColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//判断当前图片是否为最后一张图片</span></span><br><span class="line">                <span class="function"><span class="title">if</span>(<span class="params">index&gt;=imgArr.length-<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">                    index=<span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//通过css将图片设置到第一张</span></span><br><span class="line">                    imgList.style.left=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//去除内联样式，式样式表中的鼠标悬浮变色样式实现</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;allA.length;i++)allA[i].style.backgroundColor=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                allA[index].style.backgroundColor=<span class="string">&quot;aliceblue&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">autoChange</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                timer=<span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    index++;</span><br><span class="line">                    index%=imgArr.length;</span><br><span class="line">                    move(imgList,<span class="string">&quot;left&quot;</span>,<span class="number">40</span>,-<span class="number">610</span>*index,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                        setAColor();</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;,<span class="number">3000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">    &lt;ul id=<span class="string">&quot;imgList&quot;</span>&gt;</span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.z4a.net/images/2019/05/13/157ca6b4974b78c89.jpg&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.z4a.net/images/2019/05/13/2840b21773dc852f3.jpg&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.z4a.net/images/2019/05/13/3197936dabdc3025c.jpg&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.z4a.net/images/2019/05/13/4bef50cec6ab80f08.jpg&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.z4a.net/images/2019/05/13/5bbaed807aafe43a4.jpg&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.z4a.net/images/2019/05/13/6016ef4e19fed0ded.jpg&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.z4a.net/images/2019/05/13/761ccf35b9ff73af5.jpg&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.z4a.net/images/2019/05/13/157ca6b4974b78c89.jpg&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;nav&quot;</span>&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;lbtn&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;borderbtn&quot;</span>&gt;&lt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;rbtn&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;borderbtn&quot;</span>&gt;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="32-类的操作"><a href="#32-类的操作" class="headerlink" title="32.类的操作"></a>32.类的操作</h2><p>通过Style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面，这样执行的性能较差，且这种形式要修改多个样式时也不太方便</p>
<blockquote>
<p>可以通过修改元素的class属性来间接的修改多个央视，这样浏览器只需渲染页面一次，性能更好，并且这种方式可以使表现和行为进一步分离</p>
</blockquote>
<h3 id="①自建方法"><a href="#①自建方法" class="headerlink" title="①自建方法"></a>①自建方法</h3><p><strong>统一参数：</strong> 1. obj→操作对象 1. cn→类名</p>
<h4 id="㈠-判断类方法"><a href="#㈠-判断类方法" class="headerlink" title="㈠ 判断类方法"></a>㈠ 判断类方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasClass</span>(<span class="params">obj,cn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\b&quot;</span>+cn+<span class="string">&quot;\\b&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> reg.test(obj.className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="㈡合并类方法"><a href="#㈡合并类方法" class="headerlink" title="㈡合并类方法"></a>㈡合并类方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">obj,cn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!hasClass(obj,cn))obj.className+=<span class="string">&quot;&quot;</span>+cn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="㈢删除类方法"><a href="#㈢删除类方法" class="headerlink" title="㈢删除类方法"></a>㈢删除类方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeClass</span>(<span class="params">obj,cn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\b&quot;</span>+cn+<span class="string">&quot;\\b&quot;</span>);</span><br><span class="line">    obj.className=obj.class.replace(reg,<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="㈣切换类方法"><a href="#㈣切换类方法" class="headerlink" title="㈣切换类方法"></a>㈣切换类方法</h4><ul>
<li>若元素中具有该类，则删除</li>
<li>若元素中没有该类，则添加</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleClass</span>(<span class="params">obj,cn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hasClass(obj,cn))removeClass(obj,cn);</span><br><span class="line">    <span class="keyword">else</span> addClass(obj,cn);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="②实验——三级菜单"><a href="#②实验——三级菜单" class="headerlink" title="②实验——三级菜单"></a>②实验——三级菜单</h3><p><strong>当div中有collapsed这个类时，div就是折叠状态，没有就是展开状态</strong></p>
<h2 id="33-JSON"><a href="#33-JSON" class="headerlink" title="33.JSON"></a>33.JSON</h2><ul>
<li>js中的对象只有js自己认识，其他语言都不认识</li>
<li>JSON就是一个特殊格式个字符串，这个字符串可以被任意语言所识别，并且可以转换为任意语言中的对象，<strong>JSON在开发中主要用来数据交互</strong></li>
<li>全名JavaScript Object Notation == JS对象方法</li>
<li>JSON与js对象的格式一样，<strong>只不过JSON字符串中的属性名必须加双引号</strong>，其他的与js语法一致</li>
</ul>
<h3 id="①分类"><a href="#①分类" class="headerlink" title="①分类"></a>①分类</h3><ol>
<li>对象：{}</li>
<li>数组：[]</li>
</ol>
<h3 id="②JSON中允许的数据类型"><a href="#②JSON中允许的数据类型" class="headerlink" title="②JSON中允许的数据类型"></a>②JSON中允许的数据类型</h3><ol>
<li>字符串</li>
<li>数值</li>
<li>布尔值</li>
<li>null</li>
<li>对象</li>
<li>数组</li>
</ol>
<p>（没有函数!!)</p>
<h3 id="③将JSON字符串转换为JS对象"><a href="#③将JSON字符串转换为JS对象" class="headerlink" title="③将JSON字符串转换为JS对象"></a>③将JSON字符串转换为JS对象</h3><p>在js中为我们提供了一个工具类，就叫JSON，该对象可将JSON转换为js对象，也可将js对象转换为JSON字符串</p>
<h4 id="㈠JSON-parse"><a href="#㈠JSON-parse" class="headerlink" title="㈠JSON.parse()"></a>㈠JSON.parse()</h4><ul>
<li>它可将JSON字符串转换为js对象</li>
<li>它需要一个JSON字符串作为参数，会将该字符串转换为js对象返回</li>
</ul>
<h4 id="㈡JSON-stringify"><a href="#㈡JSON-stringify" class="headerlink" title="㈡JSON.stringify()"></a>㈡JSON.stringify()</h4><ul>
<li>它可将一个js对象转换为JSON字符串</li>
<li>它需要一个js对象作为参数，会返回一个JSON字符串</li>
</ul>
<h3 id="JSON对象在IE7及以下浏览器中不支持，会报错"><a href="#JSON对象在IE7及以下浏览器中不支持，会报错" class="headerlink" title="JSON对象在IE7及以下浏览器中不支持，会报错"></a>JSON对象在IE7及以下浏览器中不支持，会报错</h3><blockquote>
<p>eval()</p>
</blockquote>
<ul>
<li>这个函数可以用来执行一段字符串形式的js代码，并将结果返回。</li>
<li><p>如果使用eval()执行的字符串中含有{}，它会将{}当成代码块，若不需要将其当成代码块解析，则需在字符串前后各加一个括号</p>
<blockquote>
<p>var obj=eval(“(“+JSONstr+”)”);</p>
</blockquote>
</li>
<li><p><strong>这个函数的功能很强大，但在开发中尽量不要使用，首先它的执行性能比较差，还有安全隐患！</strong> <strong>综上，若需兼容IE7及一下浏览器的JSON操作，可在网页源代码中引入JSON对象的定义文件</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
        <category>JavaScript</category>
        <category>Web</category>
        <category>前堂</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】泛谈“面向对象”</title>
    <url>/2018/12/31/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91%E6%B3%9B%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>不知不觉18年就过完了，转眼间又到了考试季，各位小伙伴们都复习的怎么样啊？ <a href="http://upane.cn/wp-content/uploads/2018/04/35.png"><img src="http://upane.cn/wp-content/uploads/2018/04/35.png" alt=""></a><br>好吧今天我们不谈考试，就坐下来好好说说这个“面向对象”的概念，有些同学可能一学期下来也搞不清这个到底有什么用、怎么用。这次就结合Java，当然也不只有Java，来说说面向对象的语言特性，彻底缕清这个概念。<br><a id="more"></a></p>
<h2 id="①基础"><a href="#①基础" class="headerlink" title="①基础"></a>①基础</h2><p>有些东西需要你在本次学习之前彻底搞清，以便下面的学习得更轻松，这里讲一下几个概念，如果会的话可以跳过。</p>
<h3 id="㈠声明和实例化"><a href="#㈠声明和实例化" class="headerlink" title="㈠声明和实例化"></a>㈠声明和实例化</h3><p>有些同学读课本代码时可能经常发现这样一句话： <strong>XXX xxx=new XXX();</strong> 大家都知道，这是<strong>创建对象的过程</strong>，其中XXX是类名，xxx是新创建的对象名，但是这具体是什么意思呢？ 其实，这句话干了两件事，分别是： <strong>①XXX xxx； ②xxx=new XXX();</strong> 其中第一步是<strong>声明对象</strong>，第二步是<strong>实例化对象</strong> 通俗点讲，比如这是一个做泥塑的过程，声明对象就是向电脑要了一堆泥，而实例化就是把这堆泥捏成了泥塑。 那么，具体要怎么把泥捏成泥塑呢？这就需要调用类的<strong>构造函数</strong>了，所以说，第二步后面的XXX()与前面声明的类XXX并没有必然的联系，它只是个构造函数，在特定情况下也可以写其他类的构造函数，这个我们后面再讲。 有点晕？没关系我们看一个例子： 建立一个名为“Student”的类，类包含字段“班级”（theClass）和“学号”（schoolNum）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String theClass;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> schoolNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们分别对其声明并实例化，然后调试： <a href="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-30-57.png"><img src="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-30-57.png" alt=""></a> 可以看到，最开始没有student这个对象，我们对其声明后就有了这个对象，但是值为null，空，但是我们知道Student类是有结构的（两个字段），只是null的话连结构都没有。 然后我们继续运行，让它实例化。 <a href="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-34-19.png"><img src="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-34-19.png" alt=""></a> 实例化之后student的值就变成了{Student}，我们打开变量监视器可以看到其中的结构已经就绪。 <a href="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-35-08.png"><img src="http://upane.cn/wp-content/uploads/2018/12/devenv_2018-12-31_12-35-08.png" alt=""></a> 所以，如果你的编译器报了空指针错误（nullpointer），那多半就是没实例化导致的。这样是不是就多少明白些这两步的关系了？ <strong>总结：声明就是按照类中的结构大小分配存储空间，并没有真正地构造对象，只有使用了构造函数将其实例化，一个完整的对象框架才会被真正建立起来。</strong></p>
<h3 id="㈡构造函数"><a href="#㈡构造函数" class="headerlink" title="㈡构造函数"></a>㈡构造函数</h3><p>刚刚讲实例化的时候我们就接触过构造函数了，并且知道它的作用是构建对象框架。那么它和普通函数还有什么区别吗？是不是随便一个函数都可以作为构造函数呢？ 首先我们要明确的就是，<strong>不管是什么类都默认有构造函数</strong>，只是有的类不能被实例化（比如抽象类），并且它是<strong>默认存在的</strong>，即你不定义它，它也会自动生成，只是除了实例化对象之外没有其他操作了而已。 然后，我们再讲一下它和普通函数的区别： 1. 它只能在对象被实例化的时候调用，且调用时必须加关键字<strong>new</strong> 2. 构造函数的名字<strong>必须与类名相同</strong> 3. 构造函数<strong>默认且必须返回值为空</strong>，因为这个规则，构造函数就可以省略返回类型而直接写函数名 稍微解释一下，以构造函数的用途思考这些规则其实都能想通，构造函数只为实例化对象而生，肯定只能在实例化的时候调用，并且肯定与类名相同，要不谁知道是哪个类啊？“实例化”本身就是个动作，这个动作注定它不能返回什么值，而是指使计算机去做出什么，所以肯定返回值是空。最后需要注意的是构造函数的访问修饰符一般是public，否则就无法在其他类里调用其实例化了。</p>
<h2 id="②正篇"><a href="#②正篇" class="headerlink" title="②正篇"></a>②正篇</h2><p>说了这么多终于进入正题了，下面我们就好好谈谈这个面向对象到底是什么，有什么好处，为什么这么多语言都用这个概念，具体该怎么用。</p>
<h3 id="㈠对象是什么？"><a href="#㈠对象是什么？" class="headerlink" title="㈠对象是什么？"></a>㈠对象是什么？</h3><p>说白了，它就是个东西（<strong>object</strong>），你管它什么东西（<strong>object</strong>），它就是个东西（<strong>object</strong>）。 东西是什么？什么都有可能，<strong>只要数据能描述这个东西，那它就能成为对象。</strong> 注意我把这个单词<strong>object</strong>加粗了，这是英文原版的“对象”，如果不了解这个单词希望去查一下词典，看看其名词形式下都有什么释义，这样你就会对“对象”这个概念有所体会。 我觉得其实叫“面向东西”更能表达其精髓，但是这么翻译太难听了，还是面向对象吧。</p>
<h3 id="㈡那么面向东西，呃不面向对象有什么用？"><a href="#㈡那么面向东西，呃不面向对象有什么用？" class="headerlink" title="㈡那么面向东西，呃不面向对象有什么用？"></a>㈡那么面向东西，呃不面向对象有什么用？</h3><h4 id="⑴条理化的数据操作"><a href="#⑴条理化的数据操作" class="headerlink" title="⑴条理化的数据操作"></a>⑴条理化的数据操作</h4><p>我们编程为了什么？简化用户操作？优化用户体验？这不能，都太表面了，这往白了说，就是<strong>处理数据</strong>！ 处理什么数据？肯定不是一点数据，如果数据少那人算就可以了，根本用不着专门写个程序，所以我们处理的是大量的数据！至少量大到需要专门写个程序分析才行。 为了给大家一个客观的感受，放出来前几天扒的QQ音乐网页版搜索返回值： <a href="http://upane.cn/wp-content/uploads/2018/12/notepad_2018-12-31_13-11-15.png"><img src="http://upane.cn/wp-content/uploads/2018/12/notepad_2018-12-31_13-11-15-1024x493.png" alt=""></a> 以上是搜索了“测试”这两个字的返回结果，为了保证可读性我进行了一点优化，这里每一行都是一条数据对象，也就是一个音乐。。的东西，只不过不是Java的对象，是JavaScript的对象，每行长度在880字到1024字之间，其中每条数据对象中都有非常多的字段，要想顺利承接这些字段，我需要整理它的结构。通过分析，得到每条数据的结构如下： <a href="http://upane.cn/wp-content/uploads/2018/12/notepad_2018-12-31_13-16-33.png"><img src="http://upane.cn/wp-content/uploads/2018/12/notepad_2018-12-31_13-16-33-1024x493.png" alt=""></a> 其中每个大括号里面又是这个类的子类。可以看出，其中数据真的非常多，但是却十分条理，分门别类地存储在相应的字段中，找起来也十分方便。 返回我们之前的话题中，程序员需要写图一中的每一条数据吗？并不是，程序员写的只是图二中的结构（类），结构写完，数据就自动根据位置“穿”进去了，强迫症福利，是不是？</p>
<h4 id="⑵模块化，易于维护"><a href="#⑵模块化，易于维护" class="headerlink" title="⑵模块化，易于维护"></a>⑵模块化，易于维护</h4><p>刚刚讲的数据操作其实用C语言的结构体也可以做到，但是C语言不是面向对象的，所以要说起面向对象真正的优势，还在于模块化上。 那么类比结构体多的不就是能在里面写函数吗？对，<strong>所以我们不需要把函数“随用随写”，而是把属于这个类的函数专门写在这个类里，用的时候直接调用，这就是模块化了</strong>。哪里好呢？比如我A类的函数写好，调用之发现运转正常，这个类就可以不管了，B类调用的时候出现问题那肯定是B类的故障而不是A类，一个模块就干一个事。为了让程序员方便知道一个对象中有哪些数据可以动，哪些不能动，还引入了封装的概念，这个我们在下面也会提到。 另外也为程序的拓展带来了方便，copy别人的代码更爽了（逃</p>
<h4 id="⑶灵活多变，省时省力"><a href="#⑶灵活多变，省时省力" class="headerlink" title="⑶灵活多变，省时省力"></a>⑶灵活多变，省时省力</h4><p>通过继承一个类，我们可以快速得到很多有共同特性的派生类，还可以进行重写（override）区分派生类中的特性。</p>
<h3 id="㈢那该怎么用？"><a href="#㈢那该怎么用？" class="headerlink" title="㈢那该怎么用？"></a>㈢那该怎么用？</h3><p>好了，到这里就是我们这个文章的核心了，我的真正目标是教会大家明确对象这个概念，并且能用这个概念写出<strong>条理清楚、整洁的代码</strong></p>
<h4 id="⑴重中之重，先别急着写代码，想想咱要干嘛！"><a href="#⑴重中之重，先别急着写代码，想想咱要干嘛！" class="headerlink" title="⑴重中之重，先别急着写代码，想想咱要干嘛！"></a>⑴重中之重，先别急着写代码，想想咱要干嘛！</h4><p>要求学生的平均分还是算正方形的面积？一共需要几个类？哪个类是负责统筹主逻辑的？哪个类是负责记载数据的？算平均分的话需要哪些数据？数据类型应该是什么？…… 这些都是必须要考虑的问题，特别是今后要写较大项目的时候，不管是和别人一起写还是自己独干，千万别图一时手快，否则写着写着突然发现结构不对进行不下去了，要全部重构的时候就等着哭咯！</p>
<h4 id="⑵明确结构"><a href="#⑵明确结构" class="headerlink" title="⑵明确结构"></a>⑵明确结构</h4><p>这个结构不是指的上面说的具体结构，而是类的结构，总体来讲类的结构分为以下四个： 1. 字段 字段就是直接在类里面定义的<strong>变量</strong>，该变量可以在类里共享，是否与外界共享要看访问修饰符。 2. 访问器 访问器就是get/set，用来设置字段的，<strong>可以在一定程度上对读/取进行限制，以达到封装的目的</strong>，值得一提的是，访问器本质上就是个普通函数，只是我们为这类普通函数起了一个共有的名字而已，但是我们完全可以把它当作一个普通函数来记忆。 3. 方法 方法就是类中的<strong>函数</strong>。 4. 内部类 内部类不太常见，但也是类中的结构之一，<strong>注意内部类可以读取外部类的字段，也可以调用外部类的函数。</strong></p>
<h4 id="⑶封装"><a href="#⑶封装" class="headerlink" title="⑶封装"></a>⑶封装</h4><p>了解了结构，我们就开始封装类了。我们都知道创立了类、构建了结构肯定是要对数据进行存取，定义好哪些可以存，哪些可以取，这样不管是对别人还是对自己都能起到良好的导航效果，我们的目标就是只暴露需要的，不需要的统统隐藏。 那我们就需要了解访问修饰符了： 访问修饰符分为<strong>访问符</strong>和<strong>修饰符</strong>，我们先从比较好说的访问符开始：</p>
<h6 id="访问符，顾名思义，就是用来修饰访问性的-下面我们就来比较一下Java的四个访问符（没有也算一个）标识的可访问性："><a href="#访问符，顾名思义，就是用来修饰访问性的-下面我们就来比较一下Java的四个访问符（没有也算一个）标识的可访问性：" class="headerlink" title="访问符，顾名思义，就是用来修饰访问性的,下面我们就来比较一下Java的四个访问符（没有也算一个）标识的可访问性："></a>访问符，顾名思义，就是用来修饰访问性的,下面我们就来比较一下Java的四个访问符（没有也算一个）标识的可访问性：</h6><p>同一个类</p>
<p>同一个包</p>
<p>不同包的子类</p>
<p>不同包的非子类</p>
<p>private</p>
<p>√</p>
<p>没有访问符</p>
<p>√</p>
<p>√</p>
<p>protected</p>
<p>√</p>
<p>√</p>
<p>√</p>
<p>public</p>
<p>√</p>
<p>√</p>
<p>√</p>
<p>√</p>
<h6 id="然后我们再来讲讲修饰符，修饰符的目的就是再对被修饰的语句进行进一步的解释，赋予其更多功能："><a href="#然后我们再来讲讲修饰符，修饰符的目的就是再对被修饰的语句进行进一步的解释，赋予其更多功能：" class="headerlink" title="然后我们再来讲讲修饰符，修饰符的目的就是再对被修饰的语句进行进一步的解释，赋予其更多功能："></a>然后我们再来讲讲修饰符，修饰符的目的就是再对被修饰的语句进行进一步的解释，赋予其更多功能：</h6><p>修饰符</p>
<p>功能</p>
<p>abstract</p>
<p>抽象语句，用于类和方法的修饰，具体下节讲</p>
<p>final</p>
<p>表示“固定”、不可变，用在字段的定义中就代表常量，用在类的定义中就代表该类不可被继承</p>
<p>static</p>
<p>静态语句,可修饰类、字段、方法，具体下节讲</p>
<p>了解了访问修饰符我们才能真正开始封装，那么，具体应该怎样封装呢？下面有几种常用封装手段： <strong>封装字段的手段：（默认以全部使用private封装）</strong></p>
<p>封装手段</p>
<p>写入</p>
<p>读出</p>
<p>优势</p>
<p>劣势</p>
<p>访问符public或者不写访问符)</p>
<p>√</p>
<p>√</p>
<p>方便，只改修饰符就成</p>
<p>不受控制的修改，暴露程度太高</p>
<p>利用构造函数</p>
<p>√</p>
<p>×</p>
<p>实例化对象时即进行赋值，大大减少代码量</p>
<p>如不通过其他手段则写入的值无法读出</p>
<p>设置访问器</p>
<p>√</p>
<p>√</p>
<p>在变量被修改前可以进行筛选等高级控制</p>
<p>麻烦，需要专门另写方法</p>
<p><strong>封装方法则一律使用修饰符。</strong> 可根据需要灵活选择解决方案，也可同时使用多种手段。</p>
<h4 id="⑷掌握类之间的关系：继承与多态"><a href="#⑷掌握类之间的关系：继承与多态" class="headerlink" title="⑷掌握类之间的关系：继承与多态"></a>⑷掌握类之间的关系：继承与多态</h4><p>这是最后一节了，学会了就胜利了，加油！</p>
<h5 id="1-特殊情况：静态"><a href="#1-特殊情况：静态" class="headerlink" title="1.特殊情况：静态"></a>1.特殊情况：静态</h5><p>在学习类之间的关系之前我们要先解决上一节遗留下来的一个问题：<strong>静态关系</strong>。 之所以不在上节讲是因为其与封装关系不大，但是与这一节的关系也不大，单独拿出来内容又太少，所以只好放在这里了，望见谅。 那么静态到底是什么？ 我们知道类中的结构和方法是无法直接使用的，必须通过实例化为对象再使用，<strong>可是有些方法/字段我们只使用一次，或者说没有必要单独成为对象，我们就可以把它写为静态方法/字段</strong>，这样一来，在调用时不需要实例化，直接类名.方法/字段就可以使用它们了。 <strong>注意静态方法有个坑，就是静态方法只能引用静态方法，不能引用非静态方法，但是反过来——非静态方法可以引用所有方法</strong> 值得一提的是，类也可以被静态修饰符修饰，那样就是静态类，静态类必须是内部类。正常情况下我们必须实例化外部类才能进一步实例化内部类，但是静态类可以允许我们直接实例化某个内部类，当然与普通类相比还有其他微小的差别，若感兴趣可以去百度一下，这里就不展开讲了。</p>
<h5 id="2-继承（相同）"><a href="#2-继承（相同）" class="headerlink" title="2.继承（相同）"></a>2.继承（相同）</h5><p>我这里加了个括号，写了个相同，意思是继承的主要目标是操作类与类之间相同的地方，<strong>A类继承B类，将得到B类所有已定义的结构，包括字段、访问器、方法、内部类</strong> 而这一切，只需要你在定义的类名后加个<strong>extend</strong>即可。 我们定义了山羊类，可以很轻松地继承出绵羊类。当然你也可以从羊类继承出山羊类和绵羊类，但是两者差异不大，绵羊不就是多点毛么，直接从山羊类继承出来也未尝不可。</p>
<h5 id="3-多态（差异）"><a href="#3-多态（差异）" class="headerlink" title="3.多态（差异）"></a>3.多态（差异）</h5><p>多态我们主讲差异，刚刚我们讲了继承，讲了A类能从B类继承所有内容，但是如果我想突出A类与B类的不同呢？ 比如，同是大学生，但是少林寺章丘分寺的大学生武术不及格就不能毕业，那么关于毕业这个算法，从大学生类继承出来的少林寺章丘分寺的大学生类肯定不能相同，为了实现这个功能，我们引入重写（override）的概念，注意这不是重构（overload）哈，别搞混了，忘了重构的自己去查，这里不讲了。 重写就是直接把要重写的函数在子类再写一遍，内容和父类不同就是了。这个很好理解，记得不仅<strong>方法可以重写，字段也可以重写</strong>。 好了重写讲完了，下面我们来讲讲所谓真正的多态： 还是刚刚的大学生类，但是我们给他多一个函数，让他说自己会不会打武术：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> string theClass;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> schoolNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isMartial</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不会打武术&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再继承出一个少林寺章丘分寺的大学生类，重写会不会打武术的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QSStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isMartial</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;作为少林寺章丘分寺的学生，像你这种问题，我就三个字！打!....扰了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点来了，我们这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student=<span class="keyword">new</span> QSStudent();</span><br><span class="line">student.isMartial();</span><br></pre></td></tr></table></figure>
<p>对，你没看错，构造函数和前面声明的类不一样！请问会写出什么？ 答案是：</p>
<blockquote>
<p>作为少林寺章丘分寺的学生，像你这种问题，我就三个字！打!….扰了</p>
</blockquote>
<p>然后我们再做一个实验：实例化一个Student数组，然后分别用Student的构造方法和QSStudent的构造方法为其中的元素实例化，看看有什么效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student[] students=<span class="keyword">new</span> Student[<span class="number">2</span>];</span><br><span class="line">students[<span class="number">0</span>]=<span class="keyword">new</span> Student();</span><br><span class="line">studnets[<span class="number">1</span>]=<span class="keyword">new</span> QSStudent();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;students.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    students[i].isMartial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以编译通过吗？这可是Student类型的数组哦！ 答案是<strong>可以的</strong>！ 输出为</p>
<blockquote>
<p>不会打武术 作为少林寺章丘分寺的学生，像你这种问题，我就三个字！打!….扰了</p>
</blockquote>
<p>好的让我们停一下，捋一下思路：这两次实验正好得到了相反的结果：第一个实验说声明为父类型，却用子类型构造函数实例化，且实例化出的对象使用的是子类的函数，说明实例化出的对象可能是个子类型。第二个实验却表明只能容纳同一种数据类型的数组却好像容纳了两个数据类型。好的我们再看第三个实验： 直接输出student的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student=<span class="keyword">new</span> QSStudent();</span><br><span class="line">System.out.println(student.getClass())</span><br></pre></td></tr></table></figure>
<p>它输出的是</p>
<blockquote>
<p>class QSStudent</p>
</blockquote>
<p>这直接说明了<strong>用什么构造方法，就会出来什么类型的对象，声明的类型可以是其父类型</strong> 那么如果我们使用多态调用了子类型有但父类型没有的函数/字段会怎样呢？这是不可以的，会报错。 那么，这还能算是一个完整的子类型吗？当然不算，<strong>因为它本质上还是父类型！只不过这种父类型中所有的函数/字段都被引向了被构造函数实例化的子类型！ 其实这才是真正意义上的“多态”，即父类型的不定性。</strong> 所以我们可以总结为： <strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</strong> 例二的数组用法是多态最多的表现形式，当然这只是多态的一点皮毛，如果想深入了解可以自行百度，这里仅介绍。</p>
<h5 id="4-抽象类（集成）"><a href="#4-抽象类（集成）" class="headerlink" title="4.抽象类（集成）"></a>4.抽象类（集成）</h5><p>我们刚刚了解了了继承（相同）、多态（差异），经由那两个的基础再升级我们就得到了抽象（集成）。这是个什么意思？ 还记得继承那一节里的绵羊和山羊吗？当时我们说绵羊和山羊的差异不大，所以完全可以图方便从山羊类那里派生出一个绵羊类来，但是实际上山羊和绵羊并不是继承关系，而是并列关系，它们的父类应该都是羊类，如果我们偷懒从山羊类派生出绵羊类，简单使用起来好像没什么问题，但是如果我们想使用多态的知识，即把它们做成一个数组，绵羊就成了山羊，这样显然是不合逻辑的。但是如果我们写了一个羊类，又会有傻瓜队友把它不小心实例化了，这也会造成很大的麻烦，因为它是一个不具体的对象。为了更加明确其中的结构，我们造出一个专门用来集成的类、全职父类，就是抽象类了。 抽象类使用<strong>abstract</strong>修饰，<strong>正常类里面有的东西它也都可以有，只是不能被直接实例化了</strong>，另外抽象类中也可以存在未实现、即没有方法体的方法，这种方法叫抽象方法，也用<strong>abstract</strong>修饰，若一个类派生自抽象类，那么其中的抽象函数必须被实现，否则不能实例化。当然也可以把抽象函数就这么一级一级继承下去，但是除非在哪一级被实现，否则继承类都不能实例化。 这样从某种意义上讲抽象类就是为多态而服务的。</p>
<h2 id="③总结：一个例子"><a href="#③总结：一个例子" class="headerlink" title="③总结：一个例子"></a>③总结：一个例子</h2><p>下面我们用一个例子来简单回顾一下刚才所学的内容： 现在，我们写一个普通大学生类，类中有字段学院（academy）、班级（theClass）、学号（studentNum）和一个报告自己会不会武术的方法isMartial()，<strong>还有一个内部类“Grading”，用来保存学生的成绩</strong>，包含专业课、英语和政治三科：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通高校学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String academy;</span><br><span class="line">    <span class="keyword">public</span> String theClass;</span><br><span class="line">    <span class="keyword">public</span> Grading grading;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> studentNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isMartial</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不会打武术&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通高校成绩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grading</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> specializedCourse;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> english;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> politics;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是少林寺章丘分寺的学生不一样啊！他不会武术毕不了业，所以在其内部类中应添加一个武术成绩，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//少林寺章丘分寺的学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QSStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> QSGrading grading;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isMartial</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;作为少林寺章丘分寺的学生，像你这种问题，我就三个字！打!....扰了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//少林寺章丘分寺的成绩</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QSGrading</span> <span class="keyword">extends</span> <span class="title">Student</span>.<span class="title">Grading</span>//注意这里的内部类继承写法</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> martial_Art;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在main函数中分别实例化，然后为其英语成绩赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student student1=<span class="keyword">new</span> Student();</span><br><span class="line">    Student student2=<span class="keyword">new</span> QSStudent();</span><br><span class="line">    QSStudent student3=<span class="keyword">new</span> QSStudent();</span><br><span class="line"></span><br><span class="line">    student1.grading.english=<span class="number">90</span>;</span><br><span class="line">    student2.grading.english=<span class="number">90</span>;</span><br><span class="line">    student3.grading.english=<span class="number">90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想一想，这样写能编译通过吗？如果不能，应该怎样改呢？（答案在结尾）</p>
<h2 id="④（后记）目前以来遇到的坑"><a href="#④（后记）目前以来遇到的坑" class="headerlink" title="④（后记）目前以来遇到的坑"></a>④（后记）目前以来遇到的坑</h2><p>想了想从信心满满地写了第一个小程序（小时钟）以来已经过去半年了，中间也陆陆续续开了很多坑，更踩了不少雷，从这里总结一下，为大家做一次侦察兵，希望大家在未来的编程工作中少走弯路。</p>
<h4 id="⑴尽量不要在构造函数、main函数以及各种控件的事件处理方法中写很多逻辑！"><a href="#⑴尽量不要在构造函数、main函数以及各种控件的事件处理方法中写很多逻辑！" class="headerlink" title="⑴尽量不要在构造函数、main函数以及各种控件的事件处理方法中写很多逻辑！"></a>⑴尽量不要在构造函数、main函数以及各种控件的事件处理方法中写很多逻辑！</h4><p>注意我这里说的是逻辑而不是函数，函数可以有，但是选择、循环等逻辑能少则少，那逻辑挪到哪去？当然是另建一个专门处理逻辑的函数，然后在这些函数中引用逻辑函数。 比如要制作GUI，很多人一上来就在main函数里duang duang duang把按钮、布局等等控件全初始化，甚至在main函数里给控件加匿名处理方法，搞得全篇就main函数最长，好家伙近一百行。这是万万使不得的！ 正确的处理方式是，写一个初始化控件的函数，再写一个专门给布局加控件的函数，然后在main函数里引用这两个函数。这个在行业里专门有个称呼，叫<strong>“降低耦合度”</strong>，不单是这里，其实所有函数都要尽量减少其功能，让<strong>一个函数只干一件事，各个功能彼此分离</strong>，然后利用其互相调用完成想要的功能。不要一次制作一整个机械巨人，反而要像钟表匠一样把小齿轮彼此精密地连接在一起。以后应用接口的时候更需要这样。 为什么呢？ 第一是<strong>便于debug</strong>，就像上面讲的面向对象原理一样，功能分离就可以把确定无误的功能和模棱两可的功能分离开，出现问题主要去检查容易出错的函数就可以。 另一个，也就是最重要的一个原因就是<strong>降低代码复现率，提高编程效率</strong>。因为我们定义好函数之后便可无限使用，把某些经常需要用的功能分离出来就可以少写很多代码，这个真的非常重要。 最后就是<strong>便于以后添加新功能</strong>，只要耦合度低了，要添加新功能时只要把前后衔接剪断，再接入新函数的两端即可。但是如果写成了一整个函数。。。后果不堪设想。</p>
<h4 id="⑵语义化！一定要语义化！"><a href="#⑵语义化！一定要语义化！" class="headerlink" title="⑵语义化！一定要语义化！"></a>⑵语义化！一定要语义化！</h4><p>设想有一天你接手别人的项目，突然出现那么一个函数：“<code>aaa()</code>”你说你气不气？这是干嘛的？什么意思？是不是想冲上去拧着那个人的耳朵到屏幕跟前让他解释一下？ 别说别人写的，某天自己的代码中出现一个当初随便起名的函数，你自己也恨不得扇自己两巴掌，但没办法，一小时写代码，两小时读代码，这样效率真的是太低了！ 看看课本上计算器那个例题，命名12个button就是b1一直到b12，可千万别跟他学，0到9尚且好说，如果让你说说乘号是b几，也得一个一个找吗？ 除了这些，某些语言自己就有命名标准，什么camel\\pascal命名标准，至少自己应该了解一下，以后看见名字得知道应该是个什么东西才行。 还有如果可以的话尽量为每个函数加注释，一般是两个内容，即<strong>函数的作用</strong>与<strong>函数的传入值是什么，返回值是什么</strong>。有了注释在将来维护的时候就可以大大减少工作量。</p>
<h4 id="⑶类的功能要唯一，该是什么类就干什么事"><a href="#⑶类的功能要唯一，该是什么类就干什么事" class="headerlink" title="⑶类的功能要唯一，该是什么类就干什么事"></a>⑶类的功能要唯一，该是什么类就干什么事</h4><p>再揪出课本来批：把main函数写在Student类里这种事以后可千万别干，Student是学生类，学生和main函数有什么关系？如果要写main函数<strong>专门建一个类</strong>，Student就是Student，Student不需要、也不能够包含main函数。 暂时想起这些，如果还有想起来的还会更新。</p>
<hr>
<p><strong>③的答案：</strong> 不能编译通过，因为其内部类Grading与QSGrading未实例化，应该分别将其实例化。改正方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student student1=<span class="keyword">new</span> Student();</span><br><span class="line">    Student student2=<span class="keyword">new</span> QSStudent();</span><br><span class="line">    QSStudent student3=<span class="keyword">new</span> QSStudent();</span><br><span class="line"></span><br><span class="line">    student1.grading=student1.<span class="function">new <span class="title">Grading</span><span class="params">()</span></span>;</span><br><span class="line">    student1.grading.english=<span class="number">90</span>;</span><br><span class="line">    student2.grading=student2.<span class="function">new <span class="title">Grading</span><span class="params">()</span></span>;</span><br><span class="line">    student2.grading.english=<span class="number">90</span>;</span><br><span class="line">    student3.grading=student3.<span class="function">new <span class="title">QSGrading</span><span class="params">()</span></span>;</span><br><span class="line">    student3.grading.english=<span class="number">90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再唠叨一下：之所以实例化student2的内部类使用Grading的构造方法而不是QSGrading的构造方法，是因为student2是使用多态产生的QSStudent对象，其中父类的内部类Grading与子类的内部类QSGrading类名不同，所以父类的内部类无法连接到子类的内部类，进而导致其中内部类只有Grading类没有QSGrading类。没有QSGrading类就当然没办法使用其构造方法了。</p>
<hr>
<p>最后祝各位空指针2019年都能找到对象 <a href="http://upane.cn/wp-content/uploads/2018/03/51.png"><img src="http://upane.cn/wp-content/uploads/2018/03/51.png" alt=""></a></p>
]]></content>
      <categories>
        <category>后院</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数的本质</title>
    <url>/2020/10/27/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.bilibili.com/video/BV1ys411472E">视频来自3Blue1Brown频道的“线性代数的本质”</a>，不同分p之间用分隔线分开。有个人理解，并非全部照抄，可能有省略，如果发现错误及建议欢迎在文章下方留言，我会及时改正。</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是向量？"><a href="#什么是向量？" class="headerlink" title="什么是向量？"></a>什么是向量？</h2><ol>
<li>物理学：向量是空间中的箭头，决定一个向量的是它的长度和它所指的方向。但是只要以上两个特征相同，你可以自由移动一个向量而保持它不变。处在平面上的向量是二维的，而处在真实世界中的向量是三维的。</li>
<li>计算机学：向量是有序的数字列表。“向量”只不过是“列表”的一个花哨的说法。向量的维度取决于列表的长度。</li>
<li>数学：向量可以是任何东西，只要保证两个向量相加以及数字与向量相乘有意义即可。</li>
</ol>
<h2 id="向量的表示方法"><a href="#向量的表示方法" class="headerlink" title="向量的表示方法"></a>向量的表示方法</h2><p>一个横坐标为-2，纵坐标为3的向量可以表示为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} -2  \\
3 \end{bmatrix}\quad</script><p><strong>纵向排列，第一个数是x轴坐标，第二个数是y轴坐标</strong>。</p>
<p>推而广之，一个三元向量的表示方法为:</p>
<script type="math/tex; mode=display">
\begin{bmatrix} 2 \\ 
1\\
3\end{bmatrix}\quad</script><p>同样，第一个数对应x轴，第二个数对应y轴，第三个数对应z轴。</p>
<h2 id="向量的加法"><a href="#向量的加法" class="headerlink" title="向量的加法"></a>向量的加法</h2><p>两个向量相加时，平移第二个向量，<strong>使它的起点与第一个向量的终点重合</strong>，和向量就是<strong>从第一个向量的起点出发，指向第二个向量终点</strong>的向量。</p>
<p><img src="https://www.z4a.net/images/2020/04/01/chrome_2020-04-01_18-14-28.jpg" alt=""></p>
<p><img src="https://www.z4a.net/images/2020/04/01/image09528e2d9c365a56.png" alt=""></p>
<h3 id="为什么如此定义？"><a href="#为什么如此定义？" class="headerlink" title="为什么如此定义？"></a>为什么如此定义？</h3><p>如果你先沿着第一个向量运动，然后再按照第二个向量所描述的运动方式运动，<strong>总体效果与你沿着这两个向量的和运动无异</strong></p>
<h3 id="如何计算？"><a href="#如何计算？" class="headerlink" title="如何计算？"></a>如何计算？</h3><p><strong>向量的各个维度依次相加</strong></p>
<script type="math/tex; mode=display">
\begin{bmatrix} 1 \\ 
2\end{bmatrix}
+
\begin{bmatrix} 3 \\ 
-1\end{bmatrix}

=
\begin{bmatrix} 1+3\\
2-(-1)\end{bmatrix}</script><p>从上式来看，运算规则可以简单记为<strong>对应项相加</strong></p>
<script type="math/tex; mode=display">
\begin{bmatrix} x_1 \\ 
y_1\\
\vdots\end{bmatrix}
+
\begin{bmatrix} x_2 \\ 
y_2\\
\vdots\end{bmatrix}

=
\begin{bmatrix} x_1+x_2\\
y_1+y_2\\
\vdots\end{bmatrix}\quad</script><h2 id="向量的乘法"><a href="#向量的乘法" class="headerlink" title="向量的乘法"></a>向量的乘法</h2><h3 id="向量与常数（标量）的乘法"><a href="#向量与常数（标量）的乘法" class="headerlink" title="向量与常数（标量）的乘法"></a>向量与常数（标量）的乘法</h3><h4 id="图像含义"><a href="#图像含义" class="headerlink" title="图像含义"></a>图像含义</h4><p>把该向量<strong>拉长\缩短</strong>为原来的常数倍，当常数是<strong>负数</strong>时，意味着先将该向量<strong>反向</strong>，然后拉长\缩短原来的常数倍。</p>
<p><img src="https://www.z4a.net/images/2020/04/01/imageaaf489c745073942.png" alt=""></p>
<h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><p>向量与标量相乘就是<strong>将向量中的每个分量与标量相乘</strong></p>
<script type="math/tex; mode=display">
2\cdot
\begin{bmatrix} x\\ 
y\\
\vdots\end{bmatrix}

=
\begin{bmatrix} 2x\\
2y\\
\vdots\end{bmatrix}</script><hr>
<h2 id="基向量"><a href="#基向量" class="headerlink" title="基向量"></a>基向量</h2><p>对于二维空间，<strong>x方向</strong>的单位向量称为i帽，<strong>y方向</strong>的单位向量成为j帽，分别写作</p>
<script type="math/tex; mode=display">
\hat i ,
\hat j</script><p>它们就是xy坐标系的“基向量”。</p>
<p>将向量看作这两个基向量的<strong>经过放缩的和</strong></p>
<script type="math/tex; mode=display">
\begin{bmatrix}3\\
-2\end{bmatrix}

=
(3)\hat i+(-2)\hat j</script><h3 id="如果我们选择不同的基向量会怎么样？"><a href="#如果我们选择不同的基向量会怎么样？" class="headerlink" title="如果我们选择不同的基向量会怎么样？"></a>如果我们选择不同的基向量会怎么样？</h3><p>会变成另一个新的坐标系</p>
<p>每当我们使用数字描述向量时，它都依赖于我们正在使用的基。</p>
<h2 id="线性组合"><a href="#线性组合" class="headerlink" title="线性组合"></a>线性组合</h2><p>两个数乘向量的和被称为这两个向量的线性组合</p>
<script type="math/tex; mode=display">
a\vec v+b\vec w</script><p>↑（v与w的线性组合，a与b是常量）</p>
<h3 id="什么是线性组合？"><a href="#什么是线性组合？" class="headerlink" title="什么是线性组合？"></a>什么是线性组合？</h3><p>如果<strong>固定</strong>其中一个标量，让另一个标量<strong>自由变化</strong>，所产生的<strong>向量终点</strong>会描出一条<strong>直线</strong>。</p>
<blockquote>
<p>线性关系：如果称一个数学函数L(x)是线性的，那么L(x)具有下面两条性质：</p>
<ol>
<li><strong>可加性：L(x+t)=L(x)+L(t)</strong></li>
<li><strong>一次齐次性：L(mx)=mL(x)</strong></li>
</ol>
</blockquote>
<h2 id="张成的空间"><a href="#张成的空间" class="headerlink" title="张成的空间"></a>张成的空间</h2><p>所有可以表示为给定向量<strong>线性组合</strong>的向量的<strong>集合</strong>，被称为给定向量<strong>张成的空间</strong>。</p>
<p><strong>理解：仅通过向量加法与向量数乘这两种基础运算，你能获得的所有可能向量的集合是什么</strong>。</p>
<h3 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h3><ol>
<li>在二维空间，当两基向量不共线时，张成的空间就是整个坐标系。</li>
<li>在二维空间，当两基向量共线时，张成的空间只有这条线的延长线</li>
<li>当基向量均为零向量时，张成的空间仅包括零向量</li>
</ol>
<h2 id="向量与点"><a href="#向量与点" class="headerlink" title="向量与点"></a>向量与点</h2><p>通常我们用向量的终点代表该向量</p>
<p>当只考虑一个向量时，就把它看作箭头，当你考虑多个向量时，就把他们看作点。</p>
<h2 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h2><p>一组向量中至少有一个是多余的（<strong>两向量共线</strong>），没有对张成空间做任何贡献；有多个向量，并且可以<strong>移除其中一个而不减小张成的空间</strong>，当这种情况发生时，我们称它们是<strong>线性相关</strong>的。</p>
<p>另一个表述方法是<strong>其中一个向量可以表示为其他向量的线性组合，因为这个向量已经落在其它向量张成的空间中。</strong></p>
<script type="math/tex; mode=display">
\vec u=a\vec v +b\vec w</script><p>↑（三维空间的三个基向量u、v、w）</p>
<p>另一方面，如果所有向量都给张成空间增添了新的维度，它们就被称为是<strong>线性无关</strong>的</p>
<script type="math/tex; mode=display">
\vec w\neq a \vec v</script><p>↑（二维空间的基向量w、v）</p>
<hr>
<h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>“变换”本质上是“函数”的一种花哨的说法，它接受输入内容，并输出对应结果。特别地，在线性代数的情况下，我们考虑的是<strong>接受一个向量并且输出一个向量的变换</strong></p>
<p>直观地说，如果一个变换具有以下两条性质，我们就称它是线性的：</p>
<ol>
<li>直线在变换后仍然保持为直线，不能有所弯曲</li>
<li>原点必须保持固定</li>
</ol>
<h3 id="变换类型"><a href="#变换类型" class="headerlink" title="变换类型"></a>变换类型</h3><p><strong>1.旋转</strong></p>
<p><img src="https://www.z4a.net/images/2020/04/02/0a0795da7a8a6425bcffaa64b7461ca8.gif" alt=""></p>
<p><strong>2.剪切</strong></p>
<p><img src="https://www.z4a.net/images/2020/04/02/1a9d3a84a6241707538fd2fd9b91cdd9.gif" alt=""></p>
<h3 id="如何用数值描述线性变换"><a href="#如何用数值描述线性变换" class="headerlink" title="如何用数值描述线性变换"></a>如何用数值描述线性变换</h3><p><strong>记录两基向量的位置，其他向量也会跟着变换</strong></p>
<p>变换前：</p>
<script type="math/tex; mode=display">
\vec v=-1\hat i+2\hat j</script><p>变换后：</p>
<script type="math/tex; mode=display">
\vec v=-1(变换后\hat i)+2(变换后\hat j)</script><p><img src="https://www.z4a.net/images/2020/04/02/image.png" alt=""></p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><script type="math/tex; mode=display">
\hat i \rightarrow 
\begin{bmatrix}1\\
-2\end{bmatrix}\quad \hat j \rightarrow
\begin{bmatrix}3\\
0\end{bmatrix}\\
\begin{bmatrix}x\\
y\end{bmatrix}\rightarrow 
x\begin{bmatrix}1\\
-2\end{bmatrix}+y\begin{bmatrix}3\\
0\end{bmatrix}=\begin{bmatrix}1x+3y\\
-2x+0y\end{bmatrix}</script><p>我们通常将变换后i与j的坐标包装在一个2*2的格子中，称它为2*2矩阵：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}1&3\\
-2&0\end{bmatrix}</script><p><strong>左列是变换后的i，右列是变换后的j</strong></p>
<p><strong>如果想了解线性变换对某个特定向量的作用，只需要取出向量的坐标，将他们分别与矩阵的特定列相乘，然后将结果相加即可。</strong></p>
<p>我们可以将其定义为<strong>矩阵的乘法</strong>：</p>
<script type="math/tex; mode=display">
\underbrace{
\begin{bmatrix}a&b\\
c&d\end{bmatrix}
}_{\text{应用的变换}}
\underbrace{
\begin{bmatrix}x\\
y\end{bmatrix}
}_{\text{被变换的向量}}=x
\begin{bmatrix}a\\
c\end{bmatrix}+y
\begin{bmatrix}b\\
d\end{bmatrix}=
\underbrace{
\begin{bmatrix}ax+by\\
cx+dy\end{bmatrix}
}_{\text{变换后的向量}}</script><p>这里矩阵放在左边，类似一个函数。但是我们完全可以把矩阵的列看作<strong>变换后的基向量</strong></p>
<blockquote>
<p>结论：以基向量变化后的坐标为列所构成的矩阵为我们提供了一种描述线性变换的语言，而矩阵向量乘法就是计算线性变换作用于给定向量的一种途径。这里重要的一点是，当你看到一个矩阵时，你都可以把它解读为对空间的一种特定变换。</p>
</blockquote>
<hr>
<h2 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h2><script type="math/tex; mode=display">
\underbrace{
\begin{bmatrix}1&1\\
0&1\end{bmatrix}
}_{\text{剪切矩阵}}
(\underbrace{
\begin{bmatrix}0&-1\\
1&0\end{bmatrix}
}_{\text{旋转矩阵}}
\begin{bmatrix}x\\
y\end{bmatrix})=
\underbrace{
\begin{bmatrix}1&-1\\
1&0\end{bmatrix}
}_{\text{复合矩阵}}
\begin{bmatrix}x\\
y\end{bmatrix}
\\ 
\Longrightarrow
\underbrace{
\begin{bmatrix}1&1\\
0&1\end{bmatrix}
}_{\text{剪切矩阵}}
\underbrace{
\begin{bmatrix}0&-1\\
1&0\end{bmatrix}
}_{\text{旋转矩阵}}=
\underbrace{
\begin{bmatrix}1&-1\\
1&0\end{bmatrix}
}_{\text{复合矩阵}}
\\ 
\xleftarrow{从右向左读}\quad\quad\quad\quad</script><p>如上式，对向量应用复合变换时，实际应用顺序应是先应用右边的矩阵，再应用左边的矩阵。</p>
<h3 id="计算方法-1"><a href="#计算方法-1" class="headerlink" title="计算方法"></a>计算方法</h3><script type="math/tex; mode=display">
\underbrace{
\begin{bmatrix}a&b\\
c&d\end{bmatrix}
}_{M_1}
\underbrace{
\begin{bmatrix}e&f\\
g&h\end{bmatrix}
}_{M_2}=
\begin{bmatrix}?&?\\
?&?\end{bmatrix}</script><p>要知道i帽首先去哪，先将右边矩阵M1的第一列取出，再应用于左边矩阵M2，得出的结果就是i帽在第二个变换作用后的结果：</p>
<script type="math/tex; mode=display">
\underbrace{
\begin{bmatrix}a&b\\
c&d\end{bmatrix}
}_{M_1}
\begin{bmatrix}e\\
g\end{bmatrix}=
e
\begin{bmatrix}a\\
c\end{bmatrix}
+
g\begin{bmatrix}b\\
d\end{bmatrix}=
\begin{bmatrix}ae+bg\\
ce+dg\end{bmatrix}
\\ 
\therefore
\underbrace{
\begin{bmatrix}a&b\\
c&d\end{bmatrix}
}_{M_1}
\underbrace{
\begin{bmatrix}e&f\\
g&h\end{bmatrix}
}_{M_2}=
\begin{bmatrix}ae+bg&?\\
ce+dg&?\end{bmatrix}</script><p>同样方法，可以求出j帽在第二个变换作用后的结果：</p>
<script type="math/tex; mode=display">
\underbrace{
\begin{bmatrix}a&b\\
c&d\end{bmatrix}
}_{M_1}
\begin{bmatrix}f\\
h\end{bmatrix}=
f
\begin{bmatrix}a\\
c\end{bmatrix}
+
h\begin{bmatrix}b\\
d\end{bmatrix}=
\begin{bmatrix}af+bh\\
cf+dh\end{bmatrix}
\\ 
\therefore
\underbrace{
\begin{bmatrix}a&b\\
c&d\end{bmatrix}
}_{M_1}
\underbrace{
\begin{bmatrix}c&d\\
g&h\end{bmatrix}
}_{M_2}=
\begin{bmatrix}ae+bg&af+bh\\
ce+dg&cf+dh\end{bmatrix}</script><h3 id="性质举例"><a href="#性质举例" class="headerlink" title="性质举例"></a>性质举例</h3><p>1.先旋转后剪切与先剪切后旋转，二者总体效应显然不同，<strong>所以乘积顺序显然会有影响</strong></p>
<script type="math/tex; mode=display">
M_1M_2\neq M_2M_1</script><p>2.结合律</p>
<script type="math/tex; mode=display">
M_1(M_2M_3)=(M_1M_2)M_3</script><p>(始终遵循<strong>从右向左</strong>的顺序，虽然运算单个矩阵的顺序有改变，<strong>但是整体顺序没有倒换</strong>)</p>
<hr>
<h2 id="线性变换的行列式"><a href="#线性变换的行列式" class="headerlink" title="线性变换的行列式"></a>线性变换的行列式</h2><p>线性变换前由基向量围成的面积（二维）与变换后基向量围成面积之比。</p>
<p><strong>→线性变换改变面积的比例</strong></p>
<p>例：一个线性变换的行列式是1/2，就是说它将一个区域的面积缩小一半。一个二位线性变换的行列式为0，说明它将整个平面压缩到<strong>一条线</strong>上，甚至是<strong>一个点</strong>上。</p>
<h3 id="一个区域的缩放为负数倍是什么意思？"><a href="#一个区域的缩放为负数倍是什么意思？" class="headerlink" title="一个区域的缩放为负数倍是什么意思？"></a>一个区域的缩放为负数倍是什么意思？</h3><p>如果将二维空间想象为一张纸，这个变换像是将纸<strong>反转到了另一面</strong>（空间的<strong>定向发生了改变</strong>）。换成图像意义，就是j帽移动到了i帽的右侧。</p>
<p>行列式的绝对值仍然是缩放面积的比例。</p>
<h3 id="三维空间的行列式"><a href="#三维空间的行列式" class="headerlink" title="三维空间的行列式"></a>三维空间的行列式</h3><p>它所表示的含义依然是变换前后的缩放比例，不过对三维空间则是<strong>体积的缩放</strong>。</p>
<p>当行列式为0时，则意味着整个空间被压缩为<strong>零体积</strong>的东西，也就是一个平面或者一条线，甚至是一个点。（线性相关）</p>
<p>当行列式为负数时，则代表<strong>变换后的空间已不符合“右手定则”</strong>。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><h4 id="二维行列式："><a href="#二维行列式：" class="headerlink" title="二维行列式："></a>二维行列式：</h4><script type="math/tex; mode=display">
\begin{vmatrix}a&b\\
c&d\end{vmatrix}=ad-bc</script><h4 id="三维行列式："><a href="#三维行列式：" class="headerlink" title="三维行列式："></a>三维行列式：</h4><script type="math/tex; mode=display">
\text{要计算方法去看同济版教材啊！！！那里教得比这里好！}</script><h3 id="性质举例-1"><a href="#性质举例-1" class="headerlink" title="性质举例"></a>性质举例</h3><script type="math/tex; mode=display">
\begin{vmatrix}M_1M_2\end{vmatrix}=\begin{vmatrix}M_1\end{vmatrix}\begin{vmatrix}M_2\end{vmatrix}</script><hr>
<h2 id="矩阵的用途"><a href="#矩阵的用途" class="headerlink" title="矩阵的用途"></a>矩阵的用途</h2><h3 id="解线性方程组"><a href="#解线性方程组" class="headerlink" title="解线性方程组"></a>解线性方程组</h3><p>对于以下方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
2x+5y+3z=-3\\
4x+0y+8z=0\\
1x+3y+0z=2
\end{cases}</script><p>即，在每个方程中，<strong>所有未知量只有常系数，这些未知量之间只进行加和</strong>。这种方程组称为<strong>线性方程组</strong>，可以交给矩阵来解。</p>
<p>要整理这一特定的方程组，一个典型的方法是未知量放在等号左边，剩余常数项放在等号右边，将未知量竖直对齐，必要时添加系数0。</p>
<p>它的样子与矩阵乘法相仿，所以可以将所有方程合并为一个向量方程：</p>
<script type="math/tex; mode=display">
\begin{cases}
2x+5y+3z=-3\\
4x+0y+8z=0\\
1x+3y+0z=2
\end{cases}
\Rightarrow
\underbrace{
\begin{bmatrix}2&5&3\\
4&0&8\\
1&3&0\end{bmatrix}
}_{\text{系数}}
\underbrace{
\begin{bmatrix}x\\
y\\
z\end{bmatrix}
}_{\text{未知变量}}=
\underbrace{
\begin{bmatrix}-3\\
0\\
2\end{bmatrix}
}_{\text{常数}}\\
即系数矩阵A、未知变量向量\vec x、常数向量\vec v符合：\\
A\vec x=\vec v</script><p>矩阵A代表一种线性变换，所以求解Ax=v意味着我们去寻找一个向量x，使得它变换后与v重合。</p>
<h2 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h2><p>以二维空间举例，若想寻找一个向量在变换前的位置，需要考虑施加的线性变换A<strong>是否将空间压缩为0</strong>，即它的行列式结果是否为0，若不为零，则代表<strong>有且仅有一个向量可变换到目前向量的位置</strong>，这时就需要对变换矩阵A进行<strong>逆变换</strong>。</p>
<p>如变换A的效果是将空间逆时针旋转90度，那么逆变换就是将空间顺时针旋转90度。</p>
<p>总的来说，A逆是满足以下效果的变换：</p>
<p><strong>首先应用A代表的变换，在应用A逆代表的变换，你会回到原始状态</strong></p>
<script type="math/tex; mode=display">
A^{-1}A=\underbrace{
\begin{bmatrix}1&0\\
0&1\end{bmatrix}
}_{\text{“什么都不做”的变换}}</script><p>当你找到A逆，你就可以带入Ax=v式，求得x：</p>
<script type="math/tex; mode=display">
\vec x=A^{-1}\vec v</script><p>只要变换A不将空间压缩到一个更低的维度上，也就是它的行列式不为零，拿他就存在逆变换，使得应用A在应用A逆变换之后，结果与恒等变换无异。而要想求解方程，只需要将A逆与向量v相乘即可。</p>
<p>但是当行列式为零时，与这个方程组相关的变换将空间压缩到更低的维度上，此时没有逆变换，<strong>不能将一条线“解压缩”为一个平面</strong>。</p>
<p><strong>即使不存在逆变换，解仍然可能存在</strong>，比如，向量v恰好处于压缩到的直线上。</p>
<h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><p>当变换的结果为一条直线时，也就是说结果是一维的，我们称这个变换的<strong>秩为1</strong>。如果变换后的向量落在某个二维平面上，我们称这个变换的秩为2。</p>
<p>所以说<strong>“秩”代表着变换后空间的维数</strong>。</p>
<p>不管是一条直线、一个平面还是三维空间等，<strong>所有可能的变换结果的集合被称为矩阵的“列空间”</strong>。</p>
<p>当秩达到最大时，意味着秩与列数相等，我们称为<strong>满秩</strong>。</p>
<blockquote>
<p>注：0向量必然存在在空间中，因为线性变换必须保持原点位置不变。</p>
</blockquote>
<p>变换后<strong>落在原点的向量</strong>的集合称为矩阵的<strong>“零空间”</strong>或“核”。对于Ax=v，当v恰好为零向量时，零空间给出的就是这个向量方程所有可能的解。</p>
<hr>
<h2 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h2><p>对于行与列不相等的矩阵：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}3&1\\
4&1\\
5&9\end{bmatrix}</script><p>可知，其由两个变换后的基向量（3，4，5）、（1，1，9）组成，<strong>列空间为2，而每个基向量却有三个维度</strong>，所以这是一个<strong>将二维向量提升至三维向量</strong>的过程。</p>
<script type="math/tex; mode=display">
每个变换后的基向量用三个坐标描述
\underbrace{
\begin{cases}
\begin{bmatrix}3&1\\
4&1\\
5&9\end{bmatrix}
\end{cases}
}_{\text{有两个基向量}}</script><p>所以，非方阵是<strong>可以将不同维度坐标系进行转换的变换</strong>。</p>
<hr>
<h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><h3 id="向量的点积"><a href="#向量的点积" class="headerlink" title="向量的点积"></a>向量的点积</h3><p>如果有两个<strong>维度相同的向量</strong>，求它们的点积，就是将对应坐标<strong>配对</strong>，求出<strong>每一对坐标的乘积</strong>，然后将结果<strong>相加</strong></p>
<script type="math/tex; mode=display">
\begin{bmatrix}2\\
7\\
1\end{bmatrix}
\cdot
\begin{bmatrix}8\\
2\\
8\end{bmatrix}=
2\cdot8+7\cdot2+1\cdot8</script><h4 id="图像意义"><a href="#图像意义" class="headerlink" title="图像意义"></a>图像意义</h4><p>对于两向量v、w，想象将向量w朝着过原点和向量v终点的直线上<strong>投影</strong>，将<strong>投影的长度</strong>与向量v的长度<strong>相乘</strong></p>
<p><img src="https://www.z4a.net/images/2020/04/03/chrome_2020-04-03_10-05-04.jpg" alt=""></p>
<script type="math/tex; mode=display">
\vec v \cdot \vec w=(\vec w投影的长度)(\vec v的长度)</script><p><strong>顺序无关，也可以是v的投影长度乘w的长度</strong></p>
<p>除非w的投影与v的方向<strong>相反</strong>，这种情况下点积为<strong>负值</strong>。</p>
<p>当它们<strong>相互垂直</strong>时，意味着一个向量在另一个向量上的投影为零向量，它们的点积为<strong>零</strong></p>
<h3 id="矩阵的点积（内积）"><a href="#矩阵的点积（内积）" class="headerlink" title="矩阵的点积（内积）"></a>矩阵的点积（内积）</h3><p>如果一个列矩阵乘一个行矩阵，其运算形式与两向量相乘形式类似：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}1&-2\end{bmatrix}
\begin{bmatrix}4\\
3\end{bmatrix}=4\cdot1+3\cdot-2=
\begin{bmatrix}1\\
-2\end{bmatrix}\cdot
\begin{bmatrix}4\\
3\end{bmatrix}</script><p>那么矩阵[1  -2]与向量(1,-2)有什么关系呢？</p>
<p>实际上，如果在二维坐标系中画出向量(1,-2)，那么矩阵[1  2]的含义就是<strong>将其他向量对应到向量(1,-2)所在的直线上。</strong></p>
<p><img src="https://www.z4a.net/images/2020/04/03/2020-04-03_12-15-51_Trim-1.gif" alt=""></p>
<p>根据对称性，将各向量投影到目标直线上时，它们的基向量的变化比<strong>恰好</strong>为直线上向量的坐标。</p>
<p><img src="https://www.z4a.net/images/2020/04/03/image.png" alt=""></p>
<p>像这样的巧合，称为<strong>对偶性</strong>。</p>
<hr>
<h2 id="叉积（外积）"><a href="#叉积（外积）" class="headerlink" title="叉积（外积）"></a>叉积（外积）</h2><h3 id="伪叉积"><a href="#伪叉积" class="headerlink" title="伪叉积"></a>伪叉积</h3><p>在二维坐标系中，如果有两个向量v和w，考虑他们所张成的平行四边形:</p>
<p><img src="https://www.z4a.net/images/2020/04/03/imagef1972429ce8dd1e4.png" alt=""></p>
<p>而v和w的叉积，就是这个平行四边形的<strong>面积</strong>。</p>
<p>另外，如果v在w的右侧，那么v与w的叉积为正；如果v在w的左侧，那么v与w的叉积为负。<strong>所以叉积是顺序有关的</strong>。</p>
<h3 id="计算方法-2"><a href="#计算方法-2" class="headerlink" title="计算方法"></a>计算方法</h3><p>因为矩阵的行列式的图像意义是变换前后面积比，而图像变化前面积为1，所以<strong>计算两向量的叉积时，可将两向量并成行列式计算</strong>。</p>
<script type="math/tex; mode=display">
\vec v=\begin{bmatrix}3\\
1\end{bmatrix}\quad\quad
\vec w=\begin{bmatrix}4\\
3\end{bmatrix}\\
\therefore \vec v \times \vec w=
\begin{vmatrix}3&2\\
1&-1\end{vmatrix}</script><h3 id="真叉积"><a href="#真叉积" class="headerlink" title="真叉积"></a>真叉积</h3><p>实际上，叉积并不在二维坐标系中存在，<strong>它是一个向量</strong>，刚刚算出的结果其实是叉积这个向量的<strong>模长</strong>。它存在于三维或更高维度坐标系中，是<strong>与两个向量为围成的平面垂直，并满足右手定则的方向</strong>。</p>
<p><img src="https://www.z4a.net/images/2020/04/03/imagec61e09a9eaceecb6.png" alt=""></p>
<p><img src="https://www.z4a.net/images/2020/04/03/image750feab4b9c94f8c.png" alt=""></p>
<h3 id="计算方法-3"><a href="#计算方法-3" class="headerlink" title="计算方法"></a>计算方法</h3><script type="math/tex; mode=display">
\begin{bmatrix}v_1\\
v_2\\
v_3\end{bmatrix}
\times \begin{bmatrix}w_1\\
w_2\\
w_3\end{bmatrix}

=
\begin{vmatrix}\hat i&v_1&w_2\\
\hat j&v_2&w_2\\
\hat k&v_3&w_3\end{vmatrix}</script><hr>
<h4 id="计算形式的解释"><a href="#计算形式的解释" class="headerlink" title="计算形式的解释"></a>计算形式的解释</h4><blockquote>
<p>每当看到一个从空间到数轴的线性变换，都能找到一个向量，被称为这个变换的对偶向量，使得线性变换与对偶向量点乘等价（点积章节对偶性）</p>
</blockquote>
<ol>
<li>根据v和w定义一个三维到一维的线性变换</li>
<li>找到它的对偶向量</li>
<li><p>说明这个对偶向量就是v*w</p>
<p>（待续）</p>
</li>
</ol>
<hr>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
